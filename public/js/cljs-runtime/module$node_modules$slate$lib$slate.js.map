{
"version":3,
"file":"module$node_modules$slate$lib$slate.js",
"lineCount":341,
"mappings":"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",
"sources":["node_modules/slate/lib/slate.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$slate$lib$slate\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar isPlainObject = _interopDefault(require('is-plain-object'));\nvar logger = _interopDefault(require('slate-dev-logger'));\nvar immutable = require('immutable');\nvar direction = _interopDefault(require('direction'));\nvar esrever = require('esrever');\nvar Debug = _interopDefault(require('debug'));\nvar isEqual = _interopDefault(require('lodash/isEqual'));\nvar mergeWith = _interopDefault(require('lodash/mergeWith'));\nvar slateSchemaViolations = require('slate-schema-violations');\nvar pick = _interopDefault(require('lodash/pick'));\nvar omit = _interopDefault(require('lodash/omit'));\nvar isEmpty = _interopDefault(require('is-empty'));\n\n/**\n * Slate-specific model types.\n *\n * @type {Object}\n */\n\nvar MODEL_TYPES = {\n  BLOCK: '@@__SLATE_BLOCK__@@',\n  CHANGE: '@@__SLATE_CHANGE__@@',\n  CHARACTER: '@@__SLATE_CHARACTER__@@',\n  DOCUMENT: '@@__SLATE_DOCUMENT__@@',\n  HISTORY: '@@__SLATE_HISTORY__@@',\n  INLINE: '@@__SLATE_INLINE__@@',\n  LEAF: '@@__SLATE_LEAF__@@',\n  MARK: '@@__SLATE_MARK__@@',\n  OPERATION: '@@__SLATE_OPERATION__@@',\n  RANGE: '@@__SLATE_RANGE__@@',\n  SCHEMA: '@@__SLATE_SCHEMA__@@',\n  STACK: '@@__SLATE_STACK__@@',\n  TEXT: '@@__SLATE_TEXT__@@',\n  VALUE: '@@__SLATE_VALUE__@@'\n\n  /**\n   * Export type identification function\n   *\n   * @param {string} type\n   * @param {any} any\n   * @return {boolean}\n   */\n\n};function isType(type, any) {\n  return !!(any && any[MODEL_TYPES[type]]);\n}\n\n/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nvar n = void 0;\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nvar generate = void 0;\n\n/**\n * Generate a key.\n *\n * @return {String}\n */\n\nfunction generateKey() {\n  return generate();\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setKeyGenerator(func) {\n  generate = func;\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetKeyGenerator() {\n  n = 0;\n  generate = function generate() {\n    return \"\" + n++;\n  };\n}\n\n/**\n * Set the initial state.\n */\n\nresetKeyGenerator();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/**\n * Dependencies.\n */\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  data: new immutable.Map(),\n  isVoid: false,\n  key: undefined,\n  nodes: new immutable.List(),\n  type: undefined\n\n  /**\n   * Block.\n   *\n   * @type {Block}\n   */\n\n};\nvar Block = function (_Record) {\n  inherits(Block, _Record);\n\n  function Block() {\n    classCallCheck(this, Block);\n    return possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).apply(this, arguments));\n  }\n\n  createClass(Block, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the block.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        type: this.type,\n        isVoid: this.isVoid,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS(options) {\n      return this.toJSON(options);\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'block';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n\n    /**\n     * Check if the block is empty.\n     * Returns true if block is not void and all it's children nodes are empty.\n     * Void node is never empty, regardless of it's content.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get$$1() {\n      return !this.isVoid && !this.nodes.some(function (child) {\n        return !child.isEmpty;\n      });\n    }\n\n    /**\n     * Get the concatenated text of all the block's children.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get$$1() {\n      return this.getText();\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Block` from `attrs`.\n     *\n     * @param {Object|String|Block} attrs\n     * @return {Block}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Block.isBlock(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs == 'string') {\n        attrs = { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Block.fromJSON(attrs);\n      }\n\n      throw new Error('`Block.create` only accepts objects, strings or blocks, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Blocks` from `attrs`.\n     *\n     * @param {Array<Block|Object>|List<Block|Object>} attrs\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(attrs) || Array.isArray(attrs)) {\n        var list = new immutable.List(attrs.map(Block.create));\n        return list;\n      }\n\n      throw new Error('`Block.createList` only accepts arrays or lists, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Block` from a JSON `object`.\n     *\n     * @param {Object|Block} object\n     * @return {Block}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Block.isBlock(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$isVoid = object.isVoid,\n          isVoid = _object$isVoid === undefined ? false : _object$isVoid,\n          _object$key = object.key,\n          key = _object$key === undefined ? generateKey() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes,\n          type = object.type;\n\n\n      if (typeof type != 'string') {\n        throw new Error('`Block.fromJSON` requires a `type` string.');\n      }\n\n      var block = new Block({\n        key: key,\n        type: type,\n        isVoid: !!isVoid,\n        data: immutable.Map(data),\n        nodes: Block.createChildren(nodes)\n      });\n\n      return block;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Block`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlockList',\n\n\n    /**\n     * Check if `any` is a block list.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isBlockList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Block.isBlock(item);\n      });\n    }\n  }]);\n  return Block;\n}(immutable.Record(DEFAULTS));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nBlock.fromJS = Block.fromJSON;\nBlock.isBlock = isType.bind(null, 'BLOCK');\nBlock.prototype[MODEL_TYPES.BLOCK] = true;\n\n/**\n * Dependencies.\n */\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$1 = {\n  data: new immutable.Map(),\n  isVoid: false,\n  key: undefined,\n  nodes: new immutable.List(),\n  type: undefined\n\n  /**\n   * Inline.\n   *\n   * @type {Inline}\n   */\n\n};\nvar Inline = function (_Record) {\n  inherits(Inline, _Record);\n\n  function Inline() {\n    classCallCheck(this, Inline);\n    return possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));\n  }\n\n  createClass(Inline, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the inline.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        type: this.type,\n        isVoid: this.isVoid,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS(options) {\n      return this.toJSON(options);\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'inline';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n\n    /**\n     * Check if the inline is empty.\n     * Returns true if inline is not void and all it's children nodes are empty.\n     * Void node is never empty, regardless of it's content.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get$$1() {\n      return !this.isVoid && !this.nodes.some(function (child) {\n        return !child.isEmpty;\n      });\n    }\n\n    /**\n     * Get the concatenated text of all the inline's children.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get$$1() {\n      return this.getText();\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Inline` with `attrs`.\n     *\n     * @param {Object|String|Inline} attrs\n     * @return {Inline}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Inline.isInline(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs == 'string') {\n        attrs = { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Inline.fromJSON(attrs);\n      }\n\n      throw new Error('`Inline.create` only accepts objects, strings or inlines, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Inlines` from an array.\n     *\n     * @param {Array<Inline|Object>|List<Inline|Object>} elements\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Inline.create));\n        return list;\n      }\n\n      throw new Error('`Inline.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a `Inline` from a JSON `object`.\n     *\n     * @param {Object|Inline} object\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Inline.isInline(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$isVoid = object.isVoid,\n          isVoid = _object$isVoid === undefined ? false : _object$isVoid,\n          _object$key = object.key,\n          key = _object$key === undefined ? generateKey() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes,\n          type = object.type;\n\n\n      if (typeof type != 'string') {\n        throw new Error('`Inline.fromJS` requires a `type` string.');\n      }\n\n      var inline = new Inline({\n        key: key,\n        type: type,\n        isVoid: !!isVoid,\n        data: new immutable.Map(data),\n        nodes: Inline.createChildren(nodes)\n      });\n\n      return inline;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Inline`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInlineList',\n\n\n    /**\n     * Check if `any` is a list of inlines.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isInlineList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Inline.isInline(item);\n      });\n    }\n  }]);\n  return Inline;\n}(immutable.Record(DEFAULTS$1));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nInline.fromJS = Inline.fromJSON;\nInline.isInline = isType.bind(null, 'INLINE');\nInline.prototype[MODEL_TYPES.INLINE] = true;\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nvar Data = function () {\n  function Data() {\n    classCallCheck(this, Data);\n  }\n\n  createClass(Data, null, [{\n    key: 'create',\n\n    /**\n     * Create a new `Data` with `attrs`.\n     *\n     * @param {Object|Data|Map} attrs\n     * @return {Data} data\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (immutable.Map.isMap(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Data.fromJSON(attrs);\n      }\n\n      throw new Error('`Data.create` only accepts objects or maps, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Data` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Data}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      return new immutable.Map(object);\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }]);\n  return Data;\n}();\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nData.fromJS = Data.fromJSON;\n\n/**\n * GLOBAL: True if memoization should is enabled.\n *\n * @type {Boolean}\n */\n\nvar ENABLED = true;\n\n/**\n * GLOBAL: Changing this cache key will clear all previous cached results.\n *\n * @type {Number}\n */\n\nvar CACHE_KEY = 0;\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Object}\n */\n\nvar LEAF = {};\n\n/**\n * A value to represent a memoized undefined value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Object}\n */\n\nvar UNDEFINED = {};\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nvar UNSET = undefined;\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  var _loop = function _loop(property) {\n    var original = object[property];\n\n    if (!original) {\n      throw new Error(\"Object does not have a property named \\\"\" + property + \"\\\".\");\n    }\n\n    object[property] = function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // If memoization is disabled, call into the original method.\n      if (!ENABLED) return original.apply(this, args);\n\n      // If the cache key is different, previous caches must be cleared.\n      if (CACHE_KEY !== this.__cache_key) {\n        this.__cache_key = CACHE_KEY;\n        this.__cache = new Map(); // eslint-disable-line no-undef,no-restricted-globals\n        this.__cache_no_args = {};\n      }\n\n      if (!this.__cache) {\n        this.__cache = new Map(); // eslint-disable-line no-undef,no-restricted-globals\n      }\n\n      if (!this.__cache_no_args) {\n        this.__cache_no_args = {};\n      }\n\n      var takesArguments = args.length !== 0;\n\n      var cachedValue = void 0;\n      var keys = void 0;\n\n      if (takesArguments) {\n        keys = [property].concat(args);\n        cachedValue = getIn(this.__cache, keys);\n      } else {\n        cachedValue = this.__cache_no_args[property];\n      }\n\n      // If we've got a result already, return it.\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue;\n      }\n\n      // Otherwise calculate what it should be once and cache it.\n      var value = original.apply(this, args);\n      var v = value === undefined ? UNDEFINED : value;\n\n      if (takesArguments) {\n        this.__cache = setIn(this.__cache, keys, v);\n      } else {\n        this.__cache_no_args[property] = v;\n      }\n\n      return value;\n    };\n  };\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n\n      _loop(property);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var key = _step2.value;\n\n      map = map.get(key);\n      if (map === UNSET) return UNSET;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return map.get(LEAF);\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  var parent = map;\n  var child = void 0;\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var key = _step3.value;\n\n      child = parent.get(key);\n\n      // If the path was not created yet...\n      if (child === UNSET) {\n        child = new Map(); // eslint-disable-line no-undef,no-restricted-globals\n        parent.set(key, child);\n      }\n\n      parent = child;\n    }\n\n    // The whole path has been created, so set the value to the bottom most map.\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  child.set(LEAF, value);\n  return map;\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction resetMemoization() {\n  CACHE_KEY++;\n\n  if (CACHE_KEY >= Number.MAX_SAFE_INTEGER) {\n    CACHE_KEY = 0;\n  }\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled;\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$2 = {\n  data: new immutable.Map(),\n  type: undefined\n\n  /**\n   * Mark.\n   *\n   * @type {Mark}\n   */\n\n};\nvar Mark = function (_Record) {\n  inherits(Mark, _Record);\n\n  function Mark() {\n    classCallCheck(this, Mark);\n    return possibleConstructorReturn(this, (Mark.__proto__ || Object.getPrototypeOf(Mark)).apply(this, arguments));\n  }\n\n  createClass(Mark, [{\n    key: 'getComponent',\n\n\n    /**\n     * Get the component for the node from a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Component|Void}\n     */\n\n    value: function getComponent(schema) {\n      return schema.__getComponent(this);\n    }\n\n    /**\n     * Return a JSON representation of the mark.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON()\n      };\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS() {\n      return this.toJSON();\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     */\n\n    get: function get$$1() {\n      return 'mark';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Mark` with `attrs`.\n     *\n     * @param {Object|Mark} attrs\n     * @return {Mark}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Mark.isMark(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs == 'string') {\n        attrs = { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Mark.fromJSON(attrs);\n      }\n\n      throw new Error('`Mark.create` only accepts objects, strings or marks, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a set of marks.\n     *\n     * @param {Array<Object|Mark>} elements\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'createSet',\n    value: function createSet(elements) {\n      if (immutable.Set.isSet(elements) || Array.isArray(elements)) {\n        var marks = new immutable.Set(elements.map(Mark.create));\n        return marks;\n      }\n\n      if (elements == null) {\n        return immutable.Set();\n      }\n\n      throw new Error('`Mark.createSet` only accepts sets, arrays or null, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a dictionary of settable mark properties from `attrs`.\n     *\n     * @param {Object|String|Mark} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Mark.isMark(attrs)) {\n        return {\n          data: attrs.data,\n          type: attrs.type\n        };\n      }\n\n      if (typeof attrs == 'string') {\n        return { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        var props = {};\n        if ('type' in attrs) props.type = attrs.type;\n        if ('data' in attrs) props.data = Data.create(attrs.data);\n        return props;\n      }\n\n      throw new Error('`Mark.createProperties` only accepts objects, strings or marks, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Mark` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Mark}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          type = object.type;\n\n\n      if (typeof type != 'string') {\n        throw new Error('`Mark.fromJS` requires a `type` string.');\n      }\n\n      var mark = new Mark({\n        type: type,\n        data: new immutable.Map(data)\n      });\n\n      return mark;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Mark`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isMarkSet',\n\n\n    /**\n     * Check if `any` is a set of marks.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isMarkSet(any) {\n      return immutable.Set.isSet(any) && any.every(function (item) {\n        return Mark.isMark(item);\n      });\n    }\n  }]);\n  return Mark;\n}(immutable.Record(DEFAULTS$2));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nMark.fromJS = Mark.fromJSON;\nMark.isMark = isType.bind(null, 'MARK');\nMark.prototype[MODEL_TYPES.MARK] = true;\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Mark.prototype, ['getComponent']);\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes = {};\n\n/**\n * Mix in the changes that pass through to their at-range equivalents because\n * they don't have any effect on the selection.\n */\n\nvar PROXY_TRANSFORMS = ['deleteBackward', 'deleteCharBackward', 'deleteLineBackward', 'deleteWordBackward', 'deleteForward', 'deleteCharForward', 'deleteWordForward', 'deleteLineForward', 'setBlocks', 'setInlines', 'splitInline', 'unwrapBlock', 'unwrapInline', 'wrapBlock', 'wrapInline'];\n\nPROXY_TRANSFORMS.forEach(function (method) {\n  Changes[method] = function (change) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var value = change.value;\n    var selection = value.selection;\n\n    var methodAtRange = method + 'AtRange';\n    change[methodAtRange].apply(change, [selection].concat(args));\n\n    if (method.match(/Backward$/)) {\n      change.collapseToStart();\n    } else if (method.match(/Forward$/)) {\n      change.collapseToEnd();\n    }\n  };\n});\n\nChanges.setBlock = function () {\n  logger.deprecate('slate@0.33.0', 'The `setBlock` method of Slate changes has been renamed to `setBlocks`.');\n\n  Changes.setBlocks.apply(Changes, arguments);\n};\n\nChanges.setInline = function () {\n  logger.deprecate('slate@0.33.0', 'The `setInline` method of Slate changes has been renamed to `setInlines`.');\n\n  Changes.setInlines.apply(Changes, arguments);\n};\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMark = function (change, mark) {\n  mark = Mark.create(mark);\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    change.addMarkAtRange(selection, mark);\n  } else if (selection.marks) {\n    var marks = selection.marks.add(mark);\n    var sel = selection.set('marks', marks);\n    change.select(sel);\n  } else {\n    var _marks = document.getActiveMarksAtRange(selection).add(mark);\n    var _sel = selection.set('marks', _marks);\n    change.select(_sel);\n  }\n};\n\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMarks = function (change, marks) {\n  marks.forEach(function (mark) {\n    return change.addMark(mark);\n  });\n};\n\n/**\n * Delete at the current selection.\n *\n * @param {Change} change\n */\n\nChanges.delete = function (change) {\n  var value = change.value;\n  var selection = value.selection;\n\n  change.deleteAtRange(selection);\n\n  // Ensure that the selection is collapsed to the start, because in certain\n  // cases when deleting across inline nodes, when splitting the inline node the\n  // end point of the selection will end up after the split point.\n  change.collapseToStart();\n};\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Block} block\n */\n\nChanges.insertBlock = function (change, block) {\n  block = Block.create(block);\n  var value = change.value;\n  var selection = value.selection;\n\n  change.insertBlockAtRange(selection, block);\n\n  // If the node was successfully inserted, update the selection.\n  var node = change.value.document.getNode(block.key);\n  if (node) change.collapseToEndOf(node);\n};\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Change} change\n * @param {Document} fragment\n */\n\nChanges.insertFragment = function (change, fragment) {\n  if (!fragment.nodes.size) return;\n\n  var value = change.value;\n  var _value = value,\n      document = _value.document,\n      selection = _value.selection;\n  var _value2 = value,\n      startText = _value2.startText,\n      endText = _value2.endText,\n      startInline = _value2.startInline;\n\n  var lastText = fragment.getLastText();\n  var lastInline = fragment.getClosestInline(lastText.key);\n  var firstChild = fragment.nodes.first();\n  var lastChild = fragment.nodes.last();\n  var keys = document.getTexts().map(function (text) {\n    return text.key;\n  });\n  var isAppending = !startInline || selection.hasEdgeAtStartOf(startText) || selection.hasEdgeAtEndOf(endText);\n\n  var isInserting = fragment.hasBlocks(firstChild.key) || fragment.hasBlocks(lastChild.key);\n\n  change.insertFragmentAtRange(selection, fragment);\n  value = change.value;\n  document = value.document;\n\n  var newTexts = document.getTexts().filter(function (n) {\n    return !keys.includes(n.key);\n  });\n  var newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first();\n\n  if (newText && (lastInline || isInserting)) {\n    change.select(selection.collapseToEndOf(newText));\n  } else if (newText) {\n    change.select(selection.collapseToStartOf(newText).move(lastText.text.length));\n  } else {\n    change.select(selection.collapseToStart().move(lastText.text.length));\n  }\n};\n\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Inline} inline\n */\n\nChanges.insertInline = function (change, inline) {\n  inline = Inline.create(inline);\n  var value = change.value;\n  var selection = value.selection;\n\n  change.insertInlineAtRange(selection, inline);\n\n  // If the node was successfully inserted, update the selection.\n  var node = change.value.document.getNode(inline.key);\n  if (node) change.collapseToEndOf(node);\n};\n\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Change} change\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nChanges.insertText = function (change, text, marks) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection);\n  change.insertTextAtRange(selection, text, marks);\n\n  // If the text was successfully inserted, and the selection had marks on it,\n  // unset the selection's marks.\n  if (selection.marks && document != change.value.document) {\n    change.select({ marks: null });\n  }\n};\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Change} change\n * @param {Number} depth (optional)\n */\n\nChanges.splitBlock = function (change) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var value = change.value;\n  var selection = value.selection,\n      document = value.document;\n\n  var marks = selection.marks || document.getInsertMarksAtRange(selection);\n  change.splitBlockAtRange(selection, depth).collapseToEnd();\n\n  if (marks && marks.size !== 0) {\n    change.select({ marks: marks });\n  }\n};\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.removeMark = function (change, mark) {\n  mark = Mark.create(mark);\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    change.removeMarkAtRange(selection, mark);\n  } else if (selection.marks) {\n    var marks = selection.marks.remove(mark);\n    var sel = selection.set('marks', marks);\n    change.select(sel);\n  } else {\n    var _marks2 = document.getActiveMarksAtRange(selection).remove(mark);\n    var _sel2 = selection.set('marks', _marks2);\n    change.select(_sel2);\n  }\n};\n\n/**\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} oldMark\n * @param {Mark} newMark\n */\n\nChanges.replaceMark = function (change, oldMark, newMark) {\n  change.removeMark(oldMark);\n  change.addMark(newMark);\n};\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.toggleMark = function (change, mark) {\n  mark = Mark.create(mark);\n  var value = change.value;\n\n  var exists = value.activeMarks.has(mark);\n\n  if (exists) {\n    change.removeMark(mark);\n  } else {\n    change.addMark(mark);\n  }\n};\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Change} change\n * @param {String} prefix\n * @param {String} suffix\n */\n\nChanges.wrapText = function (change, prefix) {\n  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prefix;\n  var value = change.value;\n  var selection = value.selection;\n\n  change.wrapTextAtRange(selection, prefix, suffix);\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    change.moveStart(0 - prefix.length);\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  change.moveEnd(0 - suffix.length);\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward != change.value.selection.isForward) {\n    change.flip();\n  }\n};\n\n/**\n * Dependencies.\n */\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$3 = {\n  data: new immutable.Map(),\n  key: undefined,\n  nodes: new immutable.List()\n\n  /**\n   * Document.\n   *\n   * @type {Document}\n   */\n\n};\nvar Document = function (_Record) {\n  inherits(Document, _Record);\n\n  function Document() {\n    classCallCheck(this, Document);\n    return possibleConstructorReturn(this, (Document.__proto__ || Object.getPrototypeOf(Document)).apply(this, arguments));\n  }\n\n  createClass(Document, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the document.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS(options) {\n      return this.toJSON(options);\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'document';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n\n    /**\n     * Check if the document is empty.\n     * Returns true if all it's children nodes are empty.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get$$1() {\n      return !this.nodes.some(function (child) {\n        return !child.isEmpty;\n      });\n    }\n\n    /**\n     * Get the concatenated text of all the document's children.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get$$1() {\n      return this.getText();\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Document` with `attrs`.\n     *\n     * @param {Object|Array|List|Text} attrs\n     * @return {Document}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Document.isDocument(attrs)) {\n        return attrs;\n      }\n\n      if (immutable.List.isList(attrs) || Array.isArray(attrs)) {\n        attrs = { nodes: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Document.fromJSON(attrs);\n      }\n\n      throw new Error('`Document.create` only accepts objects, arrays, lists or documents, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Document` from a JSON `object`.\n     *\n     * @param {Object|Document} object\n     * @return {Document}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Document.isDocument(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$key = object.key,\n          key = _object$key === undefined ? generateKey() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes;\n\n\n      var document = new Document({\n        key: key,\n        data: new immutable.Map(data),\n        nodes: Document.createChildren(nodes)\n      });\n\n      return document;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Document`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }]);\n  return Document;\n}(immutable.Record(DEFAULTS$3));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nDocument.fromJS = Document.fromJSON;\nDocument.isDocument = isType.bind(null, 'DOCUMENT');\nDocument.prototype[MODEL_TYPES.DOCUMENT] = true;\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$4 = {\n  anchorKey: null,\n  anchorOffset: 0,\n  focusKey: null,\n  focusOffset: 0,\n  isBackward: null,\n  isFocused: false,\n  marks: null,\n  isAtomic: false\n\n  /**\n   * Range.\n   *\n   * @type {Range}\n   */\n\n};\nvar Range = function (_Record) {\n  inherits(Range, _Record);\n\n  function Range() {\n    classCallCheck(this, Range);\n    return possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).apply(this, arguments));\n  }\n\n  createClass(Range, [{\n    key: 'hasAnchorAtStartOf',\n\n\n    /**\n     * Check whether anchor point of the range is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n    value: function hasAnchorAtStartOf(node) {\n      // PERF: Do a check for a `0` offset first since it's quickest.\n      if (this.anchorOffset != 0) return false;\n      var first = getFirst(node);\n      return this.anchorKey == first.key;\n    }\n\n    /**\n     * Check whether anchor point of the range is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasAnchorAtEndOf',\n    value: function hasAnchorAtEndOf(node) {\n      var last = getLast(node);\n      return this.anchorKey == last.key && this.anchorOffset == last.text.length;\n    }\n\n    /**\n     * Check whether the anchor edge of a range is in a `node` and at an\n     * offset between `start` and `end`.\n     *\n     * @param {Node} node\n     * @param {Number} start\n     * @param {Number} end\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasAnchorBetween',\n    value: function hasAnchorBetween(node, start, end) {\n      return this.anchorOffset <= end && start <= this.anchorOffset && this.hasAnchorIn(node);\n    }\n\n    /**\n     * Check whether the anchor edge of a range is in a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasAnchorIn',\n    value: function hasAnchorIn(node) {\n      return node.object == 'text' ? node.key == this.anchorKey : this.anchorKey != null && node.hasDescendant(this.anchorKey);\n    }\n\n    /**\n     * Check whether focus point of the range is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusAtEndOf',\n    value: function hasFocusAtEndOf(node) {\n      var last = getLast(node);\n      return this.focusKey == last.key && this.focusOffset == last.text.length;\n    }\n\n    /**\n     * Check whether focus point of the range is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusAtStartOf',\n    value: function hasFocusAtStartOf(node) {\n      if (this.focusOffset != 0) return false;\n      var first = getFirst(node);\n      return this.focusKey == first.key;\n    }\n\n    /**\n     * Check whether the focus edge of a range is in a `node` and at an\n     * offset between `start` and `end`.\n     *\n     * @param {Node} node\n     * @param {Number} start\n     * @param {Number} end\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusBetween',\n    value: function hasFocusBetween(node, start, end) {\n      return start <= this.focusOffset && this.focusOffset <= end && this.hasFocusIn(node);\n    }\n\n    /**\n     * Check whether the focus edge of a range is in a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusIn',\n    value: function hasFocusIn(node) {\n      return node.object == 'text' ? node.key == this.focusKey : this.focusKey != null && node.hasDescendant(this.focusKey);\n    }\n\n    /**\n     * Check whether the range is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtStartOf',\n    value: function isAtStartOf(node) {\n      return this.isCollapsed && this.hasAnchorAtStartOf(node);\n    }\n\n    /**\n     * Check whether the range is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtEndOf',\n    value: function isAtEndOf(node) {\n      return this.isCollapsed && this.hasAnchorAtEndOf(node);\n    }\n\n    /**\n     * Focus the range.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'focus',\n    value: function focus() {\n      return this.merge({\n        isFocused: true\n      });\n    }\n\n    /**\n     * Blur the range.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'blur',\n    value: function blur() {\n      return this.merge({\n        isFocused: false\n      });\n    }\n\n    /**\n     * Unset the range.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'deselect',\n    value: function deselect() {\n      return this.merge({\n        anchorKey: null,\n        anchorOffset: 0,\n        focusKey: null,\n        focusOffset: 0,\n        isFocused: false,\n        isBackward: false\n      });\n    }\n\n    /**\n     * Flip the range.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'flip',\n    value: function flip() {\n      return this.merge({\n        anchorKey: this.focusKey,\n        anchorOffset: this.focusOffset,\n        focusKey: this.anchorKey,\n        focusOffset: this.anchorOffset,\n        isBackward: this.isBackward == null ? null : !this.isBackward\n      });\n    }\n\n    /**\n     * Move the anchor offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchor',\n    value: function moveAnchor() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var anchorKey = this.anchorKey,\n          focusKey = this.focusKey,\n          focusOffset = this.focusOffset,\n          isBackward = this.isBackward;\n\n      var anchorOffset = this.anchorOffset + n;\n      return this.merge({\n        anchorOffset: anchorOffset,\n        isBackward: anchorKey == focusKey ? anchorOffset > focusOffset : isBackward\n      });\n    }\n\n    /**\n     * Move the anchor offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocus',\n    value: function moveFocus() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var anchorKey = this.anchorKey,\n          anchorOffset = this.anchorOffset,\n          focusKey = this.focusKey,\n          isBackward = this.isBackward;\n\n      var focusOffset = this.focusOffset + n;\n      return this.merge({\n        focusOffset: focusOffset,\n        isBackward: focusKey == anchorKey ? anchorOffset > focusOffset : isBackward\n      });\n    }\n\n    /**\n     * Move the range's anchor point to a `key` and `offset`.\n     *\n     * @param {String} key\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorTo',\n    value: function moveAnchorTo(key, offset) {\n      var anchorKey = this.anchorKey,\n          focusKey = this.focusKey,\n          focusOffset = this.focusOffset,\n          isBackward = this.isBackward;\n\n      return this.merge({\n        anchorKey: key,\n        anchorOffset: offset,\n        isBackward: key == focusKey ? offset > focusOffset : key == anchorKey ? isBackward : null\n      });\n    }\n\n    /**\n     * Move the range's focus point to a `key` and `offset`.\n     *\n     * @param {String} key\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusTo',\n    value: function moveFocusTo(key, offset) {\n      var focusKey = this.focusKey,\n          anchorKey = this.anchorKey,\n          anchorOffset = this.anchorOffset,\n          isBackward = this.isBackward;\n\n      return this.merge({\n        focusKey: key,\n        focusOffset: offset,\n        isBackward: key == anchorKey ? anchorOffset > offset : key == focusKey ? isBackward : null\n      });\n    }\n\n    /**\n     * Move the range to `anchorOffset`.\n     *\n     * @param {Number} anchorOffset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorOffsetTo',\n    value: function moveAnchorOffsetTo(anchorOffset) {\n      return this.merge({\n        anchorOffset: anchorOffset,\n        isBackward: this.anchorKey == this.focusKey ? anchorOffset > this.focusOffset : this.isBackward\n      });\n    }\n\n    /**\n     * Move the range to `focusOffset`.\n     *\n     * @param {Number} focusOffset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusOffsetTo',\n    value: function moveFocusOffsetTo(focusOffset) {\n      return this.merge({\n        focusOffset: focusOffset,\n        isBackward: this.anchorKey == this.focusKey ? this.anchorOffset > focusOffset : this.isBackward\n      });\n    }\n\n    /**\n     * Move the range to `anchorOffset` and `focusOffset`.\n     *\n     * @param {Number} anchorOffset\n     * @param {Number} focusOffset (optional)\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveOffsetsTo',\n    value: function moveOffsetsTo(anchorOffset) {\n      var focusOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : anchorOffset;\n\n      return this.moveAnchorOffsetTo(anchorOffset).moveFocusOffsetTo(focusOffset);\n    }\n\n    /**\n     * Move the focus point to the anchor point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToAnchor',\n    value: function moveToAnchor() {\n      return this.moveFocusTo(this.anchorKey, this.anchorOffset);\n    }\n\n    /**\n     * Move the anchor point to the focus point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToFocus',\n    value: function moveToFocus() {\n      return this.moveAnchorTo(this.focusKey, this.focusOffset);\n    }\n\n    /**\n     * Move the range's anchor point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorToStartOf',\n    value: function moveAnchorToStartOf(node) {\n      node = getFirst(node);\n      return this.moveAnchorTo(node.key, 0);\n    }\n\n    /**\n     * Move the range's anchor point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorToEndOf',\n    value: function moveAnchorToEndOf(node) {\n      node = getLast(node);\n      return this.moveAnchorTo(node.key, node.text.length);\n    }\n\n    /**\n     * Move the range's focus point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusToStartOf',\n    value: function moveFocusToStartOf(node) {\n      node = getFirst(node);\n      return this.moveFocusTo(node.key, 0);\n    }\n\n    /**\n     * Move the range's focus point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusToEndOf',\n    value: function moveFocusToEndOf(node) {\n      node = getLast(node);\n      return this.moveFocusTo(node.key, node.text.length);\n    }\n\n    /**\n     * Move to the entire range of `start` and `end` nodes.\n     *\n     * @param {Node} start\n     * @param {Node} end (optional)\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToRangeOf',\n    value: function moveToRangeOf(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;\n\n      var range = this.isBackward ? this.flip() : this;\n      return range.moveAnchorToStartOf(start).moveFocusToEndOf(end);\n    }\n\n    /**\n     * Normalize the range, relative to a `node`, ensuring that the anchor\n     * and focus nodes of the range always refer to leaf text nodes.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(node) {\n      var range = this;\n      var anchorKey = range.anchorKey,\n          anchorOffset = range.anchorOffset,\n          focusKey = range.focusKey,\n          focusOffset = range.focusOffset,\n          isBackward = range.isBackward;\n\n\n      var anchorOffsetType = typeof anchorOffset === 'undefined' ? 'undefined' : _typeof(anchorOffset);\n      var focusOffsetType = typeof focusOffset === 'undefined' ? 'undefined' : _typeof(focusOffset);\n\n      if (anchorOffsetType != 'number' || focusOffsetType != 'number') {\n        logger.warn('The range offsets should be numbers, but they were of type \"' + anchorOffsetType + '\" and \"' + focusOffsetType + '\".');\n      }\n\n      // If the range is unset, make sure it is properly zeroed out.\n      if (anchorKey == null || focusKey == null) {\n        return range.merge({\n          anchorKey: null,\n          anchorOffset: 0,\n          focusKey: null,\n          focusOffset: 0,\n          isBackward: false\n        });\n      }\n\n      // Get the anchor and focus nodes.\n      var anchorNode = node.getDescendant(anchorKey);\n      var focusNode = node.getDescendant(focusKey);\n\n      // If the range is malformed, warn and zero it out.\n      if (!anchorNode || !focusNode) {\n        logger.warn('The range was invalid and was reset. The range in question was:', range);\n\n        var first = node.getFirstText();\n        return range.merge({\n          anchorKey: first ? first.key : null,\n          anchorOffset: 0,\n          focusKey: first ? first.key : null,\n          focusOffset: 0,\n          isBackward: false\n        });\n      }\n\n      // If the anchor node isn't a text node, match it to one.\n      if (anchorNode.object != 'text') {\n        logger.warn('The range anchor was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:', anchorNode);\n\n        var anchorText = anchorNode.getTextAtOffset(anchorOffset);\n        var offset = anchorNode.getOffset(anchorText.key);\n        anchorOffset = anchorOffset - offset;\n        anchorNode = anchorText;\n      }\n\n      // If the focus node isn't a text node, match it to one.\n      if (focusNode.object != 'text') {\n        logger.warn('The range focus was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:', focusNode);\n\n        var focusText = focusNode.getTextAtOffset(focusOffset);\n        var _offset = focusNode.getOffset(focusText.key);\n        focusOffset = focusOffset - _offset;\n        focusNode = focusText;\n      }\n\n      // If `isBackward` is not set, derive it.\n      if (isBackward == null) {\n        if (anchorNode.key === focusNode.key) {\n          isBackward = anchorOffset > focusOffset;\n        } else {\n          isBackward = !node.areDescendantsSorted(anchorNode.key, focusNode.key);\n        }\n      }\n\n      // Merge in any updated properties.\n      return range.merge({\n        anchorKey: anchorNode.key,\n        anchorOffset: anchorOffset,\n        focusKey: focusNode.key,\n        focusOffset: focusOffset,\n        isBackward: isBackward\n      });\n    }\n\n    /**\n     * Return a JSON representation of the range.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        anchorKey: this.anchorKey,\n        anchorOffset: this.anchorOffset,\n        focusKey: this.focusKey,\n        focusOffset: this.focusOffset,\n        isBackward: this.isBackward,\n        isFocused: this.isFocused,\n        marks: this.marks == null ? null : this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        }),\n        isAtomic: this.isAtomic\n      };\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS() {\n      return this.toJSON();\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'range';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n\n    /**\n     * Check whether the range is blurred.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlurred',\n    get: function get$$1() {\n      return !this.isFocused;\n    }\n\n    /**\n     * Check whether the range is collapsed.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCollapsed',\n    get: function get$$1() {\n      return this.anchorKey == this.focusKey && this.anchorOffset == this.focusOffset;\n    }\n\n    /**\n     * Check whether the range is expanded.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isExpanded',\n    get: function get$$1() {\n      return !this.isCollapsed;\n    }\n\n    /**\n     * Check whether the range is forward.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isForward',\n    get: function get$$1() {\n      return this.isBackward == null ? null : !this.isBackward;\n    }\n\n    /**\n     * Check whether the range's keys are set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSet',\n    get: function get$$1() {\n      return this.anchorKey != null && this.focusKey != null;\n    }\n\n    /**\n     * Check whether the range's keys are not set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isUnset',\n    get: function get$$1() {\n      return !this.isSet;\n    }\n\n    /**\n     * Get the start key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startKey',\n    get: function get$$1() {\n      return this.isBackward ? this.focusKey : this.anchorKey;\n    }\n\n    /**\n     * Get the start offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startOffset',\n    get: function get$$1() {\n      return this.isBackward ? this.focusOffset : this.anchorOffset;\n    }\n\n    /**\n     * Get the end key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endKey',\n    get: function get$$1() {\n      return this.isBackward ? this.anchorKey : this.focusKey;\n    }\n\n    /**\n     * Get the end offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endOffset',\n    get: function get$$1() {\n      return this.isBackward ? this.anchorOffset : this.focusOffset;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Range` with `attrs`.\n     *\n     * @param {Object|Range} attrs\n     * @return {Range}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Range.isRange(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Range.fromJSON(attrs);\n      }\n\n      throw new Error('`Range.create` only accepts objects or ranges, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Ranges` from `elements`.\n     *\n     * @param {Array<Range|Object>|List<Range|Object>} elements\n     * @return {List<Range>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Range.create));\n        return list;\n      }\n\n      throw new Error('`Range.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a dictionary of settable range properties from `attrs`.\n     *\n     * @param {Object|String|Range} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Range.isRange(attrs)) {\n        return {\n          anchorKey: attrs.anchorKey,\n          anchorOffset: attrs.anchorOffset,\n          focusKey: attrs.focusKey,\n          focusOffset: attrs.focusOffset,\n          isBackward: attrs.isBackward,\n          isFocused: attrs.isFocused,\n          marks: attrs.marks,\n          isAtomic: attrs.isAtomic\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        var props = {};\n        if ('anchorKey' in attrs) props.anchorKey = attrs.anchorKey;\n        if ('anchorOffset' in attrs) props.anchorOffset = attrs.anchorOffset;\n        if ('anchorPath' in attrs) props.anchorPath = attrs.anchorPath;\n        if ('focusKey' in attrs) props.focusKey = attrs.focusKey;\n        if ('focusOffset' in attrs) props.focusOffset = attrs.focusOffset;\n        if ('focusPath' in attrs) props.focusPath = attrs.focusPath;\n        if ('isBackward' in attrs) props.isBackward = attrs.isBackward;\n        if ('isFocused' in attrs) props.isFocused = attrs.isFocused;\n        if ('marks' in attrs) props.marks = attrs.marks == null ? null : Mark.createSet(attrs.marks);\n        if ('isAtomic' in attrs) props.isAtomic = attrs.isAtomic;\n        return props;\n      }\n\n      throw new Error('`Range.createProperties` only accepts objects or ranges, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Range` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Range}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$anchorKey = object.anchorKey,\n          anchorKey = _object$anchorKey === undefined ? null : _object$anchorKey,\n          _object$anchorOffset = object.anchorOffset,\n          anchorOffset = _object$anchorOffset === undefined ? 0 : _object$anchorOffset,\n          _object$focusKey = object.focusKey,\n          focusKey = _object$focusKey === undefined ? null : _object$focusKey,\n          _object$focusOffset = object.focusOffset,\n          focusOffset = _object$focusOffset === undefined ? 0 : _object$focusOffset,\n          _object$isBackward = object.isBackward,\n          isBackward = _object$isBackward === undefined ? null : _object$isBackward,\n          _object$isFocused = object.isFocused,\n          isFocused = _object$isFocused === undefined ? false : _object$isFocused,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? null : _object$marks,\n          _object$isAtomic = object.isAtomic,\n          isAtomic = _object$isAtomic === undefined ? false : _object$isAtomic;\n\n\n      var range = new Range({\n        anchorKey: anchorKey,\n        anchorOffset: anchorOffset,\n        focusKey: focusKey,\n        focusOffset: focusOffset,\n        isBackward: isBackward,\n        isFocused: isFocused,\n        marks: marks == null ? null : new immutable.Set(marks.map(Mark.fromJSON)),\n        isAtomic: isAtomic\n      });\n\n      return range;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }, {\n    key: 'isRange',\n\n\n    /**\n     * Check if an `obj` is a `Range`.\n     *\n     * @param {Any} obj\n     * @return {Boolean}\n     */\n\n    value: function isRange(obj) {\n      return !!(obj && obj[MODEL_TYPES.RANGE]);\n    }\n  }]);\n  return Range;\n}(immutable.Record(DEFAULTS$4));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nRange.fromJS = Range.fromJSON;\nRange.prototype[MODEL_TYPES.RANGE] = true;\n\n/**\n * Mix in some \"move\" convenience methods.\n */\n\nvar MOVE_METHODS = [['move', ''], ['move', 'To'], ['move', 'ToStartOf'], ['move', 'ToEndOf']];\n\nMOVE_METHODS.forEach(function (_ref) {\n  var _ref2 = slicedToArray(_ref, 2),\n      p = _ref2[0],\n      s = _ref2[1];\n\n  Range.prototype['' + p + s] = function () {\n    var _ref3;\n\n    return (_ref3 = this[p + 'Anchor' + s].apply(this, arguments))[p + 'Focus' + s].apply(_ref3, arguments);\n  };\n});\n\n/**\n * Mix in the \"start\", \"end\" and \"edge\" convenience methods.\n */\n\nvar EDGE_METHODS = [['has', 'AtStartOf', true], ['has', 'AtEndOf', true], ['has', 'Between', true], ['has', 'In', true], ['collapseTo', ''], ['move', ''], ['moveTo', ''], ['move', 'To'], ['move', 'OffsetTo']];\n\nEDGE_METHODS.forEach(function (_ref4) {\n  var _ref5 = slicedToArray(_ref4, 3),\n      p = _ref5[0],\n      s = _ref5[1],\n      hasEdge = _ref5[2];\n\n  var anchor = p + 'Anchor' + s;\n  var focus = p + 'Focus' + s;\n\n  Range.prototype[p + 'Start' + s] = function () {\n    return this.isBackward ? this[focus].apply(this, arguments) : this[anchor].apply(this, arguments);\n  };\n\n  Range.prototype[p + 'End' + s] = function () {\n    return this.isBackward ? this[anchor].apply(this, arguments) : this[focus].apply(this, arguments);\n  };\n\n  if (hasEdge) {\n    Range.prototype[p + 'Edge' + s] = function () {\n      return this[anchor].apply(this, arguments) || this[focus].apply(this, arguments);\n    };\n  }\n});\n\n/**\n * Mix in some aliases for convenience / parallelism with the browser APIs.\n */\n\nvar ALIAS_METHODS = [['collapseTo', 'moveTo'], ['collapseToAnchor', 'moveToAnchor'], ['collapseToFocus', 'moveToFocus'], ['collapseToStart', 'moveToStart'], ['collapseToEnd', 'moveToEnd'], ['collapseToStartOf', 'moveToStartOf'], ['collapseToEndOf', 'moveToEndOf'], ['extend', 'moveFocus'], ['extendTo', 'moveFocusTo'], ['extendToStartOf', 'moveFocusToStartOf'], ['extendToEndOf', 'moveFocusToEndOf']];\n\nALIAS_METHODS.forEach(function (_ref6) {\n  var _ref7 = slicedToArray(_ref6, 2),\n      alias = _ref7[0],\n      method = _ref7[1];\n\n  Range.prototype[alias] = function () {\n    return this[method].apply(this, arguments);\n  };\n});\n\n/**\n * Get the first text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getFirst(node) {\n  return node.object == 'text' ? node : node.getFirstText();\n}\n\n/**\n * Get the last text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getLast(node) {\n  return node.object == 'text' ? node : node.getLastText();\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$5 = {\n  marks: new immutable.Set(),\n  text: ''\n\n  /**\n   * Character.\n   *\n   * @type {Character}\n   */\n\n};\nvar Character = function (_Record) {\n  inherits(Character, _Record);\n\n  function Character() {\n    classCallCheck(this, Character);\n    return possibleConstructorReturn(this, (Character.__proto__ || Object.getPrototypeOf(Character)).apply(this, arguments));\n  }\n\n  createClass(Character, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the character.\n     *\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        text: this.text,\n        marks: this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS() {\n      return this.toJSON();\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'character';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a `Character` with `attrs`.\n     *\n     * @param {Object|String|Character} attrs\n     * @return {Character}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Character.isCharacter(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs == 'string') {\n        attrs = { text: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Character.fromJSON(attrs);\n      }\n\n      throw new Error('`Character.create` only accepts objects, strings or characters, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Characters` from `elements`.\n     *\n     * @param {String|Array<Object|Character|String>|List<Object|Character|String>} elements\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (typeof elements == 'string') {\n        elements = elements.split('');\n      }\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Character.create));\n        return list;\n      }\n\n      throw new Error('`Block.createList` only accepts strings, arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a `Character` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Character}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var text = object.text,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? [] : _object$marks;\n\n\n      if (typeof text != 'string') {\n        throw new Error('`Character.fromJSON` requires a block `text` string.');\n      }\n\n      var character = new Character({\n        text: text,\n        marks: new immutable.Set(marks)\n      });\n\n      return character;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Character`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCharacterList',\n\n\n    /**\n     * Check if `any` is a character list.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isCharacterList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Character.isCharacter(item);\n      });\n    }\n  }]);\n  return Character;\n}(immutable.Record(DEFAULTS$5));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nCharacter.fromJS = Character.fromJSON;\nCharacter.isCharacter = isType.bind(null, 'CHARACTER');\nCharacter.prototype[MODEL_TYPES.CHARACTER] = true;\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$6 = {\n  marks: immutable.Set(),\n  text: ''\n\n  /**\n   * Leaf.\n   *\n   * @type {Leaf}\n   */\n\n};\nvar Leaf = function (_Record) {\n  inherits(Leaf, _Record);\n\n  function Leaf() {\n    classCallCheck(this, Leaf);\n    return possibleConstructorReturn(this, (Leaf.__proto__ || Object.getPrototypeOf(Leaf)).apply(this, arguments));\n  }\n\n  createClass(Leaf, [{\n    key: 'getCharacters',\n\n\n    /**\n     * Return leaf as a list of characters\n     *\n     * @return {List<Character>}\n     */\n\n    value: function getCharacters() {\n      logger.deprecate('slate@0.34.0', 'The `characters` property of Slate objects is deprecated');\n\n      var marks = this.marks;\n\n      var characters = Character.createList(this.text.split('').map(function (char) {\n        return Character.create({\n          text: char,\n          marks: marks\n        });\n      }));\n\n      return characters;\n    }\n\n    /**\n     * Update a `mark` at leaf, replace with newMark\n     *\n     * @param {Mark} mark\n     * @param {Mark} newMark\n     * @returns {Leaf}\n     */\n\n  }, {\n    key: 'updateMark',\n    value: function updateMark(mark, newMark) {\n      var marks = this.marks;\n\n      if (newMark.equals(mark)) return this;\n      if (!marks.has(mark)) return this;\n      var newMarks = marks.withMutations(function (collection) {\n        collection.remove(mark).add(newMark);\n      });\n      return this.set('marks', newMarks);\n    }\n\n    /**\n     * Add a `set` of marks at `index` and `length`.\n     *\n     * @param {Set<Mark>} set\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'addMarks',\n    value: function addMarks(set$$1) {\n      var marks = this.marks;\n\n      return this.set('marks', marks.union(set$$1));\n    }\n\n    /**\n     * Remove a `mark` at `index` and `length`.\n     *\n     * @param {Mark} mark\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(mark) {\n      var marks = this.marks;\n\n      return this.set('marks', marks.remove(mark));\n    }\n\n    /**\n     * Return a JSON representation of the leaf.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        text: this.text,\n        marks: this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS() {\n      return this.toJSON();\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'leaf';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Leaf` with `attrs`.\n     *\n     * @param {Object|Leaf} attrs\n     * @return {Leaf}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Leaf.isLeaf(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs == 'string') {\n        attrs = { text: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Leaf.fromJSON(attrs);\n      }\n\n      throw new Error('`Leaf.create` only accepts objects, strings or leaves, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a valid List of `Leaf` from `leaves`\n     *\n     * @param {List<Leaf>} leaves\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'createLeaves',\n    value: function createLeaves(leaves) {\n      if (leaves.size <= 1) return leaves;\n\n      var invalid = false;\n\n      // TODO: we can make this faster with [List] and then flatten\n      var result = immutable.List().withMutations(function (cache) {\n        // Search from the leaves left end to find invalid node;\n        leaves.findLast(function (leaf, index) {\n          var firstLeaf = cache.first();\n\n          // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\n          if (firstLeaf) {\n            // If marks equals, then the two leaves can be connected\n            if (firstLeaf.marks.equals(leaf.marks)) {\n              invalid = true;\n              cache.set(0, firstLeaf.set('text', '' + leaf.text + firstLeaf.text));\n              return;\n            }\n\n            // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\n            if (firstLeaf.text === '') {\n              invalid = true;\n              cache.set(0, leaf);\n              return;\n            }\n\n            // If the current leaf is empty, drop the leaf\n            if (leaf.text === '') {\n              invalid = true;\n              return;\n            }\n          }\n\n          cache.unshift(leaf);\n        });\n      });\n\n      if (!invalid) return leaves;\n      return result;\n    }\n\n    /**\n     * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\n     * Corner Cases:\n     *   1. if offset is smaller than 0, then return [List(), leaves]\n     *   2. if offset is bigger than the text length, then return [leaves, List()]\n     *\n     * @param {List<Leaf> leaves\n     * @return {Array<List<Leaf>>}\n     */\n\n  }, {\n    key: 'splitLeaves',\n    value: function splitLeaves(leaves, offset) {\n      if (offset < 0) return [immutable.List(), leaves];\n\n      if (leaves.size === 0) {\n        return [immutable.List(), immutable.List()];\n      }\n\n      var endOffset = 0;\n      var index = -1;\n      var left = void 0,\n          right = void 0;\n\n      leaves.find(function (leaf) {\n        index++;\n        var startOffset = endOffset;\n        var text = leaf.text;\n\n        endOffset += text.length;\n\n        if (endOffset < offset) return false;\n        if (startOffset > offset) return false;\n\n        var length = offset - startOffset;\n        left = leaf.set('text', text.slice(0, length));\n        right = leaf.set('text', text.slice(length));\n        return true;\n      });\n\n      if (!left) return [leaves, immutable.List()];\n\n      if (left.text === '') {\n        if (index === 0) {\n          return [immutable.List.of(left), leaves];\n        }\n\n        return [leaves.take(index), leaves.skip(index)];\n      }\n\n      if (right.text === '') {\n        if (index === leaves.size - 1) {\n          return [leaves, immutable.List.of(right)];\n        }\n\n        return [leaves.take(index + 1), leaves.skip(index + 1)];\n      }\n\n      return [leaves.take(index).push(left), leaves.skip(index + 1).unshift(right)];\n    }\n\n    /**\n     * Create a `Leaf` list from `attrs`.\n     *\n     * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(attrs) || Array.isArray(attrs)) {\n        var list = new immutable.List(attrs.map(Leaf.create));\n        return list;\n      }\n\n      throw new Error('`Leaf.createList` only accepts arrays or lists, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Leaf` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Leaf}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$text = object.text,\n          text = _object$text === undefined ? '' : _object$text,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? [] : _object$marks;\n\n\n      var leaf = new Leaf({\n        text: text,\n        marks: immutable.Set(marks.map(Mark.fromJSON))\n      });\n\n      return leaf;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Leaf`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafList',\n\n\n    /**\n     * Check if `any` is a list of leaves.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isLeafList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Leaf.isLeaf(item);\n      });\n    }\n  }]);\n  return Leaf;\n}(immutable.Record(DEFAULTS$6));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nLeaf.fromJS = Leaf.fromJSON;\nLeaf.isLeaf = isType.bind(null, 'LEAF');\nLeaf.prototype[MODEL_TYPES.LEAF] = true;\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$7 = {\n  leaves: immutable.List(),\n  key: undefined\n\n  /**\n   * Text.\n   *\n   * @type {Text}\n   */\n\n};\nvar Text = function (_Record) {\n  inherits(Text, _Record);\n\n  function Text() {\n    classCallCheck(this, Text);\n    return possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).apply(this, arguments));\n  }\n\n  createClass(Text, [{\n    key: 'getString',\n\n\n    /**\n     * Get the concatenated text of the node, cached for text getter\n     *\n     * @returns {String}\n     */\n\n    value: function getString() {\n      return this.leaves.reduce(function (string, leaf) {\n        return string + leaf.text;\n      }, '');\n    }\n\n    /**\n     * Get the concatenated characters of the node;\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'searchLeafAtOffset',\n\n\n    /**\n     * Find the 'first' leaf at offset; By 'first' the alorighthm prefers `endOffset === offset` than `startOffset === offset`\n     * Corner Cases:\n     *   1. if offset is negative, return the first leaf;\n     *   2. if offset is larger than text length, the leaf is null, startOffset, endOffset and index is of the last leaf\n     *\n     * @param {number}\n     * @returns {Object}\n     *   @property {number} startOffset\n     *   @property {number} endOffset\n     *   @property {number} index\n     *   @property {Leaf} leaf\n     */\n\n    value: function searchLeafAtOffset(offset) {\n      var endOffset = 0;\n      var startOffset = 0;\n      var index = -1;\n\n      var leaf = this.leaves.find(function (l) {\n        index++;\n        startOffset = endOffset;\n        endOffset = startOffset + l.text.length;\n        return endOffset >= offset;\n      });\n\n      return {\n        leaf: leaf,\n        endOffset: endOffset,\n        index: index,\n        startOffset: startOffset\n      };\n    }\n\n    /**\n     * Add a `mark` at `index` and `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Mark} mark\n     * @return {Text}\n     */\n\n  }, {\n    key: 'addMark',\n    value: function addMark(index, length, mark) {\n      var marks = immutable.Set.of(mark);\n      return this.addMarks(index, length, marks);\n    }\n\n    /**\n     * Add a `set` of marks at `index` and `length`.\n     * Corner Cases:\n     *   1. If empty text, and if length === 0 and index === 0, will make sure the text contain an empty leaf with the given mark.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Set<Mark>} set\n     * @return {Text}\n     */\n\n  }, {\n    key: 'addMarks',\n    value: function addMarks(index, length, set$$1) {\n      if (this.text === '' && length === 0 && index === 0) {\n        var _leaves = this.leaves;\n\n        var first = _leaves.first();\n\n        if (!first) {\n          return this.set('leaves', immutable.List.of(Leaf.fromJSON({ text: '', marks: set$$1 })));\n        }\n\n        var newFirst = first.addMarks(set$$1);\n        if (newFirst === first) return this;\n        return this.set('leaves', immutable.List.of(newFirst));\n      }\n\n      if (this.text === '') return this;\n      if (length === 0) return this;\n      if (index >= this.text.length) return this;\n\n      var _Leaf$splitLeaves = Leaf.splitLeaves(this.leaves, index),\n          _Leaf$splitLeaves2 = slicedToArray(_Leaf$splitLeaves, 2),\n          before = _Leaf$splitLeaves2[0],\n          bundle = _Leaf$splitLeaves2[1];\n\n      var _Leaf$splitLeaves3 = Leaf.splitLeaves(bundle, length),\n          _Leaf$splitLeaves4 = slicedToArray(_Leaf$splitLeaves3, 2),\n          middle = _Leaf$splitLeaves4[0],\n          after = _Leaf$splitLeaves4[1];\n\n      var leaves = before.concat(middle.map(function (x) {\n        return x.addMarks(set$$1);\n      }), after);\n      return this.setLeaves(leaves);\n    }\n\n    /**\n     * Get the decorations for the node from a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getDecorations',\n    value: function getDecorations(schema) {\n      return schema.__getDecorations(this);\n    }\n\n    /**\n     * Derive the leaves for a list of `decorations`.\n     *\n     * @param {Array|Void} decorations (optional)\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'getLeaves',\n    value: function getLeaves() {\n      var _this2 = this;\n\n      var decorations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var leaves = this.leaves;\n\n      if (leaves.size === 0) return immutable.List.of(Leaf.create({}));\n      if (!decorations || decorations.length === 0) return leaves;\n      if (this.text.length === 0) return leaves;\n      var key = this.key;\n\n\n      decorations.forEach(function (range) {\n        var startKey = range.startKey,\n            endKey = range.endKey,\n            startOffset = range.startOffset,\n            endOffset = range.endOffset,\n            marks = range.marks;\n\n        var hasStart = startKey == key;\n        var hasEnd = endKey == key;\n\n        if (hasStart && hasEnd) {\n          var index = hasStart ? startOffset : 0;\n          var length = hasEnd ? endOffset - index : _this2.text.length - index;\n\n          if (length < 1) return;\n          if (index >= _this2.text.length) return;\n\n          if (index !== 0 || length < _this2.text.length) {\n            var _Leaf$splitLeaves5 = Leaf.splitLeaves(leaves, index),\n                _Leaf$splitLeaves6 = slicedToArray(_Leaf$splitLeaves5, 2),\n                before = _Leaf$splitLeaves6[0],\n                bundle = _Leaf$splitLeaves6[1];\n\n            var _Leaf$splitLeaves7 = Leaf.splitLeaves(bundle, length),\n                _Leaf$splitLeaves8 = slicedToArray(_Leaf$splitLeaves7, 2),\n                middle = _Leaf$splitLeaves8[0],\n                after = _Leaf$splitLeaves8[1];\n\n            leaves = before.concat(middle.map(function (x) {\n              return x.addMarks(marks);\n            }), after);\n            return;\n          }\n        }\n\n        leaves = leaves.map(function (x) {\n          return x.addMarks(marks);\n        });\n      });\n\n      if (leaves === this.leaves) return leaves;\n      return Leaf.createLeaves(leaves);\n    }\n\n    /**\n     * Get all of the active marks on between two offsets\n     * Corner Cases:\n     *   1. if startOffset is equal or bigger than endOffset, then return Set();\n     *   2. If no text is selected between start and end, then return Set()\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getActiveMarksBetweenOffsets',\n    value: function getActiveMarksBetweenOffsets(startOffset, endOffset) {\n      if (startOffset <= 0 && endOffset >= this.text.length) {\n        return this.getActiveMarks();\n      }\n\n      if (startOffset >= endOffset) return immutable.Set();\n      // For empty text in a paragraph, use getActiveMarks;\n      if (this.text === '') return this.getActiveMarks();\n\n      var result = null;\n      var leafEnd = 0;\n\n      this.leaves.forEach(function (leaf) {\n        var leafStart = leafEnd;\n        leafEnd = leafStart + leaf.text.length;\n\n        if (leafEnd <= startOffset) return;\n        if (leafStart >= endOffset) return false;\n\n        if (!result) {\n          result = leaf.marks;\n          return;\n        }\n\n        result = result.intersect(leaf.marks);\n        if (result && result.size === 0) return false;\n        return false;\n      });\n\n      return result || immutable.Set();\n    }\n\n    /**\n     * Get all of the active marks on the text\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getActiveMarks',\n    value: function getActiveMarks() {\n      var _this3 = this;\n\n      if (this.leaves.size === 0) return immutable.Set();\n\n      var result = this.leaves.first().marks;\n      if (result.size === 0) return result;\n\n      return result.withMutations(function (x) {\n        _this3.leaves.forEach(function (c) {\n          x.intersect(c.marks);\n          if (x.size === 0) return false;\n        });\n      });\n    }\n\n    /**\n     * Get all of the marks on between two offsets\n     * Corner Cases:\n     *   1. if startOffset is equal or bigger than endOffset, then return Set();\n     *   2. If no text is selected between start and end, then return Set()\n     *\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarksBetweenOffsets',\n    value: function getMarksBetweenOffsets(startOffset, endOffset) {\n      if (startOffset <= 0 && endOffset >= this.text.length) {\n        return this.getMarks();\n      }\n\n      if (startOffset >= endOffset) return immutable.Set();\n      // For empty text in a paragraph, use getActiveMarks;\n      if (this.text === '') return this.getActiveMarks();\n\n      var result = null;\n      var leafEnd = 0;\n\n      this.leaves.forEach(function (leaf) {\n        var leafStart = leafEnd;\n        leafEnd = leafStart + leaf.text.length;\n\n        if (leafEnd <= startOffset) return;\n        if (leafStart >= endOffset) return false;\n\n        if (!result) {\n          result = leaf.marks;\n          return;\n        }\n\n        result = result.union(leaf.marks);\n      });\n\n      return result || immutable.Set();\n    }\n\n    /**\n     * Get all of the marks on the text.\n     *\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarks',\n    value: function getMarks() {\n      var array = this.getMarksAsArray();\n      return new immutable.OrderedSet(array);\n    }\n\n    /**\n     * Get all of the marks on the text as an array\n     *\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getMarksAsArray',\n    value: function getMarksAsArray() {\n      if (this.leaves.size === 0) return [];\n      var first = this.leaves.first().marks;\n      if (this.leaves.size === 1) return first.toArray();\n\n      var result = [];\n\n      this.leaves.forEach(function (leaf) {\n        result.push(leaf.marks.toArray());\n      });\n\n      return Array.prototype.concat.apply(first.toArray(), result);\n    }\n\n    /**\n     * Get the marks on the text at `index`.\n     * Corner Cases:\n     *   1. if no text is before the index, and index !== 0, then return Set()\n     *   2. (for insert after split node or mark at range) if index === 0, and text === '', then return the leaf.marks\n     *   3. if index === 0, text !== '', return Set()\n     *\n     *\n     * @param {Number} index\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getMarksAtIndex',\n    value: function getMarksAtIndex(index) {\n      var _searchLeafAtOffset = this.searchLeafAtOffset(index),\n          leaf = _searchLeafAtOffset.leaf;\n\n      if (!leaf) return immutable.Set();\n      return leaf.marks;\n    }\n\n    /**\n     * Get a node by `key`, to parallel other nodes.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNode',\n    value: function getNode(key) {\n      return this.key == key ? this : null;\n    }\n\n    /**\n     * Check if the node has a node by `key`, to parallel other nodes.\n     *\n     * @param {String} key\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasNode',\n    value: function hasNode(key) {\n      return !!this.getNode(key);\n    }\n\n    /**\n     * Insert `text` at `index`.\n     *\n     * @param {Numbder} offset\n     * @param {String} text\n     * @param {Set} marks (optional)\n     * @return {Text}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(offset, text, marks) {\n      if (this.text === '') {\n        return this.set('leaves', immutable.List.of(Leaf.create({ text: text, marks: marks })));\n      }\n\n      if (text.length === 0) return this;\n      if (!marks) marks = immutable.Set();\n\n      var _searchLeafAtOffset2 = this.searchLeafAtOffset(offset),\n          startOffset = _searchLeafAtOffset2.startOffset,\n          leaf = _searchLeafAtOffset2.leaf,\n          index = _searchLeafAtOffset2.index;\n\n      var delta = offset - startOffset;\n      var beforeText = leaf.text.slice(0, delta);\n      var afterText = leaf.text.slice(delta);\n      var leaves = this.leaves;\n\n\n      if (leaf.marks.equals(marks)) {\n        return this.set('leaves', leaves.set(index, leaf.set('text', beforeText + text + afterText)));\n      }\n\n      var nextLeaves = leaves.splice(index, 1, leaf.set('text', beforeText), Leaf.create({ text: text, marks: marks }), leaf.set('text', afterText));\n\n      return this.setLeaves(nextLeaves);\n    }\n\n    /**\n     * Regenerate the node's key.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'regenerateKey',\n    value: function regenerateKey() {\n      var key = generateKey();\n      return this.set('key', key);\n    }\n\n    /**\n     * Remove a `mark` at `index` and `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Mark} mark\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(index, length, mark) {\n      if (this.text === '' && index === 0 && length === 0) {\n        var first = this.leaves.first();\n        if (!first) return this;\n        var newFirst = first.removeMark(mark);\n        if (newFirst === first) return this;\n        return this.set('leaves', immutable.List.of(newFirst));\n      }\n\n      if (length <= 0) return this;\n      if (index >= this.text.length) return this;\n\n      var _Leaf$splitLeaves9 = Leaf.splitLeaves(this.leaves, index),\n          _Leaf$splitLeaves10 = slicedToArray(_Leaf$splitLeaves9, 2),\n          before = _Leaf$splitLeaves10[0],\n          bundle = _Leaf$splitLeaves10[1];\n\n      var _Leaf$splitLeaves11 = Leaf.splitLeaves(bundle, length),\n          _Leaf$splitLeaves12 = slicedToArray(_Leaf$splitLeaves11, 2),\n          middle = _Leaf$splitLeaves12[0],\n          after = _Leaf$splitLeaves12[1];\n\n      var leaves = before.concat(middle.map(function (x) {\n        return x.removeMark(mark);\n      }), after);\n      return this.setLeaves(leaves);\n    }\n\n    /**\n     * Remove text from the text node at `start` for `length`.\n     *\n     * @param {Number} start\n     * @param {Number} length\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(start, length) {\n      if (length <= 0) return this;\n      if (start >= this.text.length) return this;\n\n      // PERF: For simple backspace, we can operate directly on the leaf\n      if (length === 1) {\n        var _searchLeafAtOffset3 = this.searchLeafAtOffset(start + 1),\n            leaf = _searchLeafAtOffset3.leaf,\n            index = _searchLeafAtOffset3.index,\n            startOffset = _searchLeafAtOffset3.startOffset;\n\n        var offset = start - startOffset;\n\n        if (leaf) {\n          if (leaf.text.length === 1) {\n            var _leaves2 = this.leaves.remove(index);\n            return this.setLeaves(_leaves2);\n          }\n\n          var beforeText = leaf.text.slice(0, offset);\n          var afterText = leaf.text.slice(offset + length);\n          var text = beforeText + afterText;\n\n          if (text.length > 0) {\n            return this.set('leaves', this.leaves.set(index, leaf.set('text', text)));\n          }\n        }\n      }\n\n      var _Leaf$splitLeaves13 = Leaf.splitLeaves(this.leaves, start),\n          _Leaf$splitLeaves14 = slicedToArray(_Leaf$splitLeaves13, 2),\n          before = _Leaf$splitLeaves14[0],\n          bundle = _Leaf$splitLeaves14[1];\n\n      var after = Leaf.splitLeaves(bundle, length)[1];\n      var leaves = Leaf.createLeaves(before.concat(after));\n\n      if (leaves.size === 1) {\n        var first = leaves.first();\n\n        if (first.text === '') {\n          return this.set('leaves', immutable.List.of(first.set('marks', this.getActiveMarks())));\n        }\n      }\n\n      return this.set('leaves', leaves);\n    }\n\n    /**\n     * Return a JSON representation of the text.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        leaves: this.getLeaves().toArray().map(function (r) {\n          return r.toJSON();\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS(options) {\n      return this.toJSON(options);\n    }\n\n    /**\n     * Update a `mark` at `index` and `length` with `properties`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Mark} mark\n     * @param {Object} properties\n     * @return {Text}\n     */\n\n  }, {\n    key: 'updateMark',\n    value: function updateMark(index, length, mark, properties) {\n      var newMark = mark.merge(properties);\n\n      if (this.text === '' && length === 0 && index === 0) {\n        var _leaves3 = this.leaves;\n\n        var first = _leaves3.first();\n        if (!first) return this;\n        var newFirst = first.updateMark(mark, newMark);\n        if (newFirst === first) return this;\n        return this.set('leaves', immutable.List.of(newFirst));\n      }\n\n      if (length <= 0) return this;\n      if (index >= this.text.length) return this;\n\n      var _Leaf$splitLeaves15 = Leaf.splitLeaves(this.leaves, index),\n          _Leaf$splitLeaves16 = slicedToArray(_Leaf$splitLeaves15, 2),\n          before = _Leaf$splitLeaves16[0],\n          bundle = _Leaf$splitLeaves16[1];\n\n      var _Leaf$splitLeaves17 = Leaf.splitLeaves(bundle, length),\n          _Leaf$splitLeaves18 = slicedToArray(_Leaf$splitLeaves17, 2),\n          middle = _Leaf$splitLeaves18[0],\n          after = _Leaf$splitLeaves18[1];\n\n      var leaves = before.concat(middle.map(function (x) {\n        return x.updateMark(mark, newMark);\n      }), after);\n\n      return this.setLeaves(leaves);\n    }\n\n    /**\n     * Split this text and return two different texts\n     * @param {Number} position\n     * @returns {Array<Text>}\n     */\n\n  }, {\n    key: 'splitText',\n    value: function splitText(offset) {\n      var splitted = Leaf.splitLeaves(this.leaves, offset);\n      var one = this.set('leaves', splitted[0]);\n      var two = this.set('leaves', splitted[1]).regenerateKey();\n      return [one, two];\n    }\n\n    /**\n     * merge this text and another text at the end\n     * @param {Text} text\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'mergeText',\n    value: function mergeText(text) {\n      var leaves = this.leaves.concat(text.leaves);\n      return this.setLeaves(leaves);\n    }\n\n    /**\n     * Validate the text node against a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Object|Void}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(schema) {\n      return schema.validateNode(this);\n    }\n\n    /**\n     * Get the first invalid descendant\n     * PERF: Do not cache this method; because it can cause cycle reference\n     *\n     * @param {Schema} schema\n     * @returns {Text|Null}\n     */\n\n  }, {\n    key: 'getFirstInvalidDescendant',\n    value: function getFirstInvalidDescendant(schema) {\n      return this.validate(schema) ? this : null;\n    }\n\n    /**\n     * Set leaves with normalized `leaves`\n     *\n     * @param {Schema} schema\n     * @returns {Text|Null}\n     */\n\n  }, {\n    key: 'setLeaves',\n    value: function setLeaves(leaves) {\n      var result = Leaf.createLeaves(leaves);\n\n      if (result.size === 1) {\n        var first = result.first();\n\n        if (!first.marks || first.marks.size === 0) {\n          if (first.text === '') {\n            return this.set('leaves', immutable.List());\n          }\n        }\n      }\n\n      return this.set('leaves', Leaf.createLeaves(leaves));\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'text';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n\n    /**\n     * Is the node empty?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get$$1() {\n      return this.text == '';\n    }\n\n    /**\n     * Get the concatenated text of the node.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get$$1() {\n      return this.getString();\n    }\n  }, {\n    key: 'characters',\n    get: function get$$1() {\n      return this.leaves.flatMap(function (x) {\n        return x.getCharacters();\n      });\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Text` with `attrs`.\n     *\n     * @param {Object|Array|List|String|Text} attrs\n     * @return {Text}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      if (Text.isText(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs == 'string') {\n        attrs = { leaves: [{ text: attrs }] };\n      }\n\n      if (isPlainObject(attrs)) {\n        if (attrs.text) {\n          var _attrs = attrs,\n              text = _attrs.text,\n              marks = _attrs.marks,\n              key = _attrs.key;\n\n          attrs = { key: key, leaves: [{ text: text, marks: marks }] };\n        }\n\n        return Text.fromJSON(attrs);\n      }\n\n      throw new Error('`Text.create` only accepts objects, arrays, strings or texts, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Texts` from `elements`.\n     *\n     * @param {Array<Text|Object>|List<Text|Object>} elements\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Text.create));\n        return list;\n      }\n\n      throw new Error('`Text.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a `Text` from a JSON `object`.\n     *\n     * @param {Object|Text} object\n     * @return {Text}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Text.isText(object)) {\n        return object;\n      }\n\n      var _object$key = object.key,\n          key = _object$key === undefined ? generateKey() : _object$key;\n      var _object$leaves = object.leaves,\n          leaves = _object$leaves === undefined ? immutable.List() : _object$leaves;\n\n\n      if (Array.isArray(leaves)) {\n        leaves = immutable.List(leaves.map(function (x) {\n          return Leaf.create(x);\n        }));\n      } else if (immutable.List.isList(leaves)) {\n        leaves = leaves.map(function (x) {\n          return Leaf.create(x);\n        });\n      } else {\n        throw new Error('leaves must be either Array or Immutable.List');\n      }\n\n      var node = new Text({\n        leaves: Leaf.createLeaves(leaves),\n        key: key\n      });\n\n      return node;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Text`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isTextList',\n\n\n    /**\n     * Check if `any` is a list\u00a0of texts.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isTextList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Text.isText(item);\n      });\n    }\n  }]);\n  return Text;\n}(immutable.Record(DEFAULTS$7));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nText.fromJS = Text.fromJSON;\nText.isText = isType.bind(null, 'TEXT');\nText.prototype[MODEL_TYPES.TEXT] = true;\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Text.prototype, ['getDecorations', 'getActiveMarks', 'getMarks', 'getMarksAsArray', 'validate', 'getString']);\n\n/**\n * Node.\n *\n * And interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Node}\n */\n\nvar Node = function () {\n  function Node() {\n    classCallCheck(this, Node);\n  }\n\n  createClass(Node, [{\n    key: 'areDescendantsSorted',\n\n\n    /**\n     * True if the node has both descendants in that order, false otherwise. The\n     * order is depth-first, post-order.\n     *\n     * @param {String} first\n     * @param {String} second\n     * @return {Boolean}\n     */\n\n    value: function areDescendantsSorted(first, second) {\n      first = assertKey(first);\n      second = assertKey(second);\n\n      var keys = this.getKeysAsArray();\n      var firstIndex = keys.indexOf(first);\n      var secondIndex = keys.indexOf(second);\n      if (firstIndex == -1 || secondIndex == -1) return null;\n\n      return firstIndex < secondIndex;\n    }\n\n    /**\n     * Assert that a node has a child by `key` and return it.\n     *\n     * @param {String} key\n     * @return {Node}\n     */\n\n  }, {\n    key: 'assertChild',\n    value: function assertChild(key) {\n      var child = this.getChild(key);\n\n      if (!child) {\n        key = assertKey(key);\n        throw new Error('Could not find a child node with key \"' + key + '\".');\n      }\n\n      return child;\n    }\n\n    /**\n     * Assert that a node has a descendant by `key` and return it.\n     *\n     * @param {String} key\n     * @return {Node}\n     */\n\n  }, {\n    key: 'assertDescendant',\n    value: function assertDescendant(key) {\n      var descendant = this.getDescendant(key);\n\n      if (!descendant) {\n        key = assertKey(key);\n        throw new Error('Could not find a descendant node with key \"' + key + '\".');\n      }\n\n      return descendant;\n    }\n\n    /**\n     * Assert that a node's tree has a node by `key` and return it.\n     *\n     * @param {String} key\n     * @return {Node}\n     */\n\n  }, {\n    key: 'assertNode',\n    value: function assertNode(key) {\n      var node = this.getNode(key);\n\n      if (!node) {\n        key = assertKey(key);\n        throw new Error('Could not find a node with key \"' + key + '\".');\n      }\n\n      return node;\n    }\n\n    /**\n     * Assert that a node exists at `path` and return it.\n     *\n     * @param {Array} path\n     * @return {Node}\n     */\n\n  }, {\n    key: 'assertPath',\n    value: function assertPath(path) {\n      var descendant = this.getDescendantAtPath(path);\n\n      if (!descendant) {\n        throw new Error('Could not find a descendant at path \"' + path + '\".');\n      }\n\n      return descendant;\n    }\n\n    /**\n     * Recursively filter all descendant nodes with `iterator`.\n     *\n     * @param {Function} iterator\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'filterDescendants',\n    value: function filterDescendants(iterator) {\n      var matches = [];\n\n      this.forEachDescendant(function (node, i, nodes) {\n        if (iterator(node, i, nodes)) matches.push(node);\n      });\n\n      return immutable.List(matches);\n    }\n\n    /**\n     * Recursively find all descendant nodes by `iterator`.\n     *\n     * @param {Function} iterator\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'findDescendant',\n    value: function findDescendant(iterator) {\n      var found = null;\n\n      this.forEachDescendant(function (node, i, nodes) {\n        if (iterator(node, i, nodes)) {\n          found = node;\n          return false;\n        }\n      });\n\n      return found;\n    }\n\n    /**\n     * Recursively iterate over all descendant nodes with `iterator`. If the\n     * iterator returns false it will break the loop.\n     *\n     * @param {Function} iterator\n     */\n\n  }, {\n    key: 'forEachDescendant',\n    value: function forEachDescendant(iterator) {\n      var ret = void 0;\n\n      this.nodes.forEach(function (child, i, nodes) {\n        if (iterator(child, i, nodes) === false) {\n          ret = false;\n          return false;\n        }\n\n        if (child.object != 'text') {\n          ret = child.forEachDescendant(iterator);\n          return ret;\n        }\n      });\n\n      return ret;\n    }\n\n    /**\n     * Get the path of ancestors of a descendant node by `key`.\n     *\n     * @param {String|Node} key\n     * @return {List<Node>|Null}\n     */\n\n  }, {\n    key: 'getAncestors',\n    value: function getAncestors(key) {\n      key = assertKey(key);\n\n      if (key == this.key) return immutable.List();\n      if (this.hasChild(key)) return immutable.List([this]);\n\n      var ancestors = void 0;\n\n      this.nodes.find(function (node) {\n        if (node.object == 'text') return false;\n        ancestors = node.getAncestors(key);\n        return ancestors;\n      });\n\n      if (ancestors) {\n        return ancestors.unshift(this);\n      } else {\n        return null;\n      }\n    }\n\n    /**\n     * Get the leaf block descendants of the node.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocks',\n    value: function getBlocks() {\n      var array = this.getBlocksAsArray();\n      return new immutable.List(array);\n    }\n\n    /**\n     * Get the leaf block descendants of the node.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocksAsArray',\n    value: function getBlocksAsArray() {\n      return this.nodes.reduce(function (array, child) {\n        if (child.object != 'block') return array;\n        if (!child.isLeafBlock()) return array.concat(child.getBlocksAsArray());\n        array.push(child);\n        return array;\n      }, []);\n    }\n\n    /**\n     * Get the leaf block descendants in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocksAtRange',\n    value: function getBlocksAtRange(range) {\n      var array = this.getBlocksAtRangeAsArray(range);\n      // Eliminate duplicates by converting to an `OrderedSet` first.\n      return new immutable.List(new immutable.OrderedSet(array));\n    }\n\n    /**\n     * Get the leaf block descendants in a `range` as an array\n     *\n     * @param {Range} range\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getBlocksAtRangeAsArray',\n    value: function getBlocksAtRangeAsArray(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return [];\n\n      var _range = range,\n          startKey = _range.startKey,\n          endKey = _range.endKey;\n\n      var startBlock = this.getClosestBlock(startKey);\n\n      // PERF: the most common case is when the range is in a single block node,\n      // where we can avoid a lot of iterating of the tree.\n      if (startKey == endKey) return [startBlock];\n\n      var endBlock = this.getClosestBlock(endKey);\n      var blocks = this.getBlocksAsArray();\n      var start = blocks.indexOf(startBlock);\n      var end = blocks.indexOf(endBlock);\n      return blocks.slice(start, end + 1);\n    }\n\n    /**\n     * Get all of the leaf blocks that match a `type`.\n     *\n     * @param {String} type\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocksByType',\n    value: function getBlocksByType(type) {\n      var array = this.getBlocksByTypeAsArray(type);\n      return new immutable.List(array);\n    }\n\n    /**\n     * Get all of the leaf blocks that match a `type` as an array\n     *\n     * @param {String} type\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getBlocksByTypeAsArray',\n    value: function getBlocksByTypeAsArray(type) {\n      return this.nodes.reduce(function (array, node) {\n        if (node.object != 'block') {\n          return array;\n        } else if (node.isLeafBlock() && node.type == type) {\n          array.push(node);\n          return array;\n        } else {\n          return array.concat(node.getBlocksByTypeAsArray(type));\n        }\n      }, []);\n    }\n\n    /**\n     * Get all of the characters for every text node.\n     *\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'getCharacters',\n    value: function getCharacters() {\n      return this.getTexts().flatMap(function (t) {\n        return t.characters;\n      });\n    }\n\n    /**\n     * Get a list of the characters in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'getCharactersAtRange',\n    value: function getCharactersAtRange(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return immutable.List();\n      var _range2 = range,\n          startKey = _range2.startKey,\n          endKey = _range2.endKey,\n          startOffset = _range2.startOffset,\n          endOffset = _range2.endOffset;\n\n\n      if (startKey === endKey) {\n        var endText = this.getDescendant(endKey);\n        return endText.characters.slice(startOffset, endOffset);\n      }\n\n      return this.getTextsAtRange(range).flatMap(function (t) {\n        if (t.key === startKey) {\n          return t.characters.slice(startOffset);\n        }\n\n        if (t.key === endKey) {\n          return t.characters.slice(0, endOffset);\n        }\n        return t.characters;\n      });\n    }\n\n    /**\n     * Get a child node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getChild',\n    value: function getChild(key) {\n      key = assertKey(key);\n      return this.nodes.find(function (node) {\n        return node.key == key;\n      });\n    }\n\n    /**\n     * Get closest parent of node by `key` that matches `iterator`.\n     *\n     * @param {String} key\n     * @param {Function} iterator\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosest',\n    value: function getClosest(key, iterator) {\n      key = assertKey(key);\n      var ancestors = this.getAncestors(key);\n\n      if (!ancestors) {\n        throw new Error('Could not find a descendant node with key \"' + key + '\".');\n      }\n\n      // Exclude this node itself.\n      return ancestors.rest().findLast(iterator);\n    }\n\n    /**\n     * Get the closest block parent of a `node`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestBlock',\n    value: function getClosestBlock(key) {\n      return this.getClosest(key, function (parent) {\n        return parent.object == 'block';\n      });\n    }\n\n    /**\n     * Get the closest inline parent of a `node`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestInline',\n    value: function getClosestInline(key) {\n      return this.getClosest(key, function (parent) {\n        return parent.object == 'inline';\n      });\n    }\n\n    /**\n     * Get the closest void parent of a `node`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestVoid',\n    value: function getClosestVoid(key) {\n      return this.getClosest(key, function (parent) {\n        return parent.isVoid;\n      });\n    }\n\n    /**\n     * Get the common ancestor of nodes `one` and `two` by keys.\n     *\n     * @param {String} one\n     * @param {String} two\n     * @return {Node}\n     */\n\n  }, {\n    key: 'getCommonAncestor',\n    value: function getCommonAncestor(one, two) {\n      one = assertKey(one);\n      two = assertKey(two);\n\n      if (one == this.key) return this;\n      if (two == this.key) return this;\n\n      this.assertDescendant(one);\n      this.assertDescendant(two);\n      var ancestors = new immutable.List();\n      var oneParent = this.getParent(one);\n      var twoParent = this.getParent(two);\n\n      while (oneParent) {\n        ancestors = ancestors.push(oneParent);\n        oneParent = this.getParent(oneParent.key);\n      }\n\n      while (twoParent) {\n        if (ancestors.includes(twoParent)) return twoParent;\n        twoParent = this.getParent(twoParent.key);\n      }\n    }\n\n    /**\n     * Get the decorations for the node from a `stack`.\n     *\n     * @param {Stack} stack\n     * @return {List}\n     */\n\n  }, {\n    key: 'getDecorations',\n    value: function getDecorations(stack) {\n      var decorations = stack.find('decorateNode', this);\n      var list = Range.createList(decorations || []);\n      return list;\n    }\n\n    /**\n     * Get the depth of a child node by `key`, with optional `startAt`.\n     *\n     * @param {String} key\n     * @param {Number} startAt (optional)\n     * @return {Number} depth\n     */\n\n  }, {\n    key: 'getDepth',\n    value: function getDepth(key) {\n      var startAt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      this.assertDescendant(key);\n      if (this.hasChild(key)) return startAt;\n      return this.getFurthestAncestor(key).getDepth(key, startAt + 1);\n    }\n\n    /**\n     * Get a descendant node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getDescendant',\n    value: function getDescendant(key) {\n      key = assertKey(key);\n      var descendantFound = null;\n\n      var found = this.nodes.find(function (node) {\n        if (node.key === key) {\n          return node;\n        } else if (node.object !== 'text') {\n          descendantFound = node.getDescendant(key);\n          return descendantFound;\n        } else {\n          return false;\n        }\n      });\n\n      return descendantFound || found;\n    }\n\n    /**\n     * Get a descendant by `path`.\n     *\n     * @param {Array} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getDescendantAtPath',\n    value: function getDescendantAtPath(path) {\n      var descendant = this;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var index = _step.value;\n\n          if (!descendant) return;\n          if (!descendant.nodes) return;\n          descendant = descendant.nodes.get(index);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return descendant;\n    }\n\n    /**\n     * Get the first child text node.\n     *\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFirstText',\n    value: function getFirstText() {\n      var descendantFound = null;\n\n      var found = this.nodes.find(function (node) {\n        if (node.object == 'text') return true;\n        descendantFound = node.getFirstText();\n        return descendantFound;\n      });\n\n      return descendantFound || found;\n    }\n\n    /**\n     * Get a fragment of the node at a `range`.\n     *\n     * @param {Range} range\n     * @return {Document}\n     */\n\n  }, {\n    key: 'getFragmentAtRange',\n    value: function getFragmentAtRange(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return Document.create();\n\n      var node = this;\n\n      // Make sure the children exist.\n      var _range3 = range,\n          startKey = _range3.startKey,\n          startOffset = _range3.startOffset,\n          endKey = _range3.endKey,\n          endOffset = _range3.endOffset;\n\n      var startText = node.assertDescendant(startKey);\n      var endText = node.assertDescendant(endKey);\n\n      // Split at the start and end.\n      var child = startText;\n      var previous = void 0;\n      var parent = void 0;\n\n      while (parent = node.getParent(child.key)) {\n        var index = parent.nodes.indexOf(child);\n        var position = child.object == 'text' ? startOffset : child.nodes.indexOf(previous);\n\n        parent = parent.splitNode(index, position);\n        node = node.updateNode(parent);\n        previous = parent.nodes.get(index + 1);\n        child = parent;\n      }\n\n      child = startKey == endKey ? node.getNextText(startKey) : endText;\n\n      while (parent = node.getParent(child.key)) {\n        var _index = parent.nodes.indexOf(child);\n        var _position = child.object == 'text' ? startKey == endKey ? endOffset - startOffset : endOffset : child.nodes.indexOf(previous);\n\n        parent = parent.splitNode(_index, _position);\n        node = node.updateNode(parent);\n        previous = parent.nodes.get(_index + 1);\n        child = parent;\n      }\n\n      // Get the start and end nodes.\n      var startNode = node.getNextSibling(node.getFurthestAncestor(startKey).key);\n      var endNode = startKey == endKey ? node.getNextSibling(node.getNextSibling(node.getFurthestAncestor(endKey).key).key) : node.getNextSibling(node.getFurthestAncestor(endKey).key);\n\n      // Get children range of nodes from start to end nodes\n      var startIndex = node.nodes.indexOf(startNode);\n      var endIndex = node.nodes.indexOf(endNode);\n      var nodes = node.nodes.slice(startIndex, endIndex);\n\n      // Return a new document fragment.\n      return Document.create({ nodes: nodes });\n    }\n\n    /**\n     * Get the furthest parent of a node by `key` that matches an `iterator`.\n     *\n     * @param {String} key\n     * @param {Function} iterator\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthest',\n    value: function getFurthest(key, iterator) {\n      var ancestors = this.getAncestors(key);\n\n      if (!ancestors) {\n        key = assertKey(key);\n        throw new Error('Could not find a descendant node with key \"' + key + '\".');\n      }\n\n      // Exclude this node itself\n      return ancestors.rest().find(iterator);\n    }\n\n    /**\n     * Get the furthest block parent of a node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestBlock',\n    value: function getFurthestBlock(key) {\n      return this.getFurthest(key, function (node) {\n        return node.object == 'block';\n      });\n    }\n\n    /**\n     * Get the furthest inline parent of a node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestInline',\n    value: function getFurthestInline(key) {\n      return this.getFurthest(key, function (node) {\n        return node.object == 'inline';\n      });\n    }\n\n    /**\n     * Get the furthest ancestor of a node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestAncestor',\n    value: function getFurthestAncestor(key) {\n      key = assertKey(key);\n      return this.nodes.find(function (node) {\n        if (node.key == key) return true;\n        if (node.object == 'text') return false;\n        return node.hasDescendant(key);\n      });\n    }\n\n    /**\n     * Get the furthest ancestor of a node by `key` that has only one child.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestOnlyChildAncestor',\n    value: function getFurthestOnlyChildAncestor(key) {\n      var ancestors = this.getAncestors(key);\n\n      if (!ancestors) {\n        key = assertKey(key);\n        throw new Error('Could not find a descendant node with key \"' + key + '\".');\n      }\n\n      var result = ancestors\n      // Skip this node...\n      .shift()\n      // Take parents until there are more than one child...\n      .reverse().takeUntil(function (p) {\n        return p.nodes.size > 1;\n      })\n      // And pick the highest.\n      .last();\n      if (!result) return null;\n      return result;\n    }\n\n    /**\n     * Get the closest inline nodes for each text node in the node.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlines',\n    value: function getInlines() {\n      var array = this.getInlinesAsArray();\n      return new immutable.List(array);\n    }\n\n    /**\n     * Get the closest inline nodes for each text node in the node, as an array.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlinesAsArray',\n    value: function getInlinesAsArray() {\n      var array = [];\n\n      this.nodes.forEach(function (child) {\n        if (child.object == 'text') return;\n\n        if (child.isLeafInline()) {\n          array.push(child);\n        } else {\n          array = array.concat(child.getInlinesAsArray());\n        }\n      });\n\n      return array;\n    }\n\n    /**\n     * Get the closest inline nodes for each text node in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlinesAtRange',\n    value: function getInlinesAtRange(range) {\n      var array = this.getInlinesAtRangeAsArray(range);\n      // Remove duplicates by converting it to an `OrderedSet` first.\n      return new immutable.List(new immutable.OrderedSet(array));\n    }\n\n    /**\n     * Get the closest inline nodes for each text node in a `range` as an array.\n     *\n     * @param {Range} range\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getInlinesAtRangeAsArray',\n    value: function getInlinesAtRangeAsArray(range) {\n      var _this = this;\n\n      range = range.normalize(this);\n      if (range.isUnset) return [];\n\n      return this.getTextsAtRangeAsArray(range).map(function (text) {\n        return _this.getClosestInline(text.key);\n      }).filter(function (exists) {\n        return exists;\n      });\n    }\n\n    /**\n     * Get all of the leaf inline nodes that match a `type`.\n     *\n     * @param {String} type\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlinesByType',\n    value: function getInlinesByType(type) {\n      var array = this.getInlinesByTypeAsArray(type);\n      return new immutable.List(array);\n    }\n\n    /**\n     * Get all of the leaf inline nodes that match a `type` as an array.\n     *\n     * @param {String} type\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getInlinesByTypeAsArray',\n    value: function getInlinesByTypeAsArray(type) {\n      return this.nodes.reduce(function (inlines, node) {\n        if (node.object == 'text') {\n          return inlines;\n        } else if (node.isLeafInline() && node.type == type) {\n          inlines.push(node);\n          return inlines;\n        } else {\n          return inlines.concat(node.getInlinesByTypeAsArray(type));\n        }\n      }, []);\n    }\n\n    /**\n     * Return a set of all keys in the node as an array.\n     *\n     * @return {Array<String>}\n     */\n\n  }, {\n    key: 'getKeysAsArray',\n    value: function getKeysAsArray() {\n      var keys = [];\n\n      this.forEachDescendant(function (desc) {\n        keys.push(desc.key);\n      });\n\n      return keys;\n    }\n\n    /**\n     * Return a set of all keys in the node.\n     *\n     * @return {Set<String>}\n     */\n\n  }, {\n    key: 'getKeys',\n    value: function getKeys() {\n      var keys = this.getKeysAsArray();\n      return new immutable.Set(keys);\n    }\n\n    /**\n     * Get the last child text node.\n     *\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getLastText',\n    value: function getLastText() {\n      var descendantFound = null;\n\n      var found = this.nodes.findLast(function (node) {\n        if (node.object == 'text') return true;\n        descendantFound = node.getLastText();\n        return descendantFound;\n      });\n\n      return descendantFound || found;\n    }\n\n    /**\n     * Get all of the marks for all of the characters of every text node.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getMarks',\n    value: function getMarks() {\n      var array = this.getMarksAsArray();\n      return new immutable.Set(array);\n    }\n\n    /**\n     * Get all of the marks for all of the characters of every text node.\n     *\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getOrderedMarks',\n    value: function getOrderedMarks() {\n      var array = this.getMarksAsArray();\n      return new immutable.OrderedSet(array);\n    }\n\n    /**\n     * Get all of the marks as an array.\n     *\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getMarksAsArray',\n    value: function getMarksAsArray() {\n      // PERF: use only one concat rather than multiple concat\n      // becuase one concat is faster\n      var result = [];\n\n      this.nodes.forEach(function (node) {\n        result.push(node.getMarksAsArray());\n      });\n      return Array.prototype.concat.apply([], result);\n    }\n\n    /**\n     * Get a set of the marks in a `range`.\n     *\n     * @param {Range} range\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getMarksAtRange',\n    value: function getMarksAtRange(range) {\n      return new immutable.Set(this.getOrderedMarksAtRange(range));\n    }\n\n    /**\n     * Get a set of the marks in a `range`.\n     *\n     * @param {Range} range\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getInsertMarksAtRange',\n    value: function getInsertMarksAtRange(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return immutable.Set();\n\n      if (range.isCollapsed) {\n        // PERF: range is not cachable, use key and offset as proxies for cache\n        return this.getMarksAtPosition(range.startKey, range.startOffset);\n      }\n\n      var _range4 = range,\n          startKey = _range4.startKey,\n          startOffset = _range4.startOffset;\n\n      var text = this.getDescendant(startKey);\n      return text.getMarksAtIndex(startOffset + 1);\n    }\n\n    /**\n     * Get a set of the marks in a `range`.\n     *\n     * @param {Range} range\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getOrderedMarksAtRange',\n    value: function getOrderedMarksAtRange(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return immutable.OrderedSet();\n\n      if (range.isCollapsed) {\n        // PERF: range is not cachable, use key and offset as proxies for cache\n        return this.getMarksAtPosition(range.startKey, range.startOffset);\n      }\n\n      var _range5 = range,\n          startKey = _range5.startKey,\n          startOffset = _range5.startOffset,\n          endKey = _range5.endKey,\n          endOffset = _range5.endOffset;\n\n      return this.getOrderedMarksBetweenPositions(startKey, startOffset, endKey, endOffset);\n    }\n\n    /**\n     * Get a set of the marks in a `range`.\n     * PERF: arguments use key and offset for utilizing cache\n     *\n     * @param {string} startKey\n     * @param {number} startOffset\n     * @param {string} endKey\n     * @param {number} endOffset\n     * @returns {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getOrderedMarksBetweenPositions',\n    value: function getOrderedMarksBetweenPositions(startKey, startOffset, endKey, endOffset) {\n      if (startKey === endKey) {\n        var startText = this.getDescendant(startKey);\n        return startText.getMarksBetweenOffsets(startOffset, endOffset);\n      }\n\n      var texts = this.getTextsBetweenPositionsAsArray(startKey, endKey);\n\n      return immutable.OrderedSet().withMutations(function (result) {\n        texts.forEach(function (text) {\n          if (text.key === startKey) {\n            result.union(text.getMarksBetweenOffsets(startOffset, text.text.length));\n          } else if (text.key === endKey) {\n            result.union(text.getMarksBetweenOffsets(0, endOffset));\n          } else {\n            result.union(text.getMarks());\n          }\n        });\n      });\n    }\n\n    /**\n     * Get a set of the active marks in a `range`.\n     *\n     * @param {Range} range\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getActiveMarksAtRange',\n    value: function getActiveMarksAtRange(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return immutable.Set();\n\n      if (range.isCollapsed) {\n        var _range6 = range,\n            _startKey = _range6.startKey,\n            _startOffset = _range6.startOffset;\n\n        return this.getMarksAtPosition(_startKey, _startOffset).toSet();\n      }\n\n      var _range7 = range,\n          startKey = _range7.startKey,\n          endKey = _range7.endKey,\n          startOffset = _range7.startOffset,\n          endOffset = _range7.endOffset;\n\n      var startText = this.getDescendant(startKey);\n\n      if (startKey !== endKey) {\n        while (startKey !== endKey && endOffset === 0) {\n          var _endText = this.getPreviousText(endKey);\n          endKey = _endText.key;\n          endOffset = _endText.text.length;\n        }\n\n        while (startKey !== endKey && startOffset === startText.text.length) {\n          startText = this.getNextText(startKey);\n          startKey = startText.key;\n          startOffset = 0;\n        }\n      }\n\n      if (startKey === endKey) {\n        return startText.getActiveMarksBetweenOffsets(startOffset, endOffset);\n      }\n\n      var startMarks = startText.getActiveMarksBetweenOffsets(startOffset, startText.text.length);\n      if (startMarks.size === 0) return immutable.Set();\n      var endText = this.getDescendant(endKey);\n      var endMarks = endText.getActiveMarksBetweenOffsets(0, endOffset);\n      var marks = startMarks.intersect(endMarks);\n      // If marks is already empty, the active marks is empty\n      if (marks.size === 0) return marks;\n\n      var text = this.getNextText(startKey);\n\n      while (text.key !== endKey) {\n        if (text.text.length !== 0) {\n          marks = marks.intersect(text.getActiveMarks());\n          if (marks.size === 0) return immutable.Set();\n        }\n\n        text = this.getNextText(text.key);\n      }\n      return marks;\n    }\n\n    /**\n     * Get a set of marks in a `position`, the equivalent of a collapsed range\n     *\n     * @param {string} key\n     * @param {number} offset\n     * @return {Set}\n     */\n\n  }, {\n    key: 'getMarksAtPosition',\n    value: function getMarksAtPosition(key, offset) {\n      var text = this.getDescendant(key);\n      var currentMarks = text.getMarksAtIndex(offset);\n      if (offset !== 0) return currentMarks;\n      var closestBlock = this.getClosestBlock(key);\n\n      if (closestBlock.text === '') {\n        // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\n        return currentMarks;\n      }\n\n      var previous = this.getPreviousText(key);\n      if (!previous) return immutable.Set();\n\n      if (closestBlock.hasDescendant(previous.key)) {\n        return previous.getMarksAtIndex(previous.text.length);\n      }\n\n      return currentMarks;\n    }\n\n    /**\n     * Get all of the marks that match a `type`.\n     *\n     * @param {String} type\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getMarksByType',\n    value: function getMarksByType(type) {\n      var array = this.getMarksByTypeAsArray(type);\n      return new immutable.Set(array);\n    }\n\n    /**\n     * Get all of the marks that match a `type`.\n     *\n     * @param {String} type\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getOrderedMarksByType',\n    value: function getOrderedMarksByType(type) {\n      var array = this.getMarksByTypeAsArray(type);\n      return new immutable.OrderedSet(array);\n    }\n\n    /**\n     * Get all of the marks that match a `type` as an array.\n     *\n     * @param {String} type\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getMarksByTypeAsArray',\n    value: function getMarksByTypeAsArray(type) {\n      return this.nodes.reduce(function (array, node) {\n        return node.object == 'text' ? array.concat(node.getMarksAsArray().filter(function (m) {\n          return m.type == type;\n        })) : array.concat(node.getMarksByTypeAsArray(type));\n      }, []);\n    }\n\n    /**\n     * Get the block node before a descendant text node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextBlock',\n    value: function getNextBlock(key) {\n      var child = this.assertDescendant(key);\n      var last = void 0;\n\n      if (child.object == 'block') {\n        last = child.getLastText();\n      } else {\n        var block = this.getClosestBlock(key);\n        last = block.getLastText();\n      }\n\n      var next = this.getNextText(last.key);\n      if (!next) return null;\n\n      return this.getClosestBlock(next.key);\n    }\n\n    /**\n     * Get the node after a descendant by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextSibling',\n    value: function getNextSibling(key) {\n      key = assertKey(key);\n\n      var parent = this.getParent(key);\n      var after = parent.nodes.skipUntil(function (child) {\n        return child.key == key;\n      });\n\n      if (after.size == 0) {\n        throw new Error('Could not find a child node with key \"' + key + '\".');\n      }\n      return after.get(1);\n    }\n\n    /**\n     * Get the text node after a descendant text node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextText',\n    value: function getNextText(key) {\n      key = assertKey(key);\n      return this.getTexts().skipUntil(function (text) {\n        return text.key == key;\n      }).get(1);\n    }\n\n    /**\n     * Get a node in the tree by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNode',\n    value: function getNode(key) {\n      key = assertKey(key);\n      return this.key == key ? this : this.getDescendant(key);\n    }\n\n    /**\n     * Get a node in the tree by `path`.\n     *\n     * @param {Array} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNodeAtPath',\n    value: function getNodeAtPath(path) {\n      return path.length ? this.getDescendantAtPath(path) : this;\n    }\n\n    /**\n     * Get the offset for a descendant text node by `key`.\n     *\n     * @param {String} key\n     * @return {Number}\n     */\n\n  }, {\n    key: 'getOffset',\n    value: function getOffset(key) {\n      this.assertDescendant(key);\n\n      // Calculate the offset of the nodes before the highest child.\n      var child = this.getFurthestAncestor(key);\n      var offset = this.nodes.takeUntil(function (n) {\n        return n == child;\n      }).reduce(function (memo, n) {\n        return memo + n.text.length;\n      }, 0);\n\n      // Recurse if need be.\n      return this.hasChild(key) ? offset : offset + child.getOffset(key);\n    }\n\n    /**\n     * Get the offset from a `range`.\n     *\n     * @param {Range} range\n     * @return {Number}\n     */\n\n  }, {\n    key: 'getOffsetAtRange',\n    value: function getOffsetAtRange(range) {\n      range = range.normalize(this);\n\n      if (range.isUnset) {\n        throw new Error('The range cannot be unset to calculcate its offset.');\n      }\n\n      if (range.isExpanded) {\n        throw new Error('The range must be collapsed to calculcate its offset.');\n      }\n\n      var _range8 = range,\n          startKey = _range8.startKey,\n          startOffset = _range8.startOffset;\n\n      return this.getOffset(startKey) + startOffset;\n    }\n\n    /**\n     * Get the parent of a child node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getParent',\n    value: function getParent(key) {\n      if (this.hasChild(key)) return this;\n\n      var node = null;\n\n      this.nodes.find(function (child) {\n        if (child.object == 'text') {\n          return false;\n        } else {\n          node = child.getParent(key);\n          return node;\n        }\n      });\n\n      return node;\n    }\n\n    /**\n     * Get the path of a descendant node by `key`.\n     *\n     * @param {String|Node} key\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getPath',\n    value: function getPath(key) {\n      var child = this.assertNode(key);\n      var ancestors = this.getAncestors(key);\n      var path = [];\n\n      ancestors.reverse().forEach(function (ancestor) {\n        var index = ancestor.nodes.indexOf(child);\n        path.unshift(index);\n        child = ancestor;\n      });\n\n      return path;\n    }\n\n    /**\n     * Refind the path of node if path is changed.\n     *\n     * @param {Array} path\n     * @param {String} key\n     * @return {Array}\n     */\n\n  }, {\n    key: 'refindPath',\n    value: function refindPath(path, key) {\n      var node = this.getDescendantAtPath(path);\n\n      if (node && node.key === key) {\n        return path;\n      }\n\n      return this.getPath(key);\n    }\n\n    /**\n     *\n     * Refind the node with the same node.key after change.\n     *\n     * @param {Array} path\n     * @param {String} key\n     * @return {Node|Void}\n     */\n\n  }, {\n    key: 'refindNode',\n    value: function refindNode(path, key) {\n      var node = this.getDescendantAtPath(path);\n\n      if (node && node.key === key) {\n        return node;\n      }\n\n      return this.getDescendant(key);\n    }\n\n    /**\n     * Get the placeholder for the node from a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Component|Void}\n     */\n\n  }, {\n    key: 'getPlaceholder',\n    value: function getPlaceholder(schema) {\n      return schema.__getPlaceholder(this);\n    }\n\n    /**\n     * Get the block node before a descendant text node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousBlock',\n    value: function getPreviousBlock(key) {\n      var child = this.assertDescendant(key);\n      var first = void 0;\n\n      if (child.object == 'block') {\n        first = child.getFirstText();\n      } else {\n        var block = this.getClosestBlock(key);\n        first = block.getFirstText();\n      }\n\n      var previous = this.getPreviousText(first.key);\n      if (!previous) return null;\n\n      return this.getClosestBlock(previous.key);\n    }\n\n    /**\n     * Get the node before a descendant node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousSibling',\n    value: function getPreviousSibling(key) {\n      key = assertKey(key);\n      var parent = this.getParent(key);\n      var before = parent.nodes.takeUntil(function (child) {\n        return child.key == key;\n      });\n\n      if (before.size == parent.nodes.size) {\n        throw new Error('Could not find a child node with key \"' + key + '\".');\n      }\n\n      return before.last();\n    }\n\n    /**\n     * Get the text node before a descendant text node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousText',\n    value: function getPreviousText(key) {\n      key = assertKey(key);\n      return this.getTexts().takeUntil(function (text) {\n        return text.key == key;\n      }).last();\n    }\n\n    /**\n     * Get the indexes of the selection for a `range`, given an extra flag for\n     * whether the node `isSelected`, to determine whether not finding matches\n     * means everything is selected or nothing is.\n     *\n     * @param {Range} range\n     * @param {Boolean} isSelected\n     * @return {Object|Null}\n     */\n\n  }, {\n    key: 'getSelectionIndexes',\n    value: function getSelectionIndexes(range) {\n      var isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var startKey = range.startKey,\n          endKey = range.endKey;\n\n      // PERF: if we're not selected, we can exit early.\n\n      if (!isSelected) {\n        return null;\n      }\n\n      // if we've been given an invalid selection we can exit early.\n      if (range.isUnset) {\n        return null;\n      }\n\n      // PERF: if the start and end keys are the same, just check for the child\n      // that contains that single key.\n      if (startKey == endKey) {\n        var child = this.getFurthestAncestor(startKey);\n        var index = child ? this.nodes.indexOf(child) : null;\n        return { start: index, end: index + 1 };\n      }\n\n      // Otherwise, check all of the children...\n      var start = null;\n      var end = null;\n\n      this.nodes.forEach(function (child, i) {\n        if (child.object == 'text') {\n          if (start == null && child.key == startKey) start = i;\n          if (end == null && child.key == endKey) end = i + 1;\n        } else {\n          if (start == null && child.hasDescendant(startKey)) start = i;\n          if (end == null && child.hasDescendant(endKey)) end = i + 1;\n        }\n\n        // PERF: exit early if both start and end have been found.\n        return start == null || end == null;\n      });\n\n      if (isSelected && start == null) start = 0;\n      if (isSelected && end == null) end = this.nodes.size;\n      return start == null ? null : { start: start, end: end };\n    }\n\n    /**\n     * Get the concatenated text string of all child nodes.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'getText',\n    value: function getText() {\n      return this.nodes.reduce(function (string, node) {\n        return string + node.text;\n      }, '');\n    }\n\n    /**\n     * Get the descendent text node at an `offset`.\n     *\n     * @param {String} offset\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getTextAtOffset',\n    value: function getTextAtOffset(offset) {\n      // PERF: Add a few shortcuts for the obvious cases.\n      if (offset == 0) return this.getFirstText();\n      if (offset == this.text.length) return this.getLastText();\n      if (offset < 0 || offset > this.text.length) return null;\n\n      var length = 0;\n\n      return this.getTexts().find(function (node, i, nodes) {\n        length += node.text.length;\n        return length > offset;\n      });\n    }\n\n    /**\n     * Get the direction of the node's text.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'getTextDirection',\n    value: function getTextDirection() {\n      var dir = direction(this.text);\n      return dir == 'neutral' ? undefined : dir;\n    }\n\n    /**\n     * Recursively get all of the child text nodes in order of appearance.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getTexts',\n    value: function getTexts() {\n      var array = this.getTextsAsArray();\n      return new immutable.List(array);\n    }\n\n    /**\n     * Recursively get all the leaf text nodes in order of appearance, as array.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getTextsAsArray',\n    value: function getTextsAsArray() {\n      var array = [];\n\n      this.nodes.forEach(function (node) {\n        if (node.object == 'text') {\n          array.push(node);\n        } else {\n          array = array.concat(node.getTextsAsArray());\n        }\n      });\n\n      return array;\n    }\n\n    /**\n     * Get all of the text nodes in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getTextsAtRange',\n    value: function getTextsAtRange(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return immutable.List();\n      var _range9 = range,\n          startKey = _range9.startKey,\n          endKey = _range9.endKey;\n\n      return new immutable.List(this.getTextsBetweenPositionsAsArray(startKey, endKey));\n    }\n\n    /**\n     * Get all of the text nodes in a `range` as an array.\n     * PERF: use key in arguments for cache\n     *\n     * @param {string} startKey\n     * @param {string} endKey\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'getTextsBetweenPositionsAsArray',\n    value: function getTextsBetweenPositionsAsArray(startKey, endKey) {\n      var startText = this.getDescendant(startKey);\n\n      // PERF: the most common case is when the range is in a single text node,\n      // where we can avoid a lot of iterating of the tree.\n      if (startKey == endKey) return [startText];\n\n      var endText = this.getDescendant(endKey);\n      var texts = this.getTextsAsArray();\n      var start = texts.indexOf(startText);\n      var end = texts.indexOf(endText, start);\n      return texts.slice(start, end + 1);\n    }\n\n    /**\n     * Get all of the text nodes in a `range` as an array.\n     *\n     * @param {Range} range\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getTextsAtRangeAsArray',\n    value: function getTextsAtRangeAsArray(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return [];\n      var _range10 = range,\n          startKey = _range10.startKey,\n          endKey = _range10.endKey;\n\n      return this.getTextsBetweenPositionsAsArray(startKey, endKey);\n    }\n\n    /**\n     * Check if a child node exists by `key`.\n     *\n     * @param {String} key\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasChild',\n    value: function hasChild(key) {\n      return !!this.getChild(key);\n    }\n\n    /**\n     * Check if a node has block node children.\n     *\n     * @param {String} key\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasBlocks',\n    value: function hasBlocks(key) {\n      var node = this.assertNode(key);\n      return !!(node.nodes && node.nodes.find(function (n) {\n        return n.object === 'block';\n      }));\n    }\n\n    /**\n     * Check if a node has inline node children.\n     *\n     * @param {String} key\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasInlines',\n    value: function hasInlines(key) {\n      var node = this.assertNode(key);\n      return !!(node.nodes && node.nodes.find(function (n) {\n        return Inline.isInline(n) || Text.isText(n);\n      }));\n    }\n\n    /**\n     * Recursively check if a child node exists by `key`.\n     *\n     * @param {String} key\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasDescendant',\n    value: function hasDescendant(key) {\n      return !!this.getDescendant(key);\n    }\n\n    /**\n     * Recursively check if a node exists by `key`.\n     *\n     * @param {String} key\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasNode',\n    value: function hasNode(key) {\n      return !!this.getNode(key);\n    }\n\n    /**\n     * Check if a node has a void parent by `key`.\n     *\n     * @param {String} key\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasVoidParent',\n    value: function hasVoidParent(key) {\n      return !!this.getClosestVoid(key);\n    }\n\n    /**\n     * Insert a `node` at `index`.\n     *\n     * @param {Number} index\n     * @param {Node} node\n     * @return {Node}\n     */\n\n  }, {\n    key: 'insertNode',\n    value: function insertNode(index, node) {\n      var keys = this.getKeysAsArray();\n\n      if (keys.includes(node.key)) {\n        node = node.regenerateKey();\n      }\n\n      if (node.object != 'text') {\n        node = node.mapDescendants(function (desc) {\n          return keys.includes(desc.key) ? desc.regenerateKey() : desc;\n        });\n      }\n\n      var nodes = this.nodes.insert(index, node);\n      return this.set('nodes', nodes);\n    }\n\n    /**\n     * Check whether the node is in a `range`.\n     *\n     * @param {Range} range\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInRange',\n    value: function isInRange(range) {\n      range = range.normalize(this);\n\n      var node = this;\n      var _range11 = range,\n          startKey = _range11.startKey,\n          endKey = _range11.endKey,\n          isCollapsed = _range11.isCollapsed;\n\n      // PERF: solve the most common cast where the start or end key are inside\n      // the node, for collapsed selections.\n\n      if (node.key == startKey || node.key == endKey || node.hasDescendant(startKey) || node.hasDescendant(endKey)) {\n        return true;\n      }\n\n      // PERF: if the selection is collapsed and the previous check didn't return\n      // true, then it must be false.\n      if (isCollapsed) {\n        return false;\n      }\n\n      // Otherwise, look through all of the leaf text nodes in the range, to see\n      // if any of them are inside the node.\n      var texts = node.getTextsAtRange(range);\n      var memo = false;\n\n      texts.forEach(function (text) {\n        if (node.hasDescendant(text.key)) memo = true;\n        return memo;\n      });\n\n      return memo;\n    }\n\n    /**\n     * Check whether the node is a leaf block.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafBlock',\n    value: function isLeafBlock() {\n      return this.object == 'block' && this.nodes.every(function (n) {\n        return n.object != 'block';\n      });\n    }\n\n    /**\n     * Check whether the node is a leaf inline.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafInline',\n    value: function isLeafInline() {\n      return this.object == 'inline' && this.nodes.every(function (n) {\n        return n.object != 'inline';\n      });\n    }\n\n    /**\n     * Merge a children node `first` with another children node `second`.\n     * `first` and `second` will be concatenated in that order.\n     * `first` and `second` must be two Nodes or two Text.\n     *\n     * @param {Node} first\n     * @param {Node} second\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mergeNode',\n    value: function mergeNode(withIndex, index) {\n      var node = this;\n      var one = node.nodes.get(withIndex);\n      var two = node.nodes.get(index);\n\n      if (one.object != two.object) {\n        throw new Error('Tried to merge two nodes of different objects: \"' + one.object + '\" and \"' + two.object + '\".');\n      }\n\n      // If the nodes are text nodes, concatenate their leaves together\n      if (one.object == 'text') {\n        one = one.mergeText(two);\n      } else {\n        // Otherwise, concatenate their child nodes together.\n        var nodes = one.nodes.concat(two.nodes);\n        one = one.set('nodes', nodes);\n      }\n\n      node = node.removeNode(index);\n      node = node.removeNode(withIndex);\n      node = node.insertNode(withIndex, one);\n      return node;\n    }\n\n    /**\n     * Map all child nodes, updating them in their parents. This method is\n     * optimized to not return a new node if no changes are made.\n     *\n     * @param {Function} iterator\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mapChildren',\n    value: function mapChildren(iterator) {\n      var _this2 = this;\n\n      var nodes = this.nodes;\n\n\n      nodes.forEach(function (node, i) {\n        var ret = iterator(node, i, _this2.nodes);\n        if (ret != node) nodes = nodes.set(ret.key, ret);\n      });\n\n      return this.set('nodes', nodes);\n    }\n\n    /**\n     * Map all descendant nodes, updating them in their parents. This method is\n     * optimized to not return a new node if no changes are made.\n     *\n     * @param {Function} iterator\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mapDescendants',\n    value: function mapDescendants(iterator) {\n      var _this3 = this;\n\n      var nodes = this.nodes;\n\n\n      nodes.forEach(function (node, index) {\n        var ret = node;\n        if (ret.object != 'text') ret = ret.mapDescendants(iterator);\n        ret = iterator(ret, index, _this3.nodes);\n        if (ret == node) return;\n\n        nodes = nodes.set(index, ret);\n      });\n\n      return this.set('nodes', nodes);\n    }\n\n    /**\n     * Regenerate the node's key.\n     *\n     * @return {Node}\n     */\n\n  }, {\n    key: 'regenerateKey',\n    value: function regenerateKey() {\n      var key = generateKey();\n      return this.set('key', key);\n    }\n\n    /**\n     * Remove a `node` from the children node map.\n     *\n     * @param {String} key\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeDescendant',\n    value: function removeDescendant(key) {\n      key = assertKey(key);\n\n      var node = this;\n      var parent = node.getParent(key);\n      if (!parent) throw new Error('Could not find a descendant node with key \"' + key + '\".');\n\n      var index = parent.nodes.findIndex(function (n) {\n        return n.key === key;\n      });\n      var nodes = parent.nodes.delete(index);\n\n      parent = parent.set('nodes', nodes);\n      node = node.updateNode(parent);\n      return node;\n    }\n\n    /**\n     * Remove a node at `index`.\n     *\n     * @param {Number} index\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeNode',\n    value: function removeNode(index) {\n      var nodes = this.nodes.delete(index);\n      return this.set('nodes', nodes);\n    }\n\n    /**\n     * Split a child node by `index` at `position`.\n     *\n     * @param {Number} index\n     * @param {Number} position\n     * @return {Node}\n     */\n\n  }, {\n    key: 'splitNode',\n    value: function splitNode(index, position) {\n      var node = this;\n      var child = node.nodes.get(index);\n      var one = void 0;\n      var two = void 0;\n\n      // If the child is a text node, the `position` refers to the text offset at\n      // which to split it.\n      if (child.object == 'text') {\n        \n        var _child$splitText = child.splitText(position);\n\n        var _child$splitText2 = slicedToArray(_child$splitText, 2);\n\n        one = _child$splitText2[0];\n        two = _child$splitText2[1];\n      } else {\n        // Otherwise, if the child is not a text node, the `position` refers to the\n        // index at which to split its children.\n        var befores = child.nodes.take(position);\n        var afters = child.nodes.skip(position);\n        one = child.set('nodes', befores);\n        two = child.set('nodes', afters).regenerateKey();\n      }\n\n      // Remove the old node and insert the newly split children.\n      node = node.removeNode(index);\n      node = node.insertNode(index, two);\n      node = node.insertNode(index, one);\n      return node;\n    }\n\n    /**\n     * Set a new value for a child node by `key`.\n     *\n     * @param {Node} node\n     * @return {Node}\n     */\n\n  }, {\n    key: 'updateNode',\n    value: function updateNode(node) {\n      if (node.key == this.key) {\n        return node;\n      }\n\n      var child = this.assertDescendant(node.key);\n      var ancestors = this.getAncestors(node.key);\n\n      ancestors.reverse().forEach(function (parent) {\n        var _parent = parent,\n            nodes = _parent.nodes;\n\n        var index = nodes.indexOf(child);\n        child = parent;\n        nodes = nodes.set(index, node);\n        parent = parent.set('nodes', nodes);\n        node = parent;\n      });\n\n      return node;\n    }\n\n    /**\n     * Validate the node against a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Function|Null}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(schema) {\n      return schema.validateNode(this);\n    }\n\n    /**\n     * Get the first invalid descendant\n     *\n     * @param {Schema} schema\n     * @return {Node|Text|Null}\n     */\n\n  }, {\n    key: 'getFirstInvalidDescendant',\n    value: function getFirstInvalidDescendant(schema) {\n      var result = null;\n\n      this.nodes.find(function (n) {\n        result = n.validate(schema) ? n : n.getFirstInvalidDescendant(schema);\n        return result;\n      });\n      return result;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Node` with `attrs`.\n     *\n     * @param {Object|Node} attrs\n     * @return {Node}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Node.isNode(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        var object = attrs.object;\n\n\n        if (!object && attrs.kind) {\n          logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n\n          object = attrs.kind;\n        }\n\n        switch (object) {\n          case 'block':\n            return Block.create(attrs);\n          case 'document':\n            return Document.create(attrs);\n          case 'inline':\n            return Inline.create(attrs);\n          case 'text':\n            return Text.create(attrs);\n\n          default:\n            {\n              throw new Error('`Node.create` requires a `object` string.');\n            }\n        }\n      }\n\n      throw new Error('`Node.create` only accepts objects or nodes but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Nodes` from an array.\n     *\n     * @param {Array<Object|Node>} elements\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = immutable.List(elements.map(Node.create));\n        return list;\n      }\n\n      throw new Error('`Node.createList` only accepts lists or arrays, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a dictionary of settable node properties from `attrs`.\n     *\n     * @param {Object|String|Node} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n        return {\n          data: attrs.data,\n          isVoid: attrs.isVoid,\n          type: attrs.type\n        };\n      }\n\n      if (typeof attrs == 'string') {\n        return { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        var props = {};\n        if ('type' in attrs) props.type = attrs.type;\n        if ('data' in attrs) props.data = Data.create(attrs.data);\n        if ('isVoid' in attrs) props.isVoid = attrs.isVoid;\n        return props;\n      }\n\n      throw new Error('`Node.createProperties` only accepts objects, strings, blocks or inlines, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Node` from a JSON `value`.\n     *\n     * @param {Object} value\n     * @return {Node}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(value) {\n      var object = value.object;\n\n\n      if (!object && value.kind) {\n        logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n\n        object = value.kind;\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.fromJSON(value);\n        case 'document':\n          return Document.fromJSON(value);\n        case 'inline':\n          return Inline.fromJSON(value);\n        case 'text':\n          return Text.fromJSON(value);\n\n        default:\n          {\n            throw new Error('`Node.fromJSON` requires an `object` of either \\'block\\', \\'document\\', \\'inline\\' or \\'text\\', but you passed: ' + value);\n          }\n      }\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }, {\n    key: 'isNode',\n\n\n    /**\n     * Check if `any` is a `Node`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isNode(any) {\n      return !!['BLOCK', 'DOCUMENT', 'INLINE', 'TEXT'].find(function (type) {\n        return isType(type, any);\n      });\n    }\n\n    /**\n     * Check if `any` is a list of nodes.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isNodeList',\n    value: function isNodeList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Node.isNode(item);\n      });\n    }\n  }]);\n  return Node;\n}();\n\n/**\n * Assert a key `arg`.\n *\n * @param {String} arg\n * @return {String}\n */\n\nNode.fromJS = Node.fromJSON;\nfunction assertKey(arg) {\n  if (typeof arg == 'string') return arg;\n  throw new Error('Invalid `key` argument! It must be a key string, but you passed: ' + arg);\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Node.prototype, ['areDescendantsSorted', 'getAncestors', 'getBlocksAsArray', 'getBlocksAtRangeAsArray', 'getBlocksByTypeAsArray', 'getChild', 'getClosestBlock', 'getClosestInline', 'getClosestVoid', 'getCommonAncestor', 'getDecorations', 'getDepth', 'getDescendant', 'getDescendantAtPath', 'getFirstText', 'getFragmentAtRange', 'getFurthestBlock', 'getFurthestInline', 'getFurthestAncestor', 'getFurthestOnlyChildAncestor', 'getInlinesAsArray', 'getInlinesAtRangeAsArray', 'getInlinesByTypeAsArray', 'getMarksAsArray', 'getMarksAtPosition', 'getOrderedMarksBetweenPositions', 'getInsertMarksAtRange', 'getKeysAsArray', 'getLastText', 'getMarksByTypeAsArray', 'getNextBlock', 'getNextSibling', 'getNextText', 'getNode', 'getNodeAtPath', 'getOffset', 'getOffsetAtRange', 'getParent', 'getPath', 'getPlaceholder', 'getPreviousBlock', 'getPreviousSibling', 'getPreviousText', 'getText', 'getTextAtOffset', 'getTextDirection', 'getTextsAsArray', 'getTextsBetweenPositionsAsArray', 'isLeafBlock', 'isLeafInline', 'validate', 'getFirstInvalidDescendant']);\n\n/**\n * Mix in `Node` methods.\n */\n\nObject.getOwnPropertyNames(Node.prototype).forEach(function (method) {\n  if (method == 'constructor') return;\n  Block.prototype[method] = Node.prototype[method];\n  Inline.prototype[method] = Node.prototype[method];\n  Document.prototype[method] = Node.prototype[method];\n});\n\nBlock.createChildren = Node.createList;\nInline.createChildren = Node.createList;\nDocument.createChildren = Node.createList;\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nvar SURROGATE_START = 0xd800;\nvar SURROGATE_END = 0xdfff;\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nvar SPACE = /\\s/;\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nvar CHAMELEON = /['\\u2018\\u2019]/;\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END;\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false;\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    var next = remaining.charAt(0);\n    var length = getCharLength(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n    if (isWord(next, rest)) return true;\n  }\n\n  if (PUNCTUATION.test(char)) return false;\n  return true;\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1;\n}\n\n/**\n * Get the offset to the end of the first character in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getCharOffset(text) {\n  var char = text.charAt(0);\n  return getCharLength(char);\n}\n\n/**\n * Get the offset to the end of the character before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset) {\n  text = text.slice(0, offset);\n  text = esrever.reverse(text);\n  return getCharOffset(text);\n}\n\n/**\n * Get the offset to the end of the character after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset) {\n  text = text.slice(offset);\n  return getCharOffset(text);\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  var length = 0;\n  var i = 0;\n  var started = false;\n  var char = void 0;\n\n  while (char = text.charAt(i)) {\n    var l = getCharLength(char);\n    char = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWord(char, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset);\n  text = esrever.reverse(text);\n  var o = getWordOffset(text);\n  return o;\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset);\n  var o = getWordOffset(text);\n  return o;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar String = {\n  getCharOffsetForward: getCharOffsetForward,\n  getCharOffsetBackward: getCharOffsetBackward,\n  getWordOffsetBackward: getWordOffsetBackward,\n  getWordOffsetForward: getWordOffsetForward\n};\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes$1 = {};\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.addMarkAtRange = function (change, range, mark) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (range.isCollapsed) return;\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n  var texts = document.getTextsAtRange(range);\n\n  texts.forEach(function (node) {\n    var key = node.key;\n\n    var index = 0;\n    var length = node.text.length;\n\n    if (key == startKey) index = startOffset;\n    if (key == endKey) length = endOffset;\n    if (key == startKey && key == endKey) length = endOffset - startOffset;\n\n    change.addMarkByKey(key, index, length, mark, { normalize: normalize });\n  });\n};\n\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Array<Mixed>} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.addMarksAtRange = function (change, range, marks) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  marks.forEach(function (mark) {\n    return change.addMarkAtRange(range, mark, options);\n  });\n};\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteAtRange = function (change, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (range.isCollapsed) return;\n\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  change.snapshotSelection();\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n  var document = value.document;\n\n  var isStartVoid = document.hasVoidParent(startKey);\n  var isEndVoid = document.hasVoidParent(endKey);\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(endKey);\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  var isHanging = startOffset == 0 && endOffset == 0 && isStartVoid == false && startKey == startBlock.getFirstText().key && endKey == endBlock.getFirstText().key;\n\n  // If it's a hanging selection, nudge it back to end in the previous text.\n  if (isHanging && isEndVoid) {\n    var prevText = document.getPreviousText(endKey);\n    endKey = prevText.key;\n    endOffset = prevText.text.length;\n    isEndVoid = document.hasVoidParent(endKey);\n  }\n\n  // If the start node is inside a void node, remove the void node and update\n  // the starting point to be right after it, continuously until the start point\n  // is not a void, or until the entire range is handled.\n  while (isStartVoid) {\n    var startVoid = document.getClosestVoid(startKey);\n    var nextText = document.getNextText(startKey);\n    change.removeNodeByKey(startVoid.key, { normalize: false });\n\n    // If the start and end keys are the same, we're done.\n    if (startKey == endKey) return;\n\n    // If there is no next text node, we're done.\n    if (!nextText) return;\n\n    // Continue...\n    document = change.value.document;\n    startKey = nextText.key;\n    startOffset = 0;\n    isStartVoid = document.hasVoidParent(startKey);\n  }\n\n  // If the end node is inside a void node, do the same thing but backwards. But\n  // we don't need any aborting checks because if we've gotten this far there\n  // must be a non-void node that will exit the loop.\n  while (isEndVoid) {\n    var endVoid = document.getClosestVoid(endKey);\n    var _prevText = document.getPreviousText(endKey);\n    change.removeNodeByKey(endVoid.key, { normalize: false });\n\n    // Continue...\n    document = change.value.document;\n    endKey = _prevText.key;\n    endOffset = _prevText.text.length;\n    isEndVoid = document.hasVoidParent(endKey);\n  }\n\n  // If the start and end key are the same, and it was a hanging selection, we\n  // can just remove the entire block.\n  if (startKey == endKey && isHanging) {\n    change.removeNodeByKey(startBlock.key, { normalize: normalize });\n    return;\n  } else if (startKey == endKey) {\n    // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n    // simply remove the text in the range.\n    var index = startOffset;\n    var length = endOffset - startOffset;\n    change.removeTextByKey(startKey, index, length, { normalize: normalize });\n    return;\n  } else {\n    // Otherwise, we need to recursively remove text and nodes inside the start\n    // block after the start offset and inside the end block before the end\n    // offset. Then remove any blocks that are in between the start and end\n    // blocks. Then finally merge the start and end nodes.\n    startBlock = document.getClosestBlock(startKey);\n    endBlock = document.getClosestBlock(endKey);\n    var startText = document.getNode(startKey);\n    var endText = document.getNode(endKey);\n    var startLength = startText.text.length - startOffset;\n    var endLength = endOffset;\n\n    var ancestor = document.getCommonAncestor(startKey, endKey);\n    var startChild = ancestor.getFurthestAncestor(startKey);\n    var endChild = ancestor.getFurthestAncestor(endKey);\n\n    var startParent = document.getParent(startBlock.key);\n    var startParentIndex = startParent.nodes.indexOf(startBlock);\n    var endParentIndex = startParent.nodes.indexOf(endBlock);\n\n    var child = void 0;\n\n    // Iterate through all of the nodes in the tree after the start text node\n    // but inside the end child, and remove them.\n    child = startText;\n\n    while (child.key != startChild.key) {\n      var parent = document.getParent(child.key);\n      var _index = parent.nodes.indexOf(child);\n      var afters = parent.nodes.slice(_index + 1);\n\n      afters.reverse().forEach(function (node) {\n        change.removeNodeByKey(node.key, { normalize: false });\n      });\n\n      child = parent;\n    }\n\n    // Remove all of the middle children.\n    var startChildIndex = ancestor.nodes.indexOf(startChild);\n    var endChildIndex = ancestor.nodes.indexOf(endChild);\n    var middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex);\n\n    middles.reverse().forEach(function (node) {\n      change.removeNodeByKey(node.key, { normalize: false });\n    });\n\n    // Remove the nodes before the end text node in the tree.\n    child = endText;\n\n    while (child.key != endChild.key) {\n      var _parent = document.getParent(child.key);\n      var _index2 = _parent.nodes.indexOf(child);\n      var befores = _parent.nodes.slice(0, _index2);\n\n      befores.reverse().forEach(function (node) {\n        change.removeNodeByKey(node.key, { normalize: false });\n      });\n\n      child = _parent;\n    }\n\n    // Remove any overlapping text content from the leaf text nodes.\n    if (startLength != 0) {\n      change.removeTextByKey(startKey, startOffset, startLength, {\n        normalize: false\n      });\n    }\n\n    if (endLength != 0) {\n      change.removeTextByKey(endKey, 0, endOffset, { normalize: false });\n    }\n\n    // If the start and end blocks aren't the same, move and merge the end block\n    // into the start block.\n    if (startBlock.key != endBlock.key) {\n      document = change.value.document;\n      var lonely = document.getFurthestOnlyChildAncestor(endBlock.key);\n\n      // Move the end block to be right after the start block.\n      if (endParentIndex != startParentIndex + 1) {\n        change.moveNodeByKey(endBlock.key, startParent.key, startParentIndex + 1, { normalize: false });\n      }\n\n      // If the selection is hanging, just remove the start block, otherwise\n      // merge the end block into it.\n      if (isHanging) {\n        change.removeNodeByKey(startBlock.key, { normalize: false });\n      } else {\n        change.mergeNodeByKey(endBlock.key, { normalize: false });\n      }\n\n      // If nested empty blocks are left over above the end block, remove them.\n      if (lonely) {\n        change.removeNodeByKey(lonely.key, { normalize: false });\n      }\n    }\n\n    // If we should normalize, do it now after everything.\n    if (normalize) {\n      change.normalizeNodeByKey(ancestor.key);\n    }\n  }\n};\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteCharBackwardAtRange = function (change, range, options) {\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = String.getCharOffsetBackward(text, o);\n  change.deleteBackwardAtRange(range, n, options);\n};\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteLineBackwardAtRange = function (change, range, options) {\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  change.deleteBackwardAtRange(range, o, options);\n};\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteWordBackwardAtRange = function (change, range, options) {\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = String.getWordOffsetBackward(text, o);\n  change.deleteBackwardAtRange(range, n, options);\n};\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteBackwardAtRange = function (change, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (n === 0) return;\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n  var _range = range,\n      startKey = _range.startKey,\n      focusOffset = _range.focusOffset;\n\n  // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  var voidParent = document.getClosestVoid(startKey);\n\n  // If there is a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key, { normalize: normalize });\n    return;\n  }\n\n  var block = document.getClosestBlock(startKey);\n\n  // If the closest is not void, but empty, remove it\n  if (block && block.isEmpty && document.nodes.size !== 1) {\n    change.removeNodeByKey(block.key, { normalize: normalize });\n    return;\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtStartOf(document)) {\n    return;\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  var text = document.getDescendant(startKey);\n\n  if (range.isAtStartOf(text)) {\n    var prev = document.getPreviousText(text.key);\n    var prevBlock = document.getClosestBlock(prev.key);\n    var prevVoid = document.getClosestVoid(prev.key);\n\n    // If the previous text node has a void parent, remove it.\n    if (prevVoid) {\n      change.removeNodeByKey(prevVoid.key, { normalize: normalize });\n      return;\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && prevBlock != block) {\n      range = range.merge({\n        anchorKey: prev.key,\n        anchorOffset: prev.text.length\n      });\n\n      change.deleteAtRange(range, { normalize: normalize });\n      return;\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n < focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset - n,\n      isBackward: true\n    });\n\n    change.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  var node = text;\n  var offset = 0;\n  var traversed = focusOffset;\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key);\n    var next = traversed + node.text.length;\n\n    if (n <= next) {\n      offset = next - n;\n      break;\n    } else {\n      traversed = next;\n    }\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset,\n    isBackward: true\n  });\n\n  change.deleteAtRange(range, { normalize: normalize });\n};\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteCharForwardAtRange = function (change, range, options) {\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = String.getCharOffsetForward(text, o);\n  change.deleteForwardAtRange(range, n, options);\n};\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteLineForwardAtRange = function (change, range, options) {\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  change.deleteForwardAtRange(range, startBlock.text.length - o, options);\n};\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteWordForwardAtRange = function (change, range, options) {\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = String.getWordOffsetForward(text, o);\n  change.deleteForwardAtRange(range, n, options);\n};\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteForwardAtRange = function (change, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (n === 0) return;\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n  var _range2 = range,\n      startKey = _range2.startKey,\n      focusOffset = _range2.focusOffset;\n\n  // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  var voidParent = document.getClosestVoid(startKey);\n\n  // If the node has a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key, { normalize: normalize });\n    return;\n  }\n\n  var block = document.getClosestBlock(startKey);\n\n  // If the closest is not void, but empty, remove it\n  if (block && block.isEmpty && document.nodes.size !== 1) {\n    var nextBlock = document.getNextBlock(block.key);\n    change.removeNodeByKey(block.key, { normalize: normalize });\n\n    if (nextBlock && nextBlock.key) {\n      change.moveToStartOf(nextBlock);\n    }\n    return;\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtEndOf(document)) {\n    return;\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  var text = document.getDescendant(startKey);\n\n  if (range.isAtEndOf(text)) {\n    var next = document.getNextText(text.key);\n    var _nextBlock = document.getClosestBlock(next.key);\n    var nextVoid = document.getClosestVoid(next.key);\n\n    // If the next text node has a void parent, remove it.\n    if (nextVoid) {\n      change.removeNodeByKey(nextVoid.key, { normalize: normalize });\n      return;\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && _nextBlock != block) {\n      range = range.merge({\n        focusKey: next.key,\n        focusOffset: 0\n      });\n\n      change.deleteAtRange(range, { normalize: normalize });\n      return;\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.text.length - focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset + n\n    });\n\n    change.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  var node = text;\n  var offset = focusOffset;\n  var traversed = text.text.length - focusOffset;\n\n  while (n > traversed) {\n    node = document.getNextText(node.key);\n    var _next = traversed + node.text.length;\n\n    if (n <= _next) {\n      offset = n - traversed;\n      break;\n    } else {\n      traversed = _next;\n    }\n  }\n\n  // If the focus node is inside a void, go up until right before it.\n  if (document.hasVoidParent(node.key)) {\n    var parent = document.getClosestVoid(node.key);\n    node = document.getPreviousText(parent.key);\n    offset = node.text.length;\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset\n  });\n\n  change.deleteAtRange(range, { normalize: normalize });\n};\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|String|Object} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.insertBlockAtRange = function (change, range, block) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  block = Block.create(block);\n  var normalize = change.getFlag('normalize', options);\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range);\n    range = range.collapseToStart();\n  }\n\n  var value = change.value;\n  var document = value.document;\n  var _range3 = range,\n      startKey = _range3.startKey,\n      startOffset = _range3.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var parent = document.getParent(startBlock.key);\n  var index = parent.nodes.indexOf(startBlock);\n\n  if (startBlock.isVoid) {\n    var extra = range.isAtEndOf(startBlock) ? 1 : 0;\n    change.insertNodeByKey(parent.key, index + extra, block, { normalize: normalize });\n  } else if (startBlock.isEmpty) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });\n  } else if (range.isAtStartOf(startBlock)) {\n    change.insertNodeByKey(parent.key, index, block, { normalize: normalize });\n  } else if (range.isAtEndOf(startBlock)) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });\n  } else {\n    change.splitDescendantsByKey(startBlock.key, startKey, startOffset, {\n      normalize: false\n    });\n\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });\n  }\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Document} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.insertFragmentAtRange = function (change, range, fragment) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var normalize = change.getFlag('normalize', options);\n\n  // If the range is expanded, delete it first.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false });\n\n    if (change.value.document.getDescendant(range.startKey)) {\n      range = range.collapseToStart();\n    } else {\n      range = range.collapseTo(range.endKey, 0);\n    }\n  }\n\n  // If the fragment is empty, there's nothing to do after deleting.\n  if (!fragment.nodes.size) return;\n\n  // Regenerate the keys for all of the fragments nodes, so that they're\n  // guaranteed not to collide with the existing keys in the document. Otherwise\n  // they will be rengerated automatically and we won't have an easy way to\n  // reference them.\n  fragment = fragment.mapDescendants(function (child) {\n    return child.regenerateKey();\n  });\n\n  // Calculate a few things...\n  var _range4 = range,\n      startKey = _range4.startKey,\n      startOffset = _range4.startOffset;\n  var value = change.value;\n  var document = value.document;\n\n  var startText = document.getDescendant(startKey);\n  var startBlock = document.getClosestBlock(startText.key);\n  var startChild = startBlock.getFurthestAncestor(startText.key);\n  var isAtStart = range.isAtStartOf(startBlock);\n  var parent = document.getParent(startBlock.key);\n  var index = parent.nodes.indexOf(startBlock);\n  var blocks = fragment.getBlocks();\n  var firstChild = fragment.nodes.first();\n  var lastChild = fragment.nodes.last();\n  var firstBlock = blocks.first();\n  var lastBlock = blocks.last();\n\n  // If the fragment only contains a void block, use `insertBlock` instead.\n  if (firstBlock == lastBlock && firstBlock.isVoid) {\n    change.insertBlockAtRange(range, firstBlock, options);\n    return;\n  }\n\n  // If the fragment starts or ends with single nested block, (e.g., table),\n  // do not merge this fragment with existing blocks.\n  if (fragment.hasBlocks(firstChild.key) || fragment.hasBlocks(lastChild.key)) {\n    fragment.nodes.reverse().forEach(function (node) {\n      change.insertBlockAtRange(range, node, options);\n    });\n    return;\n  }\n\n  // If the first and last block aren't the same, we need to insert all of the\n  // nodes after the fragment's first block at the index.\n  if (firstBlock != lastBlock) {\n    var lonelyParent = fragment.getFurthest(firstBlock.key, function (p) {\n      return p.nodes.size == 1;\n    });\n    var lonelyChild = lonelyParent || firstBlock;\n    var startIndex = parent.nodes.indexOf(startBlock);\n    fragment = fragment.removeDescendant(lonelyChild.key);\n\n    fragment.nodes.forEach(function (node, i) {\n      var newIndex = startIndex + i + 1;\n      change.insertNodeByKey(parent.key, newIndex, node, { normalize: false });\n    });\n  }\n\n  // Check if we need to split the node.\n  if (startOffset != 0) {\n    change.splitDescendantsByKey(startChild.key, startKey, startOffset, {\n      normalize: false\n    });\n  }\n\n  // Update our variables with the new value.\n  document = change.value.document;\n  startText = document.getDescendant(startKey);\n  startBlock = document.getClosestBlock(startKey);\n  startChild = startBlock.getFurthestAncestor(startText.key);\n\n  // If the first and last block aren't the same, we need to move any of the\n  // starting block's children after the split into the last block of the\n  // fragment, which has already been inserted.\n  if (firstBlock != lastBlock) {\n    var nextChild = isAtStart ? startChild : startBlock.getNextSibling(startChild.key);\n    var nextNodes = nextChild ? startBlock.nodes.skipUntil(function (n) {\n      return n.key == nextChild.key;\n    }) : immutable.List();\n    var lastIndex = lastBlock.nodes.size;\n\n    nextNodes.forEach(function (node, i) {\n      var newIndex = lastIndex + i;\n\n      change.moveNodeByKey(node.key, lastBlock.key, newIndex, {\n        normalize: false\n      });\n    });\n  }\n\n  // If the starting block is empty, we replace it entirely with the first block\n  // of the fragment, since this leads to a more expected behavior for the user.\n  if (startBlock.isEmpty) {\n    change.removeNodeByKey(startBlock.key, { normalize: false });\n    change.insertNodeByKey(parent.key, index, firstBlock, { normalize: false });\n  } else {\n    // Otherwise, we maintain the starting block, and insert all of the first\n    // block's inline nodes into it at the split point.\n    var inlineChild = startBlock.getFurthestAncestor(startText.key);\n    var inlineIndex = startBlock.nodes.indexOf(inlineChild);\n\n    firstBlock.nodes.forEach(function (inline, i) {\n      var o = startOffset == 0 ? 0 : 1;\n      var newIndex = inlineIndex + i + o;\n\n      change.insertNodeByKey(startBlock.key, newIndex, inline, {\n        normalize: false\n      });\n    });\n  }\n\n  // Normalize if requested.\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|String|Object} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.insertInlineAtRange = function (change, range, inline) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  inline = Inline.create(inline);\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false });\n    range = range.collapseToStart();\n  }\n\n  var value = change.value;\n  var document = value.document;\n  var _range5 = range,\n      startKey = _range5.startKey,\n      startOffset = _range5.startOffset;\n\n  var parent = document.getParent(startKey);\n  var startText = document.assertDescendant(startKey);\n  var index = parent.nodes.indexOf(startText);\n\n  if (parent.isVoid) return;\n\n  change.splitNodeByKey(startKey, startOffset, { normalize: false });\n  change.insertNodeByKey(parent.key, index + 1, inline, { normalize: false });\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.insertTextAtRange = function (change, range, text, marks) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var normalize = options.normalize;\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var key = startKey;\n  var offset = startOffset;\n  var parent = document.getParent(startKey);\n\n  if (parent.isVoid) return;\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false });\n\n    // Update range start after delete\n    if (change.value.startKey !== key) {\n      key = change.value.startKey;\n      offset = change.value.startOffset;\n    }\n  }\n\n  // PERF: Unless specified, don't normalize if only inserting text.\n  if (normalize === undefined) {\n    normalize = range.isExpanded && marks && marks.size !== 0;\n  }\n\n  change.insertTextByKey(key, offset, text, marks, { normalize: false });\n\n  if (normalize) {\n    // normalize in the narrowest existing block that originally contains startKey and endKey\n    var commonAncestor = document.getCommonAncestor(startKey, range.endKey);\n    var ancestors = document.getAncestors(commonAncestor.key).push(commonAncestor);\n    var normalizeAncestor = ancestors.findLast(function (n) {\n      return change.value.document.getDescendant(n.key);\n    });\n    // it is possible that normalizeAncestor doesn't return any node\n    // on that case fallback to startKey to be normalized\n    var normalizeKey = normalizeAncestor ? normalizeAncestor.key : startKey;\n    change.normalizeNodeByKey(normalizeKey);\n  }\n};\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.removeMarkAtRange = function (change, range, mark) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (range.isCollapsed) return;\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var texts = document.getTextsAtRange(range);\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n\n  texts.forEach(function (node) {\n    var key = node.key;\n\n    var index = 0;\n    var length = node.text.length;\n\n    if (key == startKey) index = startOffset;\n    if (key == endKey) length = endOffset;\n    if (key == startKey && key == endKey) length = endOffset - startOffset;\n\n    change.removeMarkByKey(key, index, length, mark, { normalize: normalize });\n  });\n};\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.setBlocksAtRange = function (change, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var blocks = document.getBlocksAtRange(range);\n\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset,\n      isCollapsed = range.isCollapsed;\n\n  var isStartVoid = document.hasVoidParent(startKey);\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(endKey);\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  var isHanging = isCollapsed == false && startOffset == 0 && endOffset == 0 && isStartVoid == false && startKey == startBlock.getFirstText().key && endKey == endBlock.getFirstText().key;\n\n  // If it's a hanging selection, ignore the last block.\n  var sets = isHanging ? blocks.slice(0, -1) : blocks;\n\n  sets.forEach(function (block) {\n    change.setNodeByKey(block.key, properties, { normalize: normalize });\n  });\n};\n\nChanges$1.setBlockAtRange = function () {\n  logger.deprecate('slate@0.33.0', 'The `setBlockAtRange` method of Slate changes has been renamed to `setBlocksAtRange`.');\n\n  Changes$1.setBlocksAtRange.apply(Changes$1, arguments);\n};\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.setInlinesAtRange = function (change, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var inlines = document.getInlinesAtRange(range);\n\n  inlines.forEach(function (inline) {\n    change.setNodeByKey(inline.key, properties, { normalize: normalize });\n  });\n};\n\nChanges$1.setInlineAtRange = function () {\n  logger.deprecate('slate@0.33.0', 'The `setInlineAtRange` method of Slate changes has been renamed to `setInlinesAtRange`.');\n\n  Changes$1.setInlinesAtRange.apply(Changes$1, arguments);\n};\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.splitBlockAtRange = function (change, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var normalize = change.getFlag('normalize', options);\n\n  var _range6 = range,\n      startKey = _range6.startKey,\n      startOffset = _range6.startOffset,\n      endOffset = _range6.endOffset,\n      endKey = _range6.endKey;\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.assertDescendant(startKey);\n  var parent = document.getClosestBlock(node.key);\n  var h = 0;\n\n  while (parent && parent.object == 'block' && h < height) {\n    node = parent;\n    parent = document.getClosestBlock(parent.key);\n    h++;\n  }\n\n  change.splitDescendantsByKey(node.key, startKey, startOffset, {\n    normalize: normalize && range.isCollapsed\n  });\n\n  if (range.isExpanded) {\n    if (range.isBackward) range = range.flip();\n    var nextBlock = change.value.document.getNextBlock(node.key);\n    range = range.moveAnchorToStartOf(nextBlock);\n\n    if (startKey === endKey) {\n      range = range.moveFocusTo(range.anchorKey, endOffset - startOffset);\n    }\n\n    change.deleteAtRange(range, { normalize: normalize });\n  }\n};\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.splitInlineAtRange = function (change, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var normalize = change.getFlag('normalize', options);\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: normalize });\n    range = range.collapseToStart();\n  }\n\n  var _range7 = range,\n      startKey = _range7.startKey,\n      startOffset = _range7.startOffset;\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.assertDescendant(startKey);\n  var parent = document.getClosestInline(node.key);\n  var h = 0;\n\n  while (parent && parent.object == 'inline' && h < height) {\n    node = parent;\n    parent = document.getClosestInline(parent.key);\n    h++;\n  }\n\n  change.splitDescendantsByKey(node.key, startKey, startOffset, { normalize: normalize });\n};\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.toggleMarkAtRange = function (change, range, mark) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (range.isCollapsed) return;\n\n  mark = Mark.create(mark);\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var marks = document.getActiveMarksAtRange(range);\n  var exists = marks.some(function (m) {\n    return m.equals(mark);\n  });\n\n  if (exists) {\n    change.removeMarkAtRange(range, mark, { normalize: normalize });\n  } else {\n    change.addMarkAtRange(range, mark, { normalize: normalize });\n  }\n};\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.unwrapBlockAtRange = function (change, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  properties = Node.createProperties(properties);\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var blocks = document.getBlocksAtRange(range);\n  var wrappers = blocks.map(function (block) {\n    return document.getClosest(block.key, function (parent) {\n      if (parent.object != 'block') return false;\n      if (properties.type != null && parent.type != properties.type) return false;\n      if (properties.isVoid != null && parent.isVoid != properties.isVoid) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n\n  wrappers.forEach(function (block) {\n    var first = block.nodes.first();\n    var last = block.nodes.last();\n    var parent = document.getParent(block.key);\n    var index = parent.nodes.indexOf(block);\n\n    var children = block.nodes.filter(function (child) {\n      return blocks.some(function (b) {\n        return child == b || child.hasDescendant(b.key);\n      });\n    });\n\n    var firstMatch = children.first();\n    var lastMatch = children.last();\n\n    if (first == firstMatch && last == lastMatch) {\n      block.nodes.forEach(function (child, i) {\n        change.moveNodeByKey(child.key, parent.key, index + i, {\n          normalize: false\n        });\n      });\n\n      change.removeNodeByKey(block.key, { normalize: false });\n    } else if (last == lastMatch) {\n      block.nodes.skipUntil(function (n) {\n        return n == firstMatch;\n      }).forEach(function (child, i) {\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false\n        });\n      });\n    } else if (first == firstMatch) {\n      block.nodes.takeUntil(function (n) {\n        return n == lastMatch;\n      }).push(lastMatch).forEach(function (child, i) {\n        change.moveNodeByKey(child.key, parent.key, index + i, {\n          normalize: false\n        });\n      });\n    } else {\n      var firstText = firstMatch.getFirstText();\n\n      change.splitDescendantsByKey(block.key, firstText.key, 0, {\n        normalize: false\n      });\n\n      document = change.value.document;\n\n      children.forEach(function (child, i) {\n        if (i == 0) {\n          var extra = child;\n          child = document.getNextBlock(child.key);\n          change.removeNodeByKey(extra.key, { normalize: false });\n        }\n\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false\n        });\n      });\n    }\n  });\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument();\n  }\n};\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.unwrapInlineAtRange = function (change, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  properties = Node.createProperties(properties);\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var texts = document.getTextsAtRange(range);\n  var inlines = texts.map(function (text) {\n    return document.getClosest(text.key, function (parent) {\n      if (parent.object != 'inline') return false;\n      if (properties.type != null && parent.type != properties.type) return false;\n      if (properties.isVoid != null && parent.isVoid != properties.isVoid) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n\n  inlines.forEach(function (inline) {\n    var parent = change.value.document.getParent(inline.key);\n    var index = parent.nodes.indexOf(inline);\n\n    inline.nodes.forEach(function (child, i) {\n      change.moveNodeByKey(child.key, parent.key, index + i, {\n        normalize: false\n      });\n    });\n  });\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument();\n  }\n};\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|Object|String} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.wrapBlockAtRange = function (change, range, block) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  block = Block.create(block);\n  block = block.set('nodes', block.nodes.clear());\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n\n  var blocks = document.getBlocksAtRange(range);\n  var firstblock = blocks.first();\n  var lastblock = blocks.last();\n  var parent = void 0,\n      siblings = void 0,\n      index = void 0;\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key);\n    siblings = blocks;\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, function (p1) {\n      return !!document.getClosest(lastblock.key, function (p2) {\n        return p1 == p2;\n      });\n    });\n  }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document;\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    var indexes = parent.nodes.reduce(function (ind, node, i) {\n      if (node == firstblock || node.hasDescendant(firstblock.key)) ind[0] = i;\n      if (node == lastblock || node.hasDescendant(lastblock.key)) ind[1] = i;\n      return ind;\n    }, []);\n\n    index = indexes[0];\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1);\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first());\n  }\n\n  // Inject the new block node into the parent.\n  change.insertNodeByKey(parent.key, index, block, { normalize: false });\n\n  // Move the sibling nodes into the new block node.\n  siblings.forEach(function (node, i) {\n    change.moveNodeByKey(node.key, block.key, i, { normalize: false });\n  });\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|Object|String} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.wrapInlineAtRange = function (change, range, inline) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var value = change.value;\n  var document = value.document;\n\n  var normalize = change.getFlag('normalize', options);\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    var inlineParent = document.getClosestInline(startKey);\n\n    if (!inlineParent.isVoid) {\n      return;\n    }\n\n    return change.wrapInlineByKey(inlineParent.key, inline, options);\n  }\n\n  inline = Inline.create(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n\n  var blocks = document.getBlocksAtRange(range);\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(endKey);\n  var startInline = document.getClosestInline(startKey);\n  var endInline = document.getClosestInline(endKey);\n  var startChild = startBlock.getFurthestAncestor(startKey);\n  var endChild = endBlock.getFurthestAncestor(endKey);\n\n  if (!startInline || startInline != endInline) {\n    change.splitDescendantsByKey(endChild.key, endKey, endOffset, {\n      normalize: false\n    });\n\n    change.splitDescendantsByKey(startChild.key, startKey, startOffset, {\n      normalize: false\n    });\n  }\n\n  document = change.value.document;\n  startBlock = document.getDescendant(startBlock.key);\n  endBlock = document.getDescendant(endBlock.key);\n  startChild = startBlock.getFurthestAncestor(startKey);\n  endChild = endBlock.getFurthestAncestor(endKey);\n  var startIndex = startBlock.nodes.indexOf(startChild);\n  var endIndex = endBlock.nodes.indexOf(endChild);\n\n  if (startInline && startInline == endInline) {\n    var text = startBlock.getTextsAtRange(range).get(0).splitText(startOffset)[1].splitText(endOffset - startOffset)[0];\n    inline = inline.set('nodes', immutable.List([text]));\n    Changes$1.insertInlineAtRange(change, range, inline, { normalize: false });\n    var inlinekey = inline.getFirstText().key;\n    var rng = {\n      anchorKey: inlinekey,\n      focusKey: inlinekey,\n      anchorOffset: 0,\n      focusOffset: endOffset - startOffset,\n      isFocused: true\n    };\n    change.select(rng);\n  } else if (startBlock == endBlock) {\n    document = change.value.document;\n    startBlock = document.getClosestBlock(startKey);\n    startChild = startBlock.getFurthestAncestor(startKey);\n\n    var startInner = document.getNextSibling(startChild.key);\n    var startInnerIndex = startBlock.nodes.indexOf(startInner);\n    var endInner = startKey == endKey ? startInner : startBlock.getFurthestAncestor(endKey);\n    var inlines = startBlock.nodes.skipUntil(function (n) {\n      return n == startInner;\n    }).takeUntil(function (n) {\n      return n == endInner;\n    }).push(endInner);\n\n    var node = inline.regenerateKey();\n\n    change.insertNodeByKey(startBlock.key, startInnerIndex, node, {\n      normalize: false\n    });\n\n    inlines.forEach(function (child, i) {\n      change.moveNodeByKey(child.key, node.key, i, { normalize: false });\n    });\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key);\n    }\n  } else {\n    var startInlines = startBlock.nodes.slice(startIndex + 1);\n    var endInlines = endBlock.nodes.slice(0, endIndex + 1);\n    var startNode = inline.regenerateKey();\n    var endNode = inline.regenerateKey();\n\n    change.insertNodeByKey(startBlock.key, startIndex + 1, startNode, {\n      normalize: false\n    });\n\n    change.insertNodeByKey(endBlock.key, endIndex, endNode, {\n      normalize: false\n    });\n\n    startInlines.forEach(function (child, i) {\n      change.moveNodeByKey(child.key, startNode.key, i, { normalize: false });\n    });\n\n    endInlines.forEach(function (child, i) {\n      change.moveNodeByKey(child.key, endNode.key, i, { normalize: false });\n    });\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key).normalizeNodeByKey(endBlock.key);\n    }\n\n    blocks.slice(1, -1).forEach(function (block) {\n      var node = inline.regenerateKey();\n      change.insertNodeByKey(block.key, 0, node, { normalize: false });\n\n      block.nodes.forEach(function (child, i) {\n        change.moveNodeByKey(child.key, node.key, i, { normalize: false });\n      });\n\n      if (normalize) {\n        change.normalizeNodeByKey(block.key);\n      }\n    });\n  }\n};\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.wrapTextAtRange = function (change, range, prefix) {\n  var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prefix;\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  var startKey = range.startKey,\n      endKey = range.endKey;\n\n  var start = range.collapseToStart();\n  var end = range.collapseToEnd();\n\n  if (startKey == endKey) {\n    end = end.move(prefix.length);\n  }\n\n  change.insertTextAtRange(start, prefix, [], { normalize: normalize });\n  change.insertTextAtRange(end, suffix, [], { normalize: normalize });\n};\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes$2 = {};\n\n/**\n * Add mark to text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.addMarkByKey = function (change, key, offset, length, mark) {\n  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n  mark = Mark.create(mark);\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.getPath(key);\n  var node = document.getNode(key);\n  var leaves = node.getLeaves();\n\n  var operations = [];\n  var bx = offset;\n  var by = offset + length;\n  var o = 0;\n\n  leaves.forEach(function (leaf) {\n    var ax = o;\n    var ay = ax + leaf.text.length;\n\n    o += leaf.text.length;\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return;\n\n    // If the leaf already has the mark, continue on.\n    if (leaf.marks.has(mark)) return;\n\n    // Otherwise, determine which offset and characters overlap.\n    var start = Math.max(ax, bx);\n    var end = Math.min(ay, by);\n\n    operations.push({\n      type: 'add_mark',\n      value: value,\n      path: path,\n      offset: start,\n      length: end - start,\n      mark: mark\n    });\n  });\n\n  change.applyOperations(operations);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Insert a `fragment` at `index` in a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} index\n * @param {Fragment} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.insertFragmentByKey = function (change, key, index, fragment) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  var normalize = change.getFlag('normalize', options);\n\n  fragment.nodes.forEach(function (node, i) {\n    change.insertNodeByKey(key, index + i, node);\n  });\n\n  if (normalize) {\n    change.normalizeNodeByKey(key);\n  }\n};\n\n/**\n * Insert a `node` at `index` in a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} index\n * @param {Node} node\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.insertNodeByKey = function (change, key, index, node) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.getPath(key);\n\n  change.applyOperation({\n    type: 'insert_node',\n    value: value,\n    path: [].concat(toConsumableArray(path), [index]),\n    node: node\n  });\n\n  if (normalize) {\n    change.normalizeNodeByKey(key);\n  }\n};\n\n/**\n * Insert `text` at `offset` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.insertTextByKey = function (change, key, offset, text, marks) {\n  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n  var normalize = change.getFlag('normalize', options);\n\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.getPath(key);\n  var node = document.getNode(key);\n  marks = marks || node.getMarksAtIndex(offset);\n\n  change.applyOperation({\n    type: 'insert_text',\n    value: value,\n    path: path,\n    offset: offset,\n    text: text,\n    marks: marks\n  });\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Merge a node by `key` with the previous node.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.mergeNodeByKey = function (change, key) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.getPath(key);\n  var original = document.getDescendant(key);\n  var previous = document.getPreviousSibling(key);\n\n  if (!previous) {\n    throw new Error('Unable to merge node with key \"' + key + '\", no previous key.');\n  }\n\n  var position = previous.object == 'text' ? previous.text.length : previous.nodes.size;\n\n  change.applyOperation({\n    type: 'merge_node',\n    value: value,\n    path: path,\n    position: position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data\n    },\n    target: null\n  });\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Move a node by `key` to a new parent by `newKey` and `index`.\n * `newKey` is the key of the container (it can be the document itself)\n *\n * @param {Change} change\n * @param {String} key\n * @param {String} newKey\n * @param {Number} index\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.moveNodeByKey = function (change, key, newKey, newIndex) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.getPath(key);\n  var newPath = document.getPath(newKey);\n\n  change.applyOperation({\n    type: 'move_node',\n    value: value,\n    path: path,\n    newPath: [].concat(toConsumableArray(newPath), [newIndex])\n  });\n\n  if (normalize) {\n    var parent = document.getCommonAncestor(key, newKey);\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Remove mark from text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.removeMarkByKey = function (change, key, offset, length, mark) {\n  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n  mark = Mark.create(mark);\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.getPath(key);\n  var node = document.getNode(key);\n  var leaves = node.getLeaves();\n\n  var operations = [];\n  var bx = offset;\n  var by = offset + length;\n  var o = 0;\n\n  leaves.forEach(function (leaf) {\n    var ax = o;\n    var ay = ax + leaf.text.length;\n\n    o += leaf.text.length;\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return;\n\n    // If the leaf already has the mark, continue on.\n    if (!leaf.marks.has(mark)) return;\n\n    // Otherwise, determine which offset and characters overlap.\n    var start = Math.max(ax, bx);\n    var end = Math.min(ay, by);\n\n    operations.push({\n      type: 'remove_mark',\n      value: value,\n      path: path,\n      offset: start,\n      length: end - start,\n      mark: mark\n    });\n  });\n\n  change.applyOperations(operations);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Remove all `marks` from node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.removeAllMarksByKey = function (change, key) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var state = change.state;\n  var document = state.document;\n\n  var node = document.getNode(key);\n  var texts = node.object === 'text' ? [node] : node.getTextsAsArray();\n\n  texts.forEach(function (text) {\n    text.getMarksAsArray().forEach(function (mark) {\n      change.removeMarkByKey(text.key, 0, text.text.length, mark, options);\n    });\n  });\n};\n\n/**\n * Remove a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.removeNodeByKey = function (change, key) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.getPath(key);\n  var node = document.getNode(key);\n\n  change.applyOperation({\n    type: 'remove_node',\n    value: value,\n    path: path,\n    node: node\n  });\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Insert `text` at `offset` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.setTextByKey = function (change, key, text, marks) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  var textNode = change.value.document.getDescendant(key);\n  change.replaceTextByKey(key, 0, textNode.text.length, text, marks, options);\n};\n\n/**\n * Replace A Length of Text with another string or text\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n *\n */\n\nChanges$2.replaceTextByKey = function (change, key, offset, length, text, marks, options) {\n  var document = change.value.document;\n\n  var textNode = document.getDescendant(key);\n\n  if (length + offset > textNode.text.length) {\n    length = textNode.text.length - offset;\n  }\n\n  var range = Range.create({\n    anchorKey: key,\n    focusKey: key,\n    anchorOffset: offset,\n    focusOffset: offset + length\n  });\n  var activeMarks = document.getActiveMarksAtRange(range);\n\n  change.removeTextByKey(key, offset, length, { normalize: false });\n\n  if (!marks) {\n    // Do not use mark at index when marks and activeMarks are both empty\n    marks = activeMarks ? activeMarks : [];\n  } else if (activeMarks) {\n    // Do not use `has` because we may want to reset marks like font-size with an updated data;\n    activeMarks = activeMarks.filter(function (activeMark) {\n      return !marks.find(function (m) {\n        return activeMark.type === m.type;\n      });\n    });\n\n    marks = activeMarks.merge(marks);\n  }\n\n  change.insertTextByKey(key, offset, text, marks, options);\n};\n\n/**\n * Remove text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.removeTextByKey = function (change, key, offset, length) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.getPath(key);\n  var node = document.getNode(key);\n  var leaves = node.getLeaves();\n  var text = node.text;\n\n\n  var removals = [];\n  var bx = offset;\n  var by = offset + length;\n  var o = 0;\n\n  leaves.forEach(function (leaf) {\n    var ax = o;\n    var ay = ax + leaf.text.length;\n\n    o += leaf.text.length;\n\n    // If the leaf doesn't overlap with the removal, continue on.\n    if (ay < bx || by < ax) return;\n\n    // Otherwise, determine which offset and characters overlap.\n    var start = Math.max(ax, bx);\n    var end = Math.min(ay, by);\n    var string = text.slice(start, end);\n\n    removals.push({\n      type: 'remove_text',\n      value: value,\n      path: path,\n      offset: start,\n      text: string,\n      marks: leaf.marks\n    });\n  });\n\n  // Apply in reverse order, so subsequent removals don't impact previous ones.\n  change.applyOperations(removals.reverse());\n\n  if (normalize) {\n    var block = document.getClosestBlock(key);\n    change.normalizeNodeByKey(block.key);\n  }\n};\n\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|Node} node\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.replaceNodeByKey = function (change, key, newNode) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  newNode = Node.create(newNode);\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.getNode(key);\n  var parent = document.getParent(key);\n  var index = parent.nodes.indexOf(node);\n  change.removeNodeByKey(key, { normalize: false });\n  change.insertNodeByKey(parent.key, index, newNode, { normalize: false });\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.setMarkByKey = function (change, key, offset, length, mark, properties) {\n  var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n  mark = Mark.create(mark);\n  properties = Mark.createProperties(properties);\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.getPath(key);\n\n  change.applyOperation({\n    type: 'set_mark',\n    value: value,\n    path: path,\n    offset: offset,\n    length: length,\n    mark: mark,\n    properties: properties\n  });\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Set `properties` on a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.setNodeByKey = function (change, key, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  properties = Node.createProperties(properties);\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.getPath(key);\n  var node = document.getNode(key);\n\n  change.applyOperation({\n    type: 'set_node',\n    value: value,\n    path: path,\n    node: node,\n    properties: properties\n  });\n\n  if (normalize) {\n    change.normalizeNodeByKey(node.key);\n  }\n};\n\n/**\n * Split a node by `key` at `position`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} position\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.splitNodeByKey = function (change, key, position) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize = options.normalize,\n      normalize = _options$normalize === undefined ? true : _options$normalize,\n      _options$target = options.target,\n      target = _options$target === undefined ? null : _options$target;\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.getPath(key);\n  var node = document.getDescendantAtPath(path);\n\n  change.applyOperation({\n    type: 'split_node',\n    value: value,\n    path: path,\n    position: position,\n    properties: {\n      type: node.type,\n      data: node.data\n    },\n    target: target\n  });\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Split a node deeply down the tree by `key`, `textKey` and `textOffset`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} position\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.splitDescendantsByKey = function (change, key, textKey, textOffset) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  if (key == textKey) {\n    change.splitNodeByKey(textKey, textOffset, options);\n    return;\n  }\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n\n  var text = document.getNode(textKey);\n  var ancestors = document.getAncestors(textKey);\n  var nodes = ancestors.skipUntil(function (a) {\n    return a.key == key;\n  }).reverse().unshift(text);\n  var previous = void 0;\n  var index = void 0;\n\n  nodes.forEach(function (node) {\n    var prevIndex = index == null ? null : index;\n    index = previous ? node.nodes.indexOf(previous) + 1 : textOffset;\n    previous = node;\n\n    change.splitNodeByKey(node.key, index, {\n      normalize: false,\n      target: prevIndex\n    });\n  });\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.unwrapInlineByKey = function (change, key, properties, options) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var node = document.assertDescendant(key);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOf(first, last);\n  change.unwrapInlineAtRange(range, properties, options);\n};\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.unwrapBlockByKey = function (change, key, properties, options) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var node = document.assertDescendant(key);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOf(first, last);\n  change.unwrapBlockAtRange(range, properties, options);\n};\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.unwrapNodeByKey = function (change, key) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var parent = document.getParent(key);\n  var node = parent.getChild(key);\n\n  var index = parent.nodes.indexOf(node);\n  var isFirst = index === 0;\n  var isLast = index === parent.nodes.size - 1;\n\n  var parentParent = document.getParent(parent.key);\n  var parentIndex = parentParent.nodes.indexOf(parent);\n\n  if (parent.nodes.size === 1) {\n    change.moveNodeByKey(key, parentParent.key, parentIndex, {\n      normalize: false\n    });\n\n    change.removeNodeByKey(parent.key, options);\n  } else if (isFirst) {\n    // Just move the node before its parent.\n    change.moveNodeByKey(key, parentParent.key, parentIndex, options);\n  } else if (isLast) {\n    // Just move the node after its parent.\n    change.moveNodeByKey(key, parentParent.key, parentIndex + 1, options);\n  } else {\n    // Split the parent.\n    change.splitNodeByKey(parent.key, index, { normalize: false });\n\n    // Extract the node in between the splitted parent.\n    change.moveNodeByKey(key, parentParent.key, parentIndex + 1, {\n      normalize: false\n    });\n\n    if (normalize) {\n      change.normalizeNodeByKey(parentParent.key);\n    }\n  }\n};\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Change} change\n * @param {String} key The node to wrap\n * @param {Block|Object|String} block The wrapping block (its children are discarded)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.wrapBlockByKey = function (change, key, block, options) {\n  block = Block.create(block);\n  block = block.set('nodes', block.nodes.clear());\n\n  var document = change.value.document;\n\n  var node = document.assertDescendant(key);\n  var parent = document.getParent(node.key);\n  var index = parent.nodes.indexOf(node);\n\n  change.insertNodeByKey(parent.key, index, block, { normalize: false });\n  change.moveNodeByKey(node.key, block.key, 0, options);\n};\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Change} change\n * @param {String} key The node to wrap\n * @param {Block|Object|String} inline The wrapping inline (its children are discarded)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$2.wrapInlineByKey = function (change, key, inline, options) {\n  inline = Inline.create(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n\n  var document = change.value.document;\n\n  var node = document.assertDescendant(key);\n  var parent = document.getParent(node.key);\n  var index = parent.nodes.indexOf(node);\n\n  change.insertNodeByKey(parent.key, index, inline, { normalize: false });\n  change.moveNodeByKey(node.key, inline.key, 0, options);\n};\n\n/**\n * Wrap a node by `key` with `parent`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Node|Object} parent\n * @param {Object} options\n */\n\nChanges$2.wrapNodeByKey = function (change, key, parent) {\n  parent = Node.create(parent);\n  parent = parent.set('nodes', parent.nodes.clear());\n\n  if (parent.object == 'block') {\n    change.wrapBlockByKey(key, parent);\n    return;\n  }\n\n  if (parent.object == 'inline') {\n    change.wrapInlineByKey(key, parent);\n    return;\n  }\n};\n\n/**\n * Slate operation attributes.\n *\n * @type {Array}\n */\n\nvar OPERATION_ATTRIBUTES = {\n  add_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  insert_node: ['value', 'path', 'node'],\n  insert_text: ['value', 'path', 'offset', 'text', 'marks'],\n  merge_node: ['value', 'path', 'position', 'properties', 'target'],\n  move_node: ['value', 'path', 'newPath'],\n  remove_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  remove_node: ['value', 'path', 'node'],\n  remove_text: ['value', 'path', 'offset', 'text', 'marks'],\n  set_mark: ['value', 'path', 'offset', 'length', 'mark', 'properties'],\n  set_node: ['value', 'path', 'node', 'properties'],\n  set_selection: ['value', 'selection', 'properties'],\n  set_value: ['value', 'properties'],\n  split_node: ['value', 'path', 'position', 'properties', 'target']\n\n  /**\n   * Export.\n   *\n   * @type {Object}\n   */\n\n};\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = Debug('slate:history');\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$8 = {\n  redos: new immutable.Stack(),\n  undos: new immutable.Stack()\n\n  /**\n   * History.\n   *\n   * @type {History}\n   */\n\n};\nvar History = function (_Record) {\n  inherits(History, _Record);\n\n  function History() {\n    classCallCheck(this, History);\n    return possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).apply(this, arguments));\n  }\n\n  createClass(History, [{\n    key: 'save',\n\n\n    /**\n     * Save an `operation` into the history.\n     *\n     * @param {Object} operation\n     * @param {Object} options\n     * @return {History}\n     */\n\n    value: function save(operation) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var history = this;\n      var _history = history,\n          undos = _history.undos,\n          redos = _history.redos;\n      var merge = options.merge,\n          skip = options.skip;\n\n      var prevBatch = undos.peek();\n      var prevOperation = prevBatch && prevBatch.last();\n\n      if (skip == null) {\n        skip = shouldSkip(operation, prevOperation);\n      }\n\n      if (skip) {\n        return history;\n      }\n\n      if (merge == null) {\n        merge = shouldMerge(operation, prevOperation);\n      }\n\n      debug('save', { operation: operation, merge: merge });\n\n      // If the `merge` flag is true, add the operation to the previous batch.\n      if (merge && prevBatch) {\n        var batch = prevBatch.push(operation);\n        undos = undos.pop();\n        undos = undos.push(batch);\n      } else {\n        // Otherwise, create a new batch with the operation.\n        var _batch = new immutable.List([operation]);\n        undos = undos.push(_batch);\n      }\n\n      // Constrain the history to 100 entries for memory's sake.\n      if (undos.size > 100) {\n        undos = undos.take(100);\n      }\n\n      // Clear the redos and update the history.\n      redos = redos.clear();\n      history = history.set('undos', undos).set('redos', redos);\n      return history;\n    }\n\n    /**\n     * Return a JSON representation of the history.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        redos: this.redos.toJSON(),\n        undos: this.undos.toJSON()\n      };\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS() {\n      return this.toJSON();\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'history';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `History` with `attrs`.\n     *\n     * @param {Object|History} attrs\n     * @return {History}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (History.isHistory(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return History.fromJSON(attrs);\n      }\n\n      throw new Error('`History.create` only accepts objects or histories, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `History` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {History}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$redos = object.redos,\n          redos = _object$redos === undefined ? [] : _object$redos,\n          _object$undos = object.undos,\n          undos = _object$undos === undefined ? [] : _object$undos;\n\n\n      var history = new History({\n        redos: new immutable.Stack(redos),\n        undos: new immutable.Stack(undos)\n      });\n\n      return history;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `History`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }]);\n  return History;\n}(immutable.Record(DEFAULTS$8));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nHistory.fromJS = History.fromJSON;\nHistory.isHistory = isType.bind(null, 'HISTORY');\nHistory.prototype[MODEL_TYPES.HISTORY] = true;\n\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldMerge(o, p) {\n  if (!p) return false;\n\n  var merge = o.type == 'set_selection' && p.type == 'set_selection' || o.type == 'insert_text' && p.type == 'insert_text' && o.offset == p.offset + p.text.length && isEqual(o.path, p.path) || o.type == 'remove_text' && p.type == 'remove_text' && o.offset + o.text.length == p.offset && isEqual(o.path, p.path);\n\n  return merge;\n}\n\n/**\n * Check whether to skip a new operation `o`, given previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldSkip(o, p) {\n  if (!p) return false;\n\n  var skip = o.type == 'set_selection' && p.type == 'set_selection';\n\n  return skip;\n}\n\n/**\n * Define the core schema rules, order-sensitive.\n *\n * @type {Array}\n */\n\nvar CORE_SCHEMA_RULES = [\n/**\n * Only allow block nodes in documents.\n *\n * @type {Object}\n */\n\n{\n  validateNode: function validateNode(node) {\n    if (node.object != 'document') return;\n    var invalids = node.nodes.filter(function (n) {\n      return n.object != 'block';\n    });\n    if (!invalids.size) return;\n\n    return function (change) {\n      invalids.forEach(function (child) {\n        change.removeNodeByKey(child.key, { normalize: false });\n      });\n    };\n  }\n},\n\n/**\n * Only allow block nodes or inline and text nodes in blocks.\n *\n * @type {Object}\n */\n\n{\n  validateNode: function validateNode(node) {\n    if (node.object != 'block') return;\n    var first = node.nodes.first();\n    if (!first) return;\n    var objects = first.object == 'block' ? ['block'] : ['inline', 'text'];\n    var invalids = node.nodes.filter(function (n) {\n      return !objects.includes(n.object);\n    });\n    if (!invalids.size) return;\n\n    return function (change) {\n      invalids.forEach(function (child) {\n        change.removeNodeByKey(child.key, { normalize: false });\n      });\n    };\n  }\n},\n\n/**\n * Only allow inline and text nodes in inlines.\n *\n * @type {Object}\n */\n\n{\n  validateNode: function validateNode(node) {\n    if (node.object != 'inline') return;\n    var invalids = node.nodes.filter(function (n) {\n      return n.object != 'inline' && n.object != 'text';\n    });\n    if (!invalids.size) return;\n\n    return function (change) {\n      invalids.forEach(function (child) {\n        change.removeNodeByKey(child.key, { normalize: false });\n      });\n    };\n  }\n},\n\n/**\n * Ensure that block and inline nodes have at least one text child.\n *\n * @type {Object}\n */\n\n{\n  validateNode: function validateNode(node) {\n    if (node.object != 'block' && node.object != 'inline') return;\n    if (node.nodes.size > 0) return;\n\n    return function (change) {\n      var text = Text.create();\n      change.insertNodeByKey(node.key, 0, text, { normalize: false });\n    };\n  }\n},\n\n/**\n * Ensure that inline non-void nodes are never empty.\n *\n * This rule is applied to all blocks and inlines, because when they contain an empty\n * inline, we need to remove the empty inline from that parent node. If `validate`\n * was to be memoized, it should be against the parent node, not the empty inline itself.\n *\n * @type {Object}\n */\n\n{\n  validateNode: function validateNode(node) {\n    if (node.object != 'inline' && node.object != 'block') return;\n\n    var invalids = node.nodes.filter(function (child) {\n      return child.object === 'inline' && child.isEmpty;\n    });\n\n    if (!invalids.size) return;\n\n    return function (change) {\n      // If all of the block's nodes are invalid, insert an empty text node so\n      // that the selection will be preserved when they are all removed.\n      if (node.nodes.size == invalids.size) {\n        var text = Text.create();\n        change.insertNodeByKey(node.key, 1, text, { normalize: false });\n      }\n\n      invalids.forEach(function (child) {\n        change.removeNodeByKey(child.key, { normalize: false });\n      });\n    };\n  }\n},\n\n/**\n * Ensure that inline void nodes are surrounded by text nodes, by adding extra\n * blank text nodes if necessary.\n *\n * @type {Object}\n */\n\n{\n  validateNode: function validateNode(node) {\n    if (node.object != 'block' && node.object != 'inline') return;\n\n    var invalids = node.nodes.reduce(function (list, child, index) {\n      if (child.object !== 'inline') return list;\n\n      var prev = index > 0 ? node.nodes.get(index - 1) : null;\n      var next = node.nodes.get(index + 1);\n\n      // We don't test if \"prev\" is inline, since it has already been\n      // processed in the loop\n      var insertBefore = !prev;\n      var insertAfter = !next || next.object == 'inline';\n\n      if (insertAfter || insertBefore) {\n        list = list.push({ insertAfter: insertAfter, insertBefore: insertBefore, index: index });\n      }\n\n      return list;\n    }, new immutable.List());\n\n    if (!invalids.size) return;\n\n    return function (change) {\n      // Shift for every text node inserted previously.\n      var shift = 0;\n\n      invalids.forEach(function (_ref) {\n        var index = _ref.index,\n            insertAfter = _ref.insertAfter,\n            insertBefore = _ref.insertBefore;\n\n        if (insertBefore) {\n          change.insertNodeByKey(node.key, shift + index, Text.create(), {\n            normalize: false\n          });\n\n          shift++;\n        }\n\n        if (insertAfter) {\n          change.insertNodeByKey(node.key, shift + index + 1, Text.create(), {\n            normalize: false\n          });\n\n          shift++;\n        }\n      });\n    };\n  }\n},\n\n/**\n * Merge adjacent text nodes.\n *\n * @type {Object}\n */\n\n{\n  validateNode: function validateNode(node) {\n    if (node.object != 'block' && node.object != 'inline') return;\n\n    var invalids = node.nodes.map(function (child, i) {\n      var next = node.nodes.get(i + 1);\n      if (child.object != 'text') return;\n      if (!next || next.object != 'text') return;\n      return next;\n    }).filter(Boolean);\n\n    if (!invalids.size) return;\n\n    return function (change) {\n      // Reverse the list to handle consecutive merges, since the earlier nodes\n      // will always exist after each merge.\n      invalids.reverse().forEach(function (n) {\n        change.mergeNodeByKey(n.key, { normalize: false });\n      });\n    };\n  }\n},\n\n/**\n * Prevent extra empty text nodes, except when adjacent to inline void nodes.\n *\n * @type {Object}\n */\n\n{\n  validateNode: function validateNode(node) {\n    if (node.object != 'block' && node.object != 'inline') return;\n    var nodes = node.nodes;\n\n    if (nodes.size <= 1) return;\n\n    var invalids = nodes.filter(function (desc, i) {\n      if (desc.object != 'text') return;\n      if (desc.text.length > 0) return;\n\n      var prev = i > 0 ? nodes.get(i - 1) : null;\n      var next = nodes.get(i + 1);\n\n      // If it's the first node, and the next is a void, preserve it.\n      if (!prev && next.object == 'inline') return;\n\n      // It it's the last node, and the previous is an inline, preserve it.\n      if (!next && prev.object == 'inline') return;\n\n      // If it's surrounded by inlines, preserve it.\n      if (next && prev && next.object == 'inline' && prev.object == 'inline') return;\n\n      // Otherwise, remove it.\n      return true;\n    });\n\n    if (!invalids.size) return;\n\n    return function (change) {\n      invalids.forEach(function (text) {\n        change.removeNodeByKey(text.key, { normalize: false });\n      });\n    };\n  }\n}];\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$9 = {\n  plugins: []\n\n  /**\n   * Stack.\n   *\n   * @type {Stack}\n   */\n\n};\nvar Stack = function (_Record) {\n  inherits(Stack, _Record);\n\n  function Stack() {\n    classCallCheck(this, Stack);\n    return possibleConstructorReturn(this, (Stack.__proto__ || Object.getPrototypeOf(Stack)).apply(this, arguments));\n  }\n\n  createClass(Stack, [{\n    key: 'getPluginsWith',\n\n\n    /**\n     * Get all plugins with `property`.\n     *\n     * @param {String} property\n     * @return {Array}\n     */\n\n    value: function getPluginsWith(property) {\n      return this.plugins.filter(function (plugin) {\n        return plugin[property] != null;\n      });\n    }\n\n    /**\n     * Iterate the plugins with `property`, returning the first non-null value.\n     *\n     * @param {String} property\n     * @param {Any} ...args\n     */\n\n  }, {\n    key: 'find',\n    value: function find(property) {\n      var plugins = this.getPluginsWith(property);\n\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var plugin = _step.value;\n\n          var ret = plugin[property].apply(plugin, args);\n          if (ret != null) return ret;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    /**\n     * Iterate the plugins with `property`, returning all the non-null values.\n     *\n     * @param {String} property\n     * @param {Any} ...args\n     * @return {Array}\n     */\n\n  }, {\n    key: 'map',\n    value: function map(property) {\n      var plugins = this.getPluginsWith(property);\n      var array = [];\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = plugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var plugin = _step2.value;\n\n          var ret = plugin[property].apply(plugin, args);\n          if (ret != null) array.push(ret);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return array;\n    }\n\n    /**\n     * Iterate the plugins with `property`, breaking on any a non-null values.\n     *\n     * @param {String} property\n     * @param {Any} ...args\n     */\n\n  }, {\n    key: 'run',\n    value: function run(property) {\n      var plugins = this.getPluginsWith(property);\n\n      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = plugins[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var plugin = _step3.value;\n\n          var ret = plugin[property].apply(plugin, args);\n          if (ret != null) return;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n\n    /**\n     * Iterate the plugins with `property`, reducing to a set of React children.\n     *\n     * @param {String} property\n     * @param {Object} props\n     * @param {Any} ...args\n     */\n\n  }, {\n    key: 'render',\n    value: function render(property, props) {\n      for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        args[_key4 - 2] = arguments[_key4];\n      }\n\n      var plugins = this.getPluginsWith(property);\n      return plugins.reduceRight(function (children, plugin) {\n        if (!plugin[property]) return children;\n        var ret = plugin[property].apply(plugin, [props].concat(args));\n        if (ret == null) return children;\n        props.children = ret;\n        return ret;\n      }, props.children === undefined ? null : props.children);\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'stack';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Constructor.\n     *\n     * @param {Object} attrs\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _attrs$plugins = attrs.plugins,\n          plugins = _attrs$plugins === undefined ? [] : _attrs$plugins;\n\n      var stack = new Stack({ plugins: plugins });\n      return stack;\n    }\n\n    /**\n     * Check if `any` is a `Stack`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isStack',\n    value: function isStack(any) {\n      return !!(any && any[MODEL_TYPES.STACK]);\n    }\n  }]);\n  return Stack;\n}(immutable.Record(DEFAULTS$9));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nStack.prototype[MODEL_TYPES.STACK] = true;\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Stack.prototype, ['getPluginsWith']);\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$1 = Debug('slate:schema');\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$10 = {\n  stack: Stack.create(),\n  document: {},\n  blocks: {},\n  inlines: {}\n\n  /**\n   * Schema.\n   *\n   * @type {Schema}\n   */\n\n};\nvar Schema = function (_Record) {\n  inherits(Schema, _Record);\n\n  function Schema() {\n    classCallCheck(this, Schema);\n    return possibleConstructorReturn(this, (Schema.__proto__ || Object.getPrototypeOf(Schema)).apply(this, arguments));\n  }\n\n  createClass(Schema, [{\n    key: 'getRule',\n\n\n    /**\n     * Get the rule for an `object`.\n     *\n     * @param {Mixed} object\n     * @return {Object}\n     */\n\n    value: function getRule(object) {\n      switch (object.object) {\n        case 'document':\n          return this.document;\n        case 'block':\n          return this.blocks[object.type];\n        case 'inline':\n          return this.inlines[object.type];\n      }\n    }\n\n    /**\n     * Get a dictionary of the parent rule validations by child type.\n     *\n     * @return {Object|Null}\n     */\n\n  }, {\n    key: 'getParentRules',\n    value: function getParentRules() {\n      var blocks = this.blocks,\n          inlines = this.inlines;\n\n      var parents = {};\n\n      for (var key in blocks) {\n        var rule = blocks[key];\n        if (rule.parent == null) continue;\n        parents[key] = rule;\n      }\n\n      for (var _key in inlines) {\n        var _rule = inlines[_key];\n        if (_rule.parent == null) continue;\n        parents[_key] = _rule;\n      }\n\n      return Object.keys(parents).length == 0 ? null : parents;\n    }\n\n    /**\n     * Fail validation by returning a normalizing change function.\n     *\n     * @param {String} violation\n     * @param {Object} context\n     * @return {Function}\n     */\n\n  }, {\n    key: 'fail',\n    value: function fail(violation, context) {\n      var _this2 = this;\n\n      return function (change) {\n        debug$1('normalizing', { violation: violation, context: context });\n        var rule = context.rule;\n        var size = change.operations.size;\n\n        if (rule.normalize) rule.normalize(change, violation, context);\n        if (change.operations.size > size) return;\n        _this2.normalize(change, violation, context);\n      };\n    }\n\n    /**\n     * Normalize an invalid value with `violation` and `context`.\n     *\n     * @param {Change} change\n     * @param {String} violation\n     * @param {Mixed} context\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(change, violation, context) {\n      switch (violation) {\n        case slateSchemaViolations.CHILD_OBJECT_INVALID:\n        case slateSchemaViolations.CHILD_TYPE_INVALID:\n        case slateSchemaViolations.CHILD_UNKNOWN:\n        case slateSchemaViolations.FIRST_CHILD_OBJECT_INVALID:\n        case slateSchemaViolations.FIRST_CHILD_TYPE_INVALID:\n        case slateSchemaViolations.LAST_CHILD_OBJECT_INVALID:\n        case slateSchemaViolations.LAST_CHILD_TYPE_INVALID:\n          {\n            var child = context.child,\n                node = context.node;\n\n            return child.object == 'text' && node.object == 'block' && node.nodes.size == 1 ? change.removeNodeByKey(node.key) : change.removeNodeByKey(child.key);\n          }\n\n        case slateSchemaViolations.CHILD_REQUIRED:\n        case slateSchemaViolations.NODE_TEXT_INVALID:\n        case slateSchemaViolations.PARENT_OBJECT_INVALID:\n        case slateSchemaViolations.PARENT_TYPE_INVALID:\n          {\n            var _node = context.node;\n\n            return _node.object == 'document' ? _node.nodes.forEach(function (child) {\n              return change.removeNodeByKey(child.key);\n            }) : change.removeNodeByKey(_node.key);\n          }\n\n        case slateSchemaViolations.NODE_DATA_INVALID:\n          {\n            var _node2 = context.node,\n                key = context.key;\n\n            return _node2.data.get(key) === undefined && _node2.object != 'document' ? change.removeNodeByKey(_node2.key) : change.setNodeByKey(_node2.key, { data: _node2.data.delete(key) });\n          }\n\n        case slateSchemaViolations.NODE_IS_VOID_INVALID:\n          {\n            var _node3 = context.node;\n\n            return change.setNodeByKey(_node3.key, { isVoid: !_node3.isVoid });\n          }\n\n        case slateSchemaViolations.NODE_MARK_INVALID:\n          {\n            var _node4 = context.node,\n                mark = context.mark;\n\n            return _node4.getTexts().forEach(function (t) {\n              return change.removeMarkByKey(t.key, 0, t.text.length, mark);\n            });\n          }\n      }\n    }\n\n    /**\n     * Validate a `node` with the schema, returning a function that will fix the\n     * invalid node, or void if the node is valid.\n     *\n     * @param {Node} node\n     * @return {Function|Void}\n     */\n\n  }, {\n    key: 'validateNode',\n    value: function validateNode(node) {\n      var _this3 = this;\n\n      var ret = this.stack.find('validateNode', node);\n      if (ret) return ret;\n\n      if (node.object == 'text') return;\n\n      var rule = this.getRule(node) || {};\n      var parents = this.getParentRules();\n      var ctx = { node: node, rule: rule };\n\n      if (rule.isVoid != null) {\n        if (node.isVoid != rule.isVoid) {\n          return this.fail(slateSchemaViolations.NODE_IS_VOID_INVALID, ctx);\n        }\n      }\n\n      if (rule.data != null) {\n        for (var key in rule.data) {\n          var fn = rule.data[key];\n          var value = node.data.get(key);\n\n          if (!fn(value)) {\n            return this.fail(slateSchemaViolations.NODE_DATA_INVALID, _extends({}, ctx, { key: key, value: value }));\n          }\n        }\n      }\n\n      if (rule.marks != null) {\n        var marks = node.getMarks().toArray();\n\n        var _loop = function _loop(mark) {\n          if (!rule.marks.some(function (def) {\n            return def.type === mark.type;\n          })) {\n            return {\n              v: _this3.fail(slateSchemaViolations.NODE_MARK_INVALID, _extends({}, ctx, { mark: mark }))\n            };\n          }\n        };\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = marks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var mark = _step.value;\n\n            var _ret = _loop(mark);\n\n            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      if (rule.text != null) {\n        var text = node.text;\n\n\n        if (!rule.text.test(text)) {\n          return this.fail(slateSchemaViolations.NODE_TEXT_INVALID, _extends({}, ctx, { text: text }));\n        }\n      }\n\n      if (rule.first != null) {\n        var _rule$first = rule.first,\n            objects = _rule$first.objects,\n            types = _rule$first.types;\n\n        var child = node.nodes.first();\n\n        if (child && objects && !objects.includes(child.object)) {\n          return this.fail(slateSchemaViolations.FIRST_CHILD_OBJECT_INVALID, _extends({}, ctx, { child: child }));\n        }\n\n        if (child && types && !types.includes(child.type)) {\n          return this.fail(slateSchemaViolations.FIRST_CHILD_TYPE_INVALID, _extends({}, ctx, { child: child }));\n        }\n      }\n\n      if (rule.last != null) {\n        var _rule$last = rule.last,\n            _objects = _rule$last.objects,\n            _types = _rule$last.types;\n\n        var _child = node.nodes.last();\n\n        if (_child && _objects && !_objects.includes(_child.object)) {\n          return this.fail(slateSchemaViolations.LAST_CHILD_OBJECT_INVALID, _extends({}, ctx, { child: _child }));\n        }\n\n        if (_child && _types && !_types.includes(_child.type)) {\n          return this.fail(slateSchemaViolations.LAST_CHILD_TYPE_INVALID, _extends({}, ctx, { child: _child }));\n        }\n      }\n\n      if (rule.nodes != null || parents != null) {\n        var nextDef = function nextDef() {\n          offset = offset == null ? null : 0;\n          def = defs.shift();\n          min = def && (def.min == null ? 0 : def.min);\n          max = def && (def.max == null ? Infinity : def.max);\n          return !!def;\n        };\n\n        var nextChild = function nextChild() {\n          index = index == null ? 0 : index + 1;\n          offset = offset == null ? 0 : offset + 1;\n          _child2 = children[index];\n          if (max != null && offset == max) nextDef();\n          return !!_child2;\n        };\n\n        var rewind = function rewind() {\n          offset -= 1;\n          index -= 1;\n        };\n\n        var children = node.nodes.toArray();\n        var defs = rule.nodes != null ? rule.nodes.slice() : [];\n\n        var offset = void 0;\n        var min = void 0;\n        var index = void 0;\n        var def = void 0;\n        var max = void 0;\n        var _child2 = void 0;\n\n        if (rule.nodes != null) {\n          nextDef();\n        }\n\n        while (nextChild()) {\n          if (parents != null && _child2.object != 'text' && _child2.type in parents) {\n            var r = parents[_child2.type];\n\n            if (r.parent.objects != null && !r.parent.objects.includes(node.object)) {\n              return this.fail(slateSchemaViolations.PARENT_OBJECT_INVALID, {\n                node: _child2,\n                parent: node,\n                rule: r\n              });\n            }\n\n            if (r.parent.types != null && !r.parent.types.includes(node.type)) {\n              return this.fail(slateSchemaViolations.PARENT_TYPE_INVALID, {\n                node: _child2,\n                parent: node,\n                rule: r\n              });\n            }\n          }\n\n          if (rule.nodes != null) {\n            if (!def) {\n              return this.fail(slateSchemaViolations.CHILD_UNKNOWN, _extends({}, ctx, { child: _child2, index: index }));\n            }\n\n            if (def.objects != null && !def.objects.includes(_child2.object)) {\n              if (offset >= min && nextDef()) {\n                rewind();\n                continue;\n              }\n              return this.fail(slateSchemaViolations.CHILD_OBJECT_INVALID, _extends({}, ctx, { child: _child2, index: index }));\n            }\n\n            if (def.types != null && !def.types.includes(_child2.type)) {\n              if (offset >= min && nextDef()) {\n                rewind();\n                continue;\n              }\n              return this.fail(slateSchemaViolations.CHILD_TYPE_INVALID, _extends({}, ctx, { child: _child2, index: index }));\n            }\n          }\n        }\n\n        if (rule.nodes != null) {\n          while (min != null) {\n            if (offset < min) {\n              return this.fail(slateSchemaViolations.CHILD_REQUIRED, _extends({}, ctx, { index: index }));\n            }\n\n            nextDef();\n          }\n        }\n      }\n    }\n\n    /**\n     * Return a JSON representation of the schema.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        document: this.document,\n        blocks: this.blocks,\n        inlines: this.inlines\n      };\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS() {\n      return this.toJSON();\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'schema';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Schema` with `attrs`.\n     *\n     * @param {Object|Schema} attrs\n     * @return {Schema}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Schema.isSchema(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Schema.fromJSON(attrs);\n      }\n\n      throw new Error('`Schema.create` only accepts objects or schemas, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Schema` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Schema}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Schema.isSchema(object)) {\n        return object;\n      }\n\n      var plugins = object.plugins;\n\n\n      if (object.rules) {\n        throw new Error('Schemas in Slate have changed! They are no longer accept a `rules` property.');\n      }\n\n      if (object.nodes) {\n        throw new Error('Schemas in Slate have changed! They are no longer accept a `nodes` property.');\n      }\n\n      if (!plugins) {\n        plugins = [{ schema: object }];\n      }\n\n      var schema = resolveSchema(plugins);\n      var stack = Stack.create({ plugins: [].concat(toConsumableArray(CORE_SCHEMA_RULES), toConsumableArray(plugins)) });\n      var ret = new Schema(_extends({}, schema, { stack: stack }));\n      return ret;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }, {\n    key: 'isSchema',\n\n\n    /**\n     * Check if `any` is a `Schema`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isSchema(any) {\n      return !!(any && any[MODEL_TYPES.SCHEMA]);\n    }\n  }]);\n  return Schema;\n}(immutable.Record(DEFAULTS$10));\n\n/**\n * Resolve a set of schema rules from an array of `plugins`.\n *\n * @param {Array} plugins\n * @return {Object}\n */\n\nSchema.fromJS = Schema.fromJSON;\nfunction resolveSchema() {\n  var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var schema = {\n    document: {},\n    blocks: {},\n    inlines: {}\n  };\n\n  plugins.slice().reverse().forEach(function (plugin) {\n    if (!plugin.schema) return;\n\n    if (plugin.schema.rules) {\n      throw new Error('Schemas in Slate have changed! They are no longer accept a `rules` property.');\n    }\n\n    if (plugin.schema.nodes) {\n      throw new Error('Schemas in Slate have changed! They are no longer accept a `nodes` property.');\n    }\n\n    var _plugin$schema = plugin.schema,\n        _plugin$schema$docume = _plugin$schema.document,\n        document = _plugin$schema$docume === undefined ? {} : _plugin$schema$docume,\n        _plugin$schema$blocks = _plugin$schema.blocks,\n        blocks = _plugin$schema$blocks === undefined ? {} : _plugin$schema$blocks,\n        _plugin$schema$inline = _plugin$schema.inlines,\n        inlines = _plugin$schema$inline === undefined ? {} : _plugin$schema$inline;\n\n    var d = resolveDocumentRule(document);\n    var bs = {};\n    var is = {};\n\n    for (var key in blocks) {\n      bs[key] = resolveNodeRule('block', key, blocks[key]);\n    }\n\n    for (var _key2 in inlines) {\n      is[_key2] = resolveNodeRule('inline', _key2, inlines[_key2]);\n    }\n\n    mergeWith(schema.document, d, customizer);\n    mergeWith(schema.blocks, bs, customizer);\n    mergeWith(schema.inlines, is, customizer);\n  });\n\n  return schema;\n}\n\n/**\n * Resolve a document rule `obj`.\n *\n * @param {Object} obj\n * @return {Object}\n */\n\nfunction resolveDocumentRule(obj) {\n  return _extends({\n    data: {},\n    nodes: null\n  }, obj);\n}\n\n/**\n * Resolve a node rule with `type` from `obj`.\n *\n * @param {String} object\n * @param {String} type\n * @param {Object} obj\n * @return {Object}\n */\n\nfunction resolveNodeRule(object, type, obj) {\n  return _extends({\n    data: {},\n    isVoid: null,\n    nodes: null,\n    first: null,\n    last: null,\n    parent: null,\n    text: null\n  }, obj);\n}\n\n/**\n * A Lodash customizer for merging schema definitions. Special cases `objects`,\n * `marks` and `types` arrays to be unioned, and ignores new `null` values.\n *\n * @param {Mixed} target\n * @param {Mixed} source\n * @return {Array|Void}\n */\n\nfunction customizer(target, source, key) {\n  if (key == 'objects' || key == 'types' || key == 'marks') {\n    return target == null ? source : target.concat(source);\n  } else {\n    return source == null ? target : source;\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nSchema.prototype[MODEL_TYPES.SCHEMA] = true;\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Schema.prototype, ['getParentRules']);\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$11 = {\n  data: new immutable.Map(),\n  decorations: null,\n  document: Document.create(),\n  history: History.create(),\n  schema: Schema.create(),\n  selection: Range.create()\n\n  /**\n   * Value.\n   *\n   * @type {Value}\n   */\n\n};\nvar Value = function (_Record) {\n  inherits(Value, _Record);\n\n  function Value() {\n    classCallCheck(this, Value);\n    return possibleConstructorReturn(this, (Value.__proto__ || Object.getPrototypeOf(Value)).apply(this, arguments));\n  }\n\n  createClass(Value, [{\n    key: 'change',\n\n\n    /**\n     * Create a new `Change` with the current value as a starting point.\n     *\n     * @param {Object} attrs\n     * @return {Change}\n     */\n\n    value: function change() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return new Change(_extends({}, attrs, { value: this }));\n    }\n\n    /**\n     * Return a JSON representation of the value.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        document: this.document.toJSON(options)\n      };\n\n      if (options.preserveData) {\n        object.data = this.data.toJSON();\n      }\n\n      if (options.preserveDecorations) {\n        object.decorations = this.decorations ? this.decorations.toArray().map(function (d) {\n          return d.toJSON();\n        }) : null;\n      }\n\n      if (options.preserveHistory) {\n        object.history = this.history.toJSON();\n      }\n\n      if (options.preserveSelection) {\n        object.selection = this.selection.toJSON();\n      }\n\n      if (options.preserveSchema) {\n        object.schema = this.schema.toJSON();\n      }\n\n      if (options.preserveSelection && !options.preserveKeys) {\n        var document = this.document,\n            selection = this.selection;\n\n\n        object.selection.anchorPath = selection.isSet ? document.getPath(selection.anchorKey) : null;\n\n        object.selection.focusPath = selection.isSet ? document.getPath(selection.focusKey) : null;\n\n        delete object.selection.anchorKey;\n        delete object.selection.focusKey;\n      }\n\n      if (options.preserveDecorations && object.decorations && !options.preserveKeys) {\n        var _document = this.document;\n\n\n        object.decorations = object.decorations.map(function (decoration) {\n          var withPath = _extends({}, decoration, {\n            anchorPath: _document.getPath(decoration.anchorKey),\n            focusPath: _document.getPath(decoration.focusKey)\n          });\n          delete withPath.anchorKey;\n          delete withPath.focusKey;\n          return withPath;\n        });\n      }\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS(options) {\n      return this.toJSON(options);\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'value';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n\n    /**\n     * Are there undoable events?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasUndos',\n    get: function get$$1() {\n      return this.history.undos.size > 0;\n    }\n\n    /**\n     * Are there redoable events?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasRedos',\n    get: function get$$1() {\n      return this.history.redos.size > 0;\n    }\n\n    /**\n     * Is the current selection blurred?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlurred',\n    get: function get$$1() {\n      return this.selection.isBlurred;\n    }\n\n    /**\n     * Is the current selection focused?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isFocused',\n    get: function get$$1() {\n      return this.selection.isFocused;\n    }\n\n    /**\n     * Is the current selection collapsed?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCollapsed',\n    get: function get$$1() {\n      return this.selection.isCollapsed;\n    }\n\n    /**\n     * Is the current selection expanded?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isExpanded',\n    get: function get$$1() {\n      return this.selection.isExpanded;\n    }\n\n    /**\n     * Is the current selection backward?\n     *\n     * @return {Boolean} isBackward\n     */\n\n  }, {\n    key: 'isBackward',\n    get: function get$$1() {\n      return this.selection.isBackward;\n    }\n\n    /**\n     * Is the current selection forward?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isForward',\n    get: function get$$1() {\n      return this.selection.isForward;\n    }\n\n    /**\n     * Get the current start key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startKey',\n    get: function get$$1() {\n      return this.selection.startKey;\n    }\n\n    /**\n     * Get the current end key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endKey',\n    get: function get$$1() {\n      return this.selection.endKey;\n    }\n\n    /**\n     * Get the current start offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startOffset',\n    get: function get$$1() {\n      return this.selection.startOffset;\n    }\n\n    /**\n     * Get the current end offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endOffset',\n    get: function get$$1() {\n      return this.selection.endOffset;\n    }\n\n    /**\n     * Get the current anchor key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'anchorKey',\n    get: function get$$1() {\n      return this.selection.anchorKey;\n    }\n\n    /**\n     * Get the current focus key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'focusKey',\n    get: function get$$1() {\n      return this.selection.focusKey;\n    }\n\n    /**\n     * Get the current anchor offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'anchorOffset',\n    get: function get$$1() {\n      return this.selection.anchorOffset;\n    }\n\n    /**\n     * Get the current focus offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'focusOffset',\n    get: function get$$1() {\n      return this.selection.focusOffset;\n    }\n\n    /**\n     * Get the current start text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'startBlock',\n    get: function get$$1() {\n      return this.startKey && this.document.getClosestBlock(this.startKey);\n    }\n\n    /**\n     * Get the current end text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'endBlock',\n    get: function get$$1() {\n      return this.endKey && this.document.getClosestBlock(this.endKey);\n    }\n\n    /**\n     * Get the current anchor text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'anchorBlock',\n    get: function get$$1() {\n      return this.anchorKey && this.document.getClosestBlock(this.anchorKey);\n    }\n\n    /**\n     * Get the current focus text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'focusBlock',\n    get: function get$$1() {\n      return this.focusKey && this.document.getClosestBlock(this.focusKey);\n    }\n\n    /**\n     * Get the current start text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'startInline',\n    get: function get$$1() {\n      return this.startKey && this.document.getClosestInline(this.startKey);\n    }\n\n    /**\n     * Get the current end text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'endInline',\n    get: function get$$1() {\n      return this.endKey && this.document.getClosestInline(this.endKey);\n    }\n\n    /**\n     * Get the current anchor text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'anchorInline',\n    get: function get$$1() {\n      return this.anchorKey && this.document.getClosestInline(this.anchorKey);\n    }\n\n    /**\n     * Get the current focus text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'focusInline',\n    get: function get$$1() {\n      return this.focusKey && this.document.getClosestInline(this.focusKey);\n    }\n\n    /**\n     * Get the current start text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'startText',\n    get: function get$$1() {\n      return this.startKey && this.document.getDescendant(this.startKey);\n    }\n\n    /**\n     * Get the current end node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'endText',\n    get: function get$$1() {\n      return this.endKey && this.document.getDescendant(this.endKey);\n    }\n\n    /**\n     * Get the current anchor node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'anchorText',\n    get: function get$$1() {\n      return this.anchorKey && this.document.getDescendant(this.anchorKey);\n    }\n\n    /**\n     * Get the current focus node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'focusText',\n    get: function get$$1() {\n      return this.focusKey && this.document.getDescendant(this.focusKey);\n    }\n\n    /**\n     * Get the next block node.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'nextBlock',\n    get: function get$$1() {\n      return this.endKey && this.document.getNextBlock(this.endKey);\n    }\n\n    /**\n     * Get the previous block node.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'previousBlock',\n    get: function get$$1() {\n      return this.startKey && this.document.getPreviousBlock(this.startKey);\n    }\n\n    /**\n     * Get the next inline node.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'nextInline',\n    get: function get$$1() {\n      return this.endKey && this.document.getNextInline(this.endKey);\n    }\n\n    /**\n     * Get the previous inline node.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'previousInline',\n    get: function get$$1() {\n      return this.startKey && this.document.getPreviousInline(this.startKey);\n    }\n\n    /**\n     * Get the next text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'nextText',\n    get: function get$$1() {\n      return this.endKey && this.document.getNextText(this.endKey);\n    }\n\n    /**\n     * Get the previous text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'previousText',\n    get: function get$$1() {\n      return this.startKey && this.document.getPreviousText(this.startKey);\n    }\n\n    /**\n     * Get the characters in the current selection.\n     *\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'characters',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.List() : this.document.getCharactersAtRange(this.selection);\n    }\n\n    /**\n     * Get the marks of the current selection.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'marks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.Set() : this.selection.marks || this.document.getMarksAtRange(this.selection);\n    }\n\n    /**\n     * Get the active marks of the current selection.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'activeMarks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.Set() : this.selection.marks || this.document.getActiveMarksAtRange(this.selection);\n    }\n\n    /**\n     * Get the block nodes in the current selection.\n     *\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'blocks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.List() : this.document.getBlocksAtRange(this.selection);\n    }\n\n    /**\n     * Get the fragment of the current selection.\n     *\n     * @return {Document}\n     */\n\n  }, {\n    key: 'fragment',\n    get: function get$$1() {\n      return this.selection.isUnset ? Document.create() : this.document.getFragmentAtRange(this.selection);\n    }\n\n    /**\n     * Get the inline nodes in the current selection.\n     *\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'inlines',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.List() : this.document.getInlinesAtRange(this.selection);\n    }\n\n    /**\n     * Get the text nodes in the current selection.\n     *\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'texts',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.List() : this.document.getTextsAtRange(this.selection);\n    }\n\n    /**\n     * Check whether the selection is empty.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get$$1() {\n      if (this.isCollapsed) return true;\n      if (this.endOffset != 0 && this.startOffset != 0) return false;\n      return this.fragment.isEmpty;\n    }\n\n    /**\n     * Check whether the selection is collapsed in a void node.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInVoid',\n    get: function get$$1() {\n      if (this.isExpanded) return false;\n      return this.document.hasVoidParent(this.startKey);\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Value` with `attrs`.\n     *\n     * @param {Object|Value} attrs\n     * @param {Object} options\n     * @return {Value}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (Value.isValue(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Value.fromJSON(attrs, options);\n      }\n\n      throw new Error('`Value.create` only accepts objects or values, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a dictionary of settable value properties from `attrs`.\n     *\n     * @param {Object|Value} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Value.isValue(attrs)) {\n        return {\n          data: attrs.data,\n          decorations: attrs.decorations,\n          schema: attrs.schema\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        var props = {};\n        if ('data' in attrs) props.data = Data.create(attrs.data);\n        if ('decorations' in attrs) props.decorations = Range.createList(attrs.decorations);\n        if ('schema' in attrs) props.schema = Schema.create(attrs.schema);\n        return props;\n      }\n\n      throw new Error('`Value.createProperties` only accepts objects or values, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Value` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @param {Object} options\n     *   @property {Boolean} normalize\n     *   @property {Array} plugins\n     * @return {Value}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _object$document = object.document,\n          document = _object$document === undefined ? {} : _object$document,\n          _object$selection = object.selection,\n          selection = _object$selection === undefined ? {} : _object$selection,\n          _object$schema = object.schema,\n          schema = _object$schema === undefined ? {} : _object$schema;\n\n\n      var data = new immutable.Map();\n\n      document = Document.fromJSON(document);\n\n      // rebuild selection from anchorPath and focusPath if keys were dropped\n      var _selection = selection,\n          anchorPath = _selection.anchorPath,\n          focusPath = _selection.focusPath,\n          anchorKey = _selection.anchorKey,\n          focusKey = _selection.focusKey;\n\n\n      if (anchorPath !== undefined && anchorKey === undefined) {\n        selection.anchorKey = document.assertPath(anchorPath).key;\n      }\n\n      if (focusPath !== undefined && focusKey === undefined) {\n        selection.focusKey = document.assertPath(focusPath).key;\n      }\n\n      selection = Range.fromJSON(selection);\n      schema = Schema.fromJSON(schema);\n\n      // Allow plugins to set a default value for `data`.\n      if (options.plugins) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = options.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var plugin = _step.value;\n\n            if (plugin.data) data = data.merge(plugin.data);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      // Then merge in the `data` provided.\n      if ('data' in object) {\n        data = data.merge(object.data);\n      }\n\n      if (selection.isUnset) {\n        var text = document.getFirstText();\n        if (text) selection = selection.collapseToStartOf(text);\n      }\n\n      var value = new Value({\n        data: data,\n        document: document,\n        selection: selection,\n        schema: schema\n      });\n\n      if (options.normalize !== false) {\n        value = value.change({ save: false }).normalize().value;\n      }\n\n      return value;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }, {\n    key: 'isValue',\n\n\n    /**\n     * Check if a `value` is a `Value`.\n     *\n     * @param {Any} value\n     * @return {Boolean}\n     */\n\n    value: function isValue(value) {\n      return !!(value && value[MODEL_TYPES.VALUE]);\n    }\n  }]);\n  return Value;\n}(immutable.Record(DEFAULTS$11));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nValue.fromJS = Value.fromJSON;\nValue.prototype[MODEL_TYPES.VALUE] = true;\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$12 = {\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  selection: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined,\n  value: undefined\n\n  /**\n   * Operation.\n   *\n   * @type {Operation}\n   */\n\n};\nvar Operation = function (_Record) {\n  inherits(Operation, _Record);\n\n  function Operation() {\n    classCallCheck(this, Operation);\n    return possibleConstructorReturn(this, (Operation.__proto__ || Object.getPrototypeOf(Operation)).apply(this, arguments));\n  }\n\n  createClass(Operation, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the operation.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var object = this.object,\n          type = this.type;\n\n      var json = { object: object, type: type };\n      var ATTRIBUTES = OPERATION_ATTRIBUTES[type];\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = ATTRIBUTES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n\n          var value = this[key];\n\n          // Skip keys for objects that should not be serialized, and are only used\n          // for providing the local-only invert behavior for the history stack.\n          if (key == 'document') continue;\n          if (key == 'selection') continue;\n          if (key == 'value') continue;\n          if (key == 'node' && type != 'insert_node') continue;\n\n          if (key == 'mark' || key == 'marks' || key == 'node') {\n            value = value.toJSON();\n          }\n\n          if (key == 'properties' && type == 'merge_node') {\n            var v = {};\n            if ('data' in value) v.data = value.data.toJS();\n            if ('type' in value) v.type = value.type;\n            value = v;\n          }\n\n          if (key == 'properties' && type == 'set_mark') {\n            var _v = {};\n            if ('data' in value) _v.data = value.data.toJS();\n            if ('type' in value) _v.type = value.type;\n            value = _v;\n          }\n\n          if (key == 'properties' && type == 'set_node') {\n            var _v2 = {};\n            if ('data' in value) _v2.data = value.data.toJS();\n            if ('isVoid' in value) _v2.isVoid = value.isVoid;\n            if ('type' in value) _v2.type = value.type;\n            value = _v2;\n          }\n\n          if (key == 'properties' && type == 'set_selection') {\n            var _v3 = {};\n            if ('anchorOffset' in value) _v3.anchorOffset = value.anchorOffset;\n            if ('anchorPath' in value) _v3.anchorPath = value.anchorPath;\n            if ('focusOffset' in value) _v3.focusOffset = value.focusOffset;\n            if ('focusPath' in value) _v3.focusPath = value.focusPath;\n            if ('isBackward' in value) _v3.isBackward = value.isBackward;\n            if ('isFocused' in value) _v3.isFocused = value.isFocused;\n            if ('marks' in value) _v3.marks = value.marks == null ? null : value.marks.toJSON();\n            value = _v3;\n          }\n\n          if (key == 'properties' && type == 'set_value') {\n            var _v4 = {};\n            if ('data' in value) _v4.data = value.data.toJS();\n            if ('decorations' in value) _v4.decorations = value.decorations.toJS();\n            if ('schema' in value) _v4.schema = value.schema.toJS();\n            value = _v4;\n          }\n\n          if (key == 'properties' && type == 'split_node') {\n            var _v5 = {};\n            if ('data' in value) _v5.data = value.data.toJS();\n            if ('type' in value) _v5.type = value.type;\n            value = _v5;\n          }\n\n          json[key] = value;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return json;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS(options) {\n      return this.toJSON(options);\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'operation';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Operation` with `attrs`.\n     *\n     * @param {Object|Array|List|String|Operation} attrs\n     * @return {Operation}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Operation.isOperation(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Operation.fromJSON(attrs);\n      }\n\n      throw new Error('`Operation.create` only accepts objects or operations, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Operations` from `elements`.\n     *\n     * @param {Array<Operation|Object>|List<Operation|Object>} elements\n     * @return {List<Operation>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Operation.create));\n        return list;\n      }\n\n      throw new Error('`Operation.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a `Operation` from a JSON `object`.\n     *\n     * @param {Object|Operation} object\n     * @return {Operation}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Operation.isOperation(object)) {\n        return object;\n      }\n\n      var type = object.type,\n          value = object.value;\n\n      var ATTRIBUTES = OPERATION_ATTRIBUTES[type];\n      var attrs = { type: type };\n\n      if (!ATTRIBUTES) {\n        throw new Error('`Operation.fromJSON` was passed an unrecognized operation type: \"' + type + '\"');\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = ATTRIBUTES[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var key = _step2.value;\n\n          var v = object[key];\n\n          if (v === undefined) {\n            // Skip keys for objects that should not be serialized, and are only used\n            // for providing the local-only invert behavior for the history stack.\n            if (key == 'document') continue;\n            if (key == 'selection') continue;\n            if (key == 'value') continue;\n            if (key == 'node' && type != 'insert_node') continue;\n\n            throw new Error('`Operation.fromJSON` was passed a \"' + type + '\" operation without the required \"' + key + '\" attribute.');\n          }\n\n          if (key == 'mark') {\n            v = Mark.create(v);\n          }\n\n          if (key == 'marks' && v != null) {\n            v = Mark.createSet(v);\n          }\n\n          if (key == 'node') {\n            v = Node.create(v);\n          }\n\n          if (key == 'selection') {\n            v = Range.create(v);\n          }\n\n          if (key == 'value') {\n            v = Value.create(v);\n          }\n\n          if (key == 'properties' && type == 'merge_node') {\n            v = Node.createProperties(v);\n          }\n\n          if (key == 'properties' && type == 'set_mark') {\n            v = Mark.createProperties(v);\n          }\n\n          if (key == 'properties' && type == 'set_node') {\n            v = Node.createProperties(v);\n          }\n\n          if (key == 'properties' && type == 'set_selection') {\n            var _v6 = v,\n                anchorKey = _v6.anchorKey,\n                focusKey = _v6.focusKey,\n                rest = objectWithoutProperties(_v6, ['anchorKey', 'focusKey']);\n\n            v = Range.createProperties(rest);\n\n            if (anchorKey !== undefined) {\n              v.anchorPath = anchorKey === null ? null : value.document.getPath(anchorKey);\n            }\n\n            if (focusKey !== undefined) {\n              v.focusPath = focusKey === null ? null : value.document.getPath(focusKey);\n            }\n          }\n\n          if (key == 'properties' && type == 'set_value') {\n            v = Value.createProperties(v);\n          }\n\n          if (key == 'properties' && type == 'split_node') {\n            v = Node.createProperties(v);\n          }\n\n          attrs[key] = v;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var node = new Operation(attrs);\n      return node;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }, {\n    key: 'isOperation',\n\n\n    /**\n     * Check if `any` is a `Operation`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isOperation(any) {\n      return !!(any && any[MODEL_TYPES.OPERATION]);\n    }\n\n    /**\n     * Check if `any` is a list\u00a0of operations.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isOperationList',\n    value: function isOperationList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Operation.isOperation(item);\n      });\n    }\n  }]);\n  return Operation;\n}(immutable.Record(DEFAULTS$12));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nOperation.fromJS = Operation.fromJSON;\nOperation.prototype[MODEL_TYPES.OPERATION] = true;\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$2 = Debug('slate:operation:invert');\n\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op);\n  var _op = op,\n      type = _op.type;\n\n  debug$2(type, op);\n\n  /**\n   * Insert node.\n   */\n\n  if (type == 'insert_node') {\n    var inverse = op.set('type', 'remove_node');\n    return inverse;\n  }\n\n  /**\n   * Remove node.\n   */\n\n  if (type == 'remove_node') {\n    var _inverse = op.set('type', 'insert_node');\n    return _inverse;\n  }\n\n  /**\n   * Move node.\n   */\n\n  if (type == 'move_node') {\n    var _op2 = op,\n        newPath = _op2.newPath,\n        path = _op2.path;\n\n    var inversePath = newPath;\n    var inverseNewPath = path;\n\n    var pathLast = path.length - 1;\n    var newPathLast = newPath.length - 1;\n\n    // If the node's old position was a left sibling of an ancestor of\n    // its new position, we need to adjust part of the path by -1.\n    if (path.length < inversePath.length && path.slice(0, pathLast).every(function (e, i) {\n      return e == inversePath[i];\n    }) && path[pathLast] < inversePath[pathLast]) {\n      inversePath = inversePath.slice(0, pathLast).concat([inversePath[pathLast] - 1]).concat(inversePath.slice(pathLast + 1, inversePath.length));\n    }\n\n    // If the node's new position is an ancestor of the old position,\n    // or a left sibling of an ancestor of its old position, we need\n    // to adjust part of the path by 1.\n    if (newPath.length < inverseNewPath.length && newPath.slice(0, newPathLast).every(function (e, i) {\n      return e == inverseNewPath[i];\n    }) && newPath[newPathLast] <= inverseNewPath[newPathLast]) {\n      inverseNewPath = inverseNewPath.slice(0, newPathLast).concat([inverseNewPath[newPathLast] + 1]).concat(inverseNewPath.slice(newPathLast + 1, inverseNewPath.length));\n    }\n\n    var _inverse2 = op.set('path', inversePath).set('newPath', inverseNewPath);\n    return _inverse2;\n  }\n\n  /**\n   * Merge node.\n   */\n\n  if (type == 'merge_node') {\n    var _op3 = op,\n        _path = _op3.path;\n    var length = _path.length;\n\n    var last = length - 1;\n    var _inversePath = _path.slice(0, last).concat([_path[last] - 1]);\n    var _inverse3 = op.set('type', 'split_node').set('path', _inversePath);\n    return _inverse3;\n  }\n\n  /**\n   * Split node.\n   */\n\n  if (type == 'split_node') {\n    var _op4 = op,\n        _path2 = _op4.path;\n    var _length = _path2.length;\n\n    var _last = _length - 1;\n    var _inversePath2 = _path2.slice(0, _last).concat([_path2[_last] + 1]);\n    var _inverse4 = op.set('type', 'merge_node').set('path', _inversePath2);\n    return _inverse4;\n  }\n\n  /**\n   * Set node.\n   */\n\n  if (type == 'set_node') {\n    var _op5 = op,\n        properties = _op5.properties,\n        node = _op5.node;\n\n    var inverseNode = node.merge(properties);\n    var inverseProperties = pick(node, Object.keys(properties));\n    var _inverse5 = op.set('node', inverseNode).set('properties', inverseProperties);\n    return _inverse5;\n  }\n\n  /**\n   * Insert text.\n   */\n\n  if (type == 'insert_text') {\n    var _inverse6 = op.set('type', 'remove_text');\n    return _inverse6;\n  }\n\n  /**\n   * Remove text.\n   */\n\n  if (type == 'remove_text') {\n    var _inverse7 = op.set('type', 'insert_text');\n    return _inverse7;\n  }\n\n  /**\n   * Add mark.\n   */\n\n  if (type == 'add_mark') {\n    var _inverse8 = op.set('type', 'remove_mark');\n    return _inverse8;\n  }\n\n  /**\n   * Remove mark.\n   */\n\n  if (type == 'remove_mark') {\n    var _inverse9 = op.set('type', 'add_mark');\n    return _inverse9;\n  }\n\n  /**\n   * Set mark.\n   */\n\n  if (type == 'set_mark') {\n    var _op6 = op,\n        _properties = _op6.properties,\n        mark = _op6.mark;\n\n    var inverseMark = mark.merge(_properties);\n    var _inverseProperties = pick(mark, Object.keys(_properties));\n    var _inverse10 = op.set('mark', inverseMark).set('properties', _inverseProperties);\n    return _inverse10;\n  }\n\n  /**\n   * Set selection.\n   */\n\n  if (type == 'set_selection') {\n    var _op7 = op,\n        _properties2 = _op7.properties,\n        selection = _op7.selection,\n        value = _op7.value;\n    var anchorPath = _properties2.anchorPath,\n        focusPath = _properties2.focusPath,\n        props = objectWithoutProperties(_properties2, ['anchorPath', 'focusPath']);\n    var document = value.document;\n\n\n    if (anchorPath !== undefined) {\n      props.anchorKey = anchorPath === null ? null : document.assertPath(anchorPath).key;\n    }\n\n    if (focusPath !== undefined) {\n      props.focusKey = focusPath === null ? null : document.assertPath(focusPath).key;\n    }\n\n    var inverseSelection = selection.merge(props);\n    var inverseProps = pick(selection, Object.keys(props));\n\n    if (anchorPath !== undefined) {\n      inverseProps.anchorPath = inverseProps.anchorKey === null ? null : document.getPath(inverseProps.anchorKey);\n\n      delete inverseProps.anchorKey;\n    }\n\n    if (focusPath !== undefined) {\n      inverseProps.focusPath = inverseProps.focusKey === null ? null : document.getPath(inverseProps.focusKey);\n\n      delete inverseProps.focusKey;\n    }\n\n    var _inverse11 = op.set('selection', inverseSelection).set('properties', inverseProps);\n    return _inverse11;\n  }\n\n  /**\n   * Set value.\n   */\n\n  if (type == 'set_value') {\n    var _op8 = op,\n        _properties3 = _op8.properties,\n        _value = _op8.value;\n\n    var inverseValue = _value.merge(_properties3);\n    var _inverseProperties2 = pick(_value, Object.keys(_properties3));\n    var _inverse12 = op.set('value', inverseValue).set('properties', _inverseProperties2);\n    return _inverse12;\n  }\n}\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes$3 = {};\n\n/**\n * Redo to the next value in the history.\n *\n * @param {Change} change\n */\n\nChanges$3.redo = function (change) {\n  var value = change.value;\n  var _value = value,\n      history = _value.history;\n\n  if (!history) return;\n\n  var _history = history,\n      undos = _history.undos,\n      redos = _history.redos;\n\n  var next = redos.peek();\n  if (!next) return;\n\n  // Shift the next value into the undo stack.\n  redos = redos.pop();\n  undos = undos.push(next);\n\n  // Replay the next operations.\n  next.forEach(function (op) {\n    var _op = op,\n        type = _op.type,\n        properties = _op.properties;\n\n    // When the operation mutates the selection, omit its `isFocused` value to\n    // prevent the editor focus from changing during redoing.\n\n    if (type == 'set_selection') {\n      op = op.set('properties', omit(properties, 'isFocused'));\n    }\n\n    change.applyOperation(op, { save: false });\n  });\n\n  // Update the history.\n  value = change.value;\n  history = history.set('undos', undos).set('redos', redos);\n  value = value.set('history', history);\n  change.value = value;\n};\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Change} change\n */\n\nChanges$3.undo = function (change) {\n  var value = change.value;\n  var _value2 = value,\n      history = _value2.history;\n\n  if (!history) return;\n\n  var _history2 = history,\n      undos = _history2.undos,\n      redos = _history2.redos;\n\n  var previous = undos.peek();\n  if (!previous) return;\n\n  // Shift the previous operations into the redo stack.\n  undos = undos.pop();\n  redos = redos.push(previous);\n\n  // Replay the inverse of the previous operations.\n  previous.slice().reverse().map(invertOperation).forEach(function (inverse) {\n    var _inverse = inverse,\n        type = _inverse.type,\n        properties = _inverse.properties;\n\n    // When the operation mutates the selection, omit its `isFocused` value to\n    // prevent the editor focus from changing during undoing.\n\n    if (type == 'set_selection') {\n      inverse = inverse.set('properties', omit(properties, 'isFocused'));\n    }\n\n    change.applyOperation(inverse, { save: false });\n  });\n\n  // Update the history.\n  value = change.value;\n  history = history.set('undos', undos).set('redos', redos);\n  value = value.set('history', history);\n  change.value = value;\n};\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes$4 = {};\n\n/**\n * Set `properties` on the selection.\n *\n * @param {Change} change\n * @param {Object} properties\n */\n\nChanges$4.select = function (change, properties) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  properties = Range.createProperties(properties);\n\n  var _options$snapshot = options.snapshot,\n      snapshot = _options$snapshot === undefined ? false : _options$snapshot;\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var props = {};\n  var sel = selection.toJSON();\n  var next = selection.merge(properties).normalize(document);\n  properties = pick(next, Object.keys(properties));\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (var k in properties) {\n    if (snapshot == false && properties[k] == sel[k]) continue;\n    props[k] = properties[k];\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n  var moved = ['anchorKey', 'anchorOffset', 'focusKey', 'focusOffset'].some(function (p) {\n    return props.hasOwnProperty(p);\n  });\n\n  if (sel.marks && properties.marks == sel.marks && moved) {\n    props.marks = null;\n  }\n\n  // If there are no new properties to set, abort.\n  if (isEmpty(props)) {\n    return;\n  }\n\n  // Apply the operation.\n  change.applyOperation({\n    type: 'set_selection',\n    value: value,\n    properties: props,\n    selection: sel\n  }, snapshot ? { skip: false, merge: false } : {});\n};\n\n/**\n * Select the whole document.\n *\n * @param {Change} change\n */\n\nChanges$4.selectAll = function (change) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var next = selection.moveToRangeOf(document);\n  change.select(next);\n};\n\n/**\n * Snapshot the current selection.\n *\n * @param {Change} change\n */\n\nChanges$4.snapshotSelection = function (change) {\n  var value = change.value;\n  var selection = value.selection;\n\n  change.select(selection, { snapshot: true });\n};\n\n/**\n * Move the anchor point backward, accounting for being at the start of a block.\n *\n * @param {Change} change\n */\n\nChanges$4.moveAnchorCharBackward = function (change) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection,\n      anchorText = value.anchorText,\n      anchorBlock = value.anchorBlock;\n  var anchorOffset = selection.anchorOffset;\n\n  var previousText = document.getPreviousText(anchorText.key);\n  var isInVoid = document.hasVoidParent(anchorText.key);\n  var isPreviousInVoid = previousText && document.hasVoidParent(previousText.key);\n\n  if (!isInVoid && anchorOffset > 0) {\n    change.moveAnchor(-1);\n    return;\n  }\n\n  if (!previousText) {\n    return;\n  }\n\n  change.moveAnchorToEndOf(previousText);\n\n  if (!isInVoid && !isPreviousInVoid && anchorBlock.hasNode(previousText.key)) {\n    change.moveAnchor(-1);\n  }\n};\n\n/**\n * Move the anchor point forward, accounting for being at the end of a block.\n *\n * @param {Change} change\n */\n\nChanges$4.moveAnchorCharForward = function (change) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection,\n      anchorText = value.anchorText,\n      anchorBlock = value.anchorBlock;\n  var anchorOffset = selection.anchorOffset;\n\n  var nextText = document.getNextText(anchorText.key);\n  var isInVoid = document.hasVoidParent(anchorText.key);\n  var isNextInVoid = nextText && document.hasVoidParent(nextText.key);\n\n  if (!isInVoid && anchorOffset < anchorText.text.length) {\n    change.moveAnchor(1);\n    return;\n  }\n\n  if (!nextText) {\n    return;\n  }\n\n  change.moveAnchorToStartOf(nextText);\n\n  if (!isInVoid && !isNextInVoid && anchorBlock.hasNode(nextText.key)) {\n    change.moveAnchor(1);\n  }\n};\n\n/**\n * Move the focus point backward, accounting for being at the start of a block.\n *\n * @param {Change} change\n */\n\nChanges$4.moveFocusCharBackward = function (change) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection,\n      focusText = value.focusText,\n      focusBlock = value.focusBlock;\n  var focusOffset = selection.focusOffset;\n\n  var previousText = document.getPreviousText(focusText.key);\n  var isInVoid = document.hasVoidParent(focusText.key);\n  var isPreviousInVoid = previousText && document.hasVoidParent(previousText.key);\n\n  if (!isInVoid && focusOffset > 0) {\n    change.moveFocus(-1);\n    return;\n  }\n\n  if (!previousText) {\n    return;\n  }\n\n  change.moveFocusToEndOf(previousText);\n\n  if (!isInVoid && !isPreviousInVoid && focusBlock.hasNode(previousText.key)) {\n    change.moveFocus(-1);\n  }\n};\n\n/**\n * Move the focus point forward, accounting for being at the end of a block.\n *\n * @param {Change} change\n */\n\nChanges$4.moveFocusCharForward = function (change) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection,\n      focusText = value.focusText,\n      focusBlock = value.focusBlock;\n  var focusOffset = selection.focusOffset;\n\n  var nextText = document.getNextText(focusText.key);\n  var isInVoid = document.hasVoidParent(focusText.key);\n  var isNextInVoid = nextText && document.hasVoidParent(nextText.key);\n\n  if (!isInVoid && focusOffset < focusText.text.length) {\n    change.moveFocus(1);\n    return;\n  }\n\n  if (!nextText) {\n    return;\n  }\n\n  change.moveFocusToStartOf(nextText);\n\n  if (!isInVoid && !isNextInVoid && focusBlock.hasNode(nextText.key)) {\n    change.moveFocus(1);\n  }\n};\n\n/**\n * Mix in move methods.\n */\n\nvar MOVE_DIRECTIONS = ['Forward', 'Backward'];\n\nMOVE_DIRECTIONS.forEach(function (direction$$1) {\n  var anchor = 'moveAnchorChar' + direction$$1;\n  var focus = 'moveFocusChar' + direction$$1;\n\n  Changes$4['moveChar' + direction$$1] = function (change) {\n    change[anchor]()[focus]();\n  };\n\n  Changes$4['moveStartChar' + direction$$1] = function (change) {\n    if (change.value.isBackward) {\n      change[focus]();\n    } else {\n      change[anchor]();\n    }\n  };\n\n  Changes$4['moveEndChar' + direction$$1] = function (change) {\n    if (change.value.isBackward) {\n      change[anchor]();\n    } else {\n      change[focus]();\n    }\n  };\n\n  Changes$4['extendChar' + direction$$1] = function (change) {\n    change['moveFocusChar' + direction$$1]();\n  };\n\n  Changes$4['collapseChar' + direction$$1] = function (change) {\n    var collapse = direction$$1 == 'Forward' ? 'collapseToEnd' : 'collapseToStart';\n    change[collapse]()['moveChar' + direction$$1]();\n  };\n});\n\n/**\n * Mix in alias methods.\n */\n\nvar ALIAS_METHODS$1 = [['collapseLineBackward', 'collapseToStartOfBlock'], ['collapseLineForward', 'collapseToEndOfBlock'], ['extendLineBackward', 'extendToStartOfBlock'], ['extendLineForward', 'extendToEndOfBlock']];\n\nALIAS_METHODS$1.forEach(function (_ref) {\n  var _ref2 = slicedToArray(_ref, 2),\n      alias = _ref2[0],\n      method = _ref2[1];\n\n  Changes$4[alias] = function (change) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    change[method].apply(change, [change].concat(args));\n  };\n});\n\n/**\n * Mix in selection changes that are just a proxy for the selection method.\n */\n\nvar PROXY_TRANSFORMS$1 = ['blur', 'collapseTo', 'collapseToAnchor', 'collapseToEnd', 'collapseToEndOf', 'collapseToFocus', 'collapseToStart', 'collapseToStartOf', 'extend', 'extendTo', 'extendToEndOf', 'extendToStartOf', 'flip', 'focus', 'move', 'moveAnchor', 'moveAnchorOffsetTo', 'moveAnchorTo', 'moveAnchorToEndOf', 'moveAnchorToStartOf', 'moveEnd', 'moveEndOffsetTo', 'moveEndTo', 'moveFocus', 'moveFocusOffsetTo', 'moveFocusTo', 'moveFocusToEndOf', 'moveFocusToStartOf', 'moveOffsetsTo', 'moveStart', 'moveStartOffsetTo', 'moveStartTo', 'moveTo', 'moveToEnd', 'moveToEndOf', 'moveToRangeOf', 'moveToStart', 'moveToStartOf', 'deselect'];\n\nPROXY_TRANSFORMS$1.forEach(function (method) {\n  Changes$4[method] = function (change) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var normalize = method != 'deselect';\n    var value = change.value;\n    var document = value.document,\n        selection = value.selection;\n\n    var next = selection[method].apply(selection, args);\n    if (normalize) next = next.normalize(document);\n    change.select(next);\n  };\n});\n\n/**\n * Mix in node-related changes.\n */\n\nvar PREFIXES = ['moveTo', 'moveAnchorTo', 'moveFocusTo', 'moveStartTo', 'moveEndTo', 'collapseTo', 'extendTo'];\n\nvar DIRECTIONS = ['Next', 'Previous'];\n\nvar OBJECTS = ['Block', 'Inline', 'Text'];\n\nPREFIXES.forEach(function (prefix) {\n  var edges = ['Start', 'End'];\n\n  if (prefix == 'moveTo') {\n    edges.push('Range');\n  }\n\n  edges.forEach(function (edge) {\n    var method = '' + prefix + edge + 'Of';\n\n    OBJECTS.forEach(function (object) {\n      var getNode = object == 'Text' ? 'getNode' : 'getClosest' + object;\n\n      Changes$4['' + method + object] = function (change) {\n        var value = change.value;\n        var document = value.document,\n            selection = value.selection;\n\n        var node = document[getNode](selection.startKey);\n        if (!node) return;\n        change[method](node);\n      };\n\n      DIRECTIONS.forEach(function (direction$$1) {\n        var getDirectionNode = 'get' + direction$$1 + object;\n        var directionKey = direction$$1 == 'Next' ? 'startKey' : 'endKey';\n\n        Changes$4['' + method + direction$$1 + object] = function (change) {\n          var value = change.value;\n          var document = value.document,\n              selection = value.selection;\n\n          var node = document[getNode](selection[directionKey]);\n          if (!node) return;\n          var target = document[getDirectionNode](node.key);\n          if (!target) return;\n          change[method](target);\n        };\n      });\n    });\n  });\n});\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes$5 = {};\n\n/**\n * Set `properties` on the value.\n *\n * @param {Change} change\n * @param {Object|Value} properties\n * @param {Object} options\n */\n\nChanges$5.setValue = function (change, properties) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  properties = Value.createProperties(properties);\n  var value = change.value;\n\n\n  change.applyOperation({\n    type: 'set_value',\n    properties: properties,\n    value: value\n  }, options);\n};\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes$6 = {};\n\n/**\n * Normalize the value with its schema.\n *\n * @param {Change} change\n */\n\nChanges$6.normalize = function (change) {\n  change.normalizeDocument();\n};\n\n/**\n * Normalize the document with the value's schema.\n *\n * @param {Change} change\n */\n\nChanges$6.normalizeDocument = function (change) {\n  var value = change.value;\n  var document = value.document;\n\n  change.normalizeNodeByKey(document.key);\n};\n\n/**\n * Normalize a `node` and its children with the value's schema.\n *\n * @param {Change} change\n * @param {Node|String} key\n */\n\nChanges$6.normalizeNodeByKey = function (change, key) {\n  var value = change.value;\n  var document = value.document,\n      schema = value.schema;\n\n  var node = document.assertNode(key);\n\n  normalizeNodeAndChildren(change, node, schema);\n\n  document = change.value.document;\n  var ancestors = document.getAncestors(key);\n  if (!ancestors) return;\n\n  ancestors.forEach(function (ancestor) {\n    if (change.value.document.getDescendant(ancestor.key)) {\n      normalizeNode(change, ancestor, schema);\n    }\n  });\n};\n\n/**\n * Normalize a `node` and its children with a `schema`.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNodeAndChildren(change, node, schema) {\n  if (node.object == 'text') {\n    normalizeNode(change, node, schema);\n    return;\n  }\n\n  var child = node.getFirstInvalidDescendant(schema);\n  var path = change.value.document.getPath(node.key);\n\n  while (node && child) {\n    normalizeNodeAndChildren(change, child, schema);\n    node = change.value.document.refindNode(path, node.key);\n\n    if (!node) {\n      path = [];\n      child = null;\n    } else {\n      path = change.value.document.refindPath(path, node.key);\n      child = node.getFirstInvalidDescendant(schema);\n    }\n  }\n\n  // Normalize the node itself if it still exists.\n  if (node) {\n    normalizeNode(change, node, schema);\n  }\n}\n\n/**\n * Normalize a `node` with a `schema`, but not its children.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNode(change, node, schema) {\n  var max = schema.stack.plugins.length + 1;\n  var iterations = 0;\n\n  function iterate(c, n) {\n    var normalize = n.validate(schema);\n    if (!normalize) return;\n\n    // Run the `normalize` function to fix the node.\n    var path = c.value.document.getPath(n.key);\n    normalize(c);\n\n    // Re-find the node reference, in case it was updated. If the node no longer\n    // exists, we're done for this branch.\n    n = c.value.document.refindNode(path, n.key);\n    if (!n) return;\n\n    path = c.value.document.refindPath(path, n.key);\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `validate` or\n    // `normalize` function of a schema rule to be written incorrectly and for\n    // an infinite invalid loop to occur.\n    iterations++;\n\n    if (iterations > max) {\n      throw new Error('A schema rule could not be validated after sufficient iterations. This is usually due to a `rule.validate` or `rule.normalize` function of a schema being incorrectly written, causing an infinite loop.');\n    }\n\n    // Otherwise, iterate again.\n    iterate(c, n);\n  }\n\n  iterate(change, node);\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar Changes$7 = _extends({}, Changes, Changes$1, Changes$2, Changes$3, Changes$4, Changes$5, Changes$6);\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$3 = Debug('slate:operation:apply');\n\n/**\n * Apply adjustments to affected ranges (selections, decorations);\n * accepts (value, checking function(range) -> bool, applying function(range) -> range)\n * returns value with affected ranges updated\n *\n * @param {Value} value\n * @param {Function} checkAffected\n * @param {Function} adjustRange\n * @return {Value}\n */\n\nfunction applyRangeAdjustments(value, checkAffected, adjustRange) {\n  // check selection, apply adjustment if affected\n  if (value.selection && checkAffected(value.selection)) {\n    value = value.set('selection', adjustRange(value.selection));\n  }\n\n  if (!value.decorations) return value;\n\n  // check all ranges, apply adjustment if affected\n  var decorations = value.decorations.map(function (decoration) {\n    return checkAffected(decoration) ? adjustRange(decoration) : decoration;\n  }).filter(function (decoration) {\n    return decoration.anchorKey !== null;\n  });\n  return value.set('decorations', decorations);\n}\n\n/**\n * clear any atomic ranges (in decorations) if they contain the point (key, offset, offset-end?)\n * specified\n *\n * @param {Value} value\n * @param {String} key\n * @param {Number} offset\n * @param {Number?} offsetEnd\n * @return {Value}\n */\n\nfunction clearAtomicRangesIfContains(value, key, offset) {\n  var offsetEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return applyRangeAdjustments(value, function (range) {\n    if (!range.isAtomic) return false;\n    var startKey = range.startKey,\n        startOffset = range.startOffset,\n        endKey = range.endKey,\n        endOffset = range.endOffset;\n\n    return startKey == key && startOffset < offset && (endKey != key || endOffset > offset) || offsetEnd && startKey == key && startOffset < offsetEnd && (endKey != key || endOffset > offsetEnd);\n  }, function (range) {\n    return range.deselect();\n  });\n}\n\n/**\n * Applying functions.\n *\n * @type {Object}\n */\n\nvar APPLIERS = {\n  /**\n   * Add mark to text at `offset` and `length` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  add_mark: function add_mark(value, operation) {\n    var path = operation.path,\n        offset = operation.offset,\n        length = operation.length,\n        mark = operation.mark;\n    var _value = value,\n        document = _value.document;\n\n    var node = document.assertPath(path);\n    node = node.addMark(offset, length, mark);\n    document = document.updateNode(node);\n    value = value.set('document', document);\n    return value;\n  },\n\n\n  /**\n   * Insert a `node` at `index` in a node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  insert_node: function insert_node(value, operation) {\n    var path = operation.path,\n        node = operation.node;\n\n    var index = path[path.length - 1];\n    var rest = path.slice(0, -1);\n    var _value2 = value,\n        document = _value2.document;\n\n    var parent = document.assertPath(rest);\n    parent = parent.insertNode(index, node);\n    document = document.updateNode(parent);\n    value = value.set('document', document);\n    return value;\n  },\n\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  insert_text: function insert_text(value, operation) {\n    var path = operation.path,\n        offset = operation.offset,\n        text = operation.text,\n        marks = operation.marks;\n    var _value3 = value,\n        document = _value3.document;\n\n    var node = document.assertPath(path);\n\n    // Update the document\n    node = node.insertText(offset, text, marks);\n    document = document.updateNode(node);\n\n    value = value.set('document', document);\n\n    // if insert happens within atomic ranges, clear\n    value = clearAtomicRangesIfContains(value, node.key, offset);\n\n    // Update the selection, decorations\n    value = applyRangeAdjustments(value, function (_ref) {\n      var anchorKey = _ref.anchorKey,\n          anchorOffset = _ref.anchorOffset,\n          isBackward = _ref.isBackward,\n          isAtomic = _ref.isAtomic;\n      return anchorKey == node.key && (anchorOffset > offset || anchorOffset == offset && (!isAtomic || !isBackward));\n    }, function (range) {\n      return range.moveAnchor(text.length);\n    });\n\n    value = applyRangeAdjustments(value, function (_ref2) {\n      var focusKey = _ref2.focusKey,\n          focusOffset = _ref2.focusOffset,\n          isBackward = _ref2.isBackward,\n          isAtomic = _ref2.isAtomic;\n      return focusKey == node.key && (focusOffset > offset || focusOffset == offset && (!isAtomic || isBackward));\n    }, function (range) {\n      return range.moveFocus(text.length);\n    });\n\n    return value;\n  },\n\n\n  /**\n   * Merge a node at `path` with the previous node.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  merge_node: function merge_node(value, operation) {\n    var path = operation.path;\n\n    var withPath = path.slice(0, path.length - 1).concat([path[path.length - 1] - 1]);\n    var _value4 = value,\n        document = _value4.document;\n\n    var one = document.assertPath(withPath);\n    var two = document.assertPath(path);\n    var parent = document.getParent(one.key);\n    var oneIndex = parent.nodes.indexOf(one);\n    var twoIndex = parent.nodes.indexOf(two);\n\n    // Perform the merge in the document.\n    parent = parent.mergeNode(oneIndex, twoIndex);\n    document = document.updateNode(parent);\n    value = value.set('document', document);\n\n    if (one.object == 'text') {\n      value = applyRangeAdjustments(value,\n      // If the nodes are text nodes and the range is inside the second node:\n      function (_ref3) {\n        var anchorKey = _ref3.anchorKey,\n            focusKey = _ref3.focusKey;\n        return anchorKey == two.key || focusKey == two.key;\n      },\n      // update it to refer to the first node instead:\n      function (range) {\n        if (range.anchorKey == two.key) range = range.moveAnchorTo(one.key, one.text.length + range.anchorOffset);\n        if (range.focusKey == two.key) range = range.moveFocusTo(one.key, one.text.length + range.focusOffset);\n        return range.normalize(document);\n      });\n    }\n\n    return value;\n  },\n\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  move_node: function move_node(value, operation) {\n    var path = operation.path,\n        newPath = operation.newPath;\n\n    var newIndex = newPath[newPath.length - 1];\n    var newParentPath = newPath.slice(0, -1);\n    var oldParentPath = path.slice(0, -1);\n    var oldIndex = path[path.length - 1];\n    var _value5 = value,\n        document = _value5.document;\n\n    var node = document.assertPath(path);\n\n    // Remove the node from its current parent.\n    var parent = document.getParent(node.key);\n    parent = parent.removeNode(oldIndex);\n    document = document.updateNode(parent);\n\n    // Find the new target...\n    var target = void 0;\n\n    // If the old path and the rest of the new path are the same, then the new\n    // target is the old parent.\n    if (oldParentPath.every(function (x, i) {\n      return x === newParentPath[i];\n    }) && oldParentPath.length === newParentPath.length) {\n      target = parent;\n    } else if (oldParentPath.every(function (x, i) {\n      return x === newParentPath[i];\n    }) && oldIndex < newParentPath[oldParentPath.length]) {\n      // Otherwise, if the old path removal resulted in the new path being no longer\n      // correct, we need to decrement the new path at the old path's last index.\n      newParentPath[oldParentPath.length]--;\n      target = document.assertPath(newParentPath);\n    } else {\n      // Otherwise, we can just grab the target normally...\n      target = document.assertPath(newParentPath);\n    }\n\n    // Insert the new node to its new parent.\n    target = target.insertNode(newIndex, node);\n    document = document.updateNode(target);\n    value = value.set('document', document);\n    return value;\n  },\n\n\n  /**\n   * Remove mark from text at `offset` and `length` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  remove_mark: function remove_mark(value, operation) {\n    var path = operation.path,\n        offset = operation.offset,\n        length = operation.length,\n        mark = operation.mark;\n    var _value6 = value,\n        document = _value6.document;\n\n    var node = document.assertPath(path);\n    node = node.removeMark(offset, length, mark);\n    document = document.updateNode(node);\n    value = value.set('document', document);\n    return value;\n  },\n\n\n  /**\n   * Remove a node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  remove_node: function remove_node(value, operation) {\n    var path = operation.path;\n    var _value7 = value,\n        document = _value7.document,\n        selection = _value7.selection;\n\n    var node = document.assertPath(path);\n\n    if (selection.isSet || value.decorations !== null) {\n      var first = node.object == 'text' ? node : node.getFirstText() || node;\n      var last = node.object == 'text' ? node : node.getLastText() || node;\n      var prev = document.getPreviousText(first.key);\n      var next = document.getNextText(last.key);\n\n      value = applyRangeAdjustments(value,\n      // If the start or end point was in this node\n      function (_ref4) {\n        var startKey = _ref4.startKey,\n            endKey = _ref4.endKey;\n        return node.hasNode(startKey) || node.hasNode(endKey);\n      },\n      // update it to be just before/after\n      function (range) {\n        var _range = range,\n            startKey = _range.startKey,\n            endKey = _range.endKey;\n\n\n        if (node.hasNode(startKey)) {\n          range = prev ? range.moveStartTo(prev.key, prev.text.length) : next ? range.moveStartTo(next.key, 0) : range.deselect();\n        }\n\n        if (node.hasNode(endKey)) {\n          range = prev ? range.moveEndTo(prev.key, prev.text.length) : next ? range.moveEndTo(next.key, 0) : range.deselect();\n        }\n\n        // If the range wasn't deselected, normalize it.\n        if (range.isSet) return range.normalize(document);\n        return range;\n      });\n    }\n\n    // Remove the node from the document.\n    var parent = document.getParent(node.key);\n    var index = parent.nodes.indexOf(node);\n    parent = parent.removeNode(index);\n    document = document.updateNode(parent);\n\n    // Update the document and range.\n    value = value.set('document', document);\n    return value;\n  },\n\n\n  /**\n   * Remove `text` at `offset` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  remove_text: function remove_text(value, operation) {\n    var path = operation.path,\n        offset = operation.offset,\n        text = operation.text;\n    var length = text.length;\n\n    var rangeOffset = offset + length;\n    var _value8 = value,\n        document = _value8.document;\n\n\n    var node = document.assertPath(path);\n\n    // if insert happens within atomic ranges, clear\n    value = clearAtomicRangesIfContains(value, node.key, offset, offset + length);\n\n    value = applyRangeAdjustments(value,\n    // if anchor of range is here\n    function (_ref5) {\n      var anchorKey = _ref5.anchorKey;\n      return anchorKey == node.key;\n    },\n    // adjust if it is in or past the removal range\n    function (range) {\n      return range.anchorOffset >= rangeOffset ? range.moveAnchor(-length) : range.anchorOffset > offset ? range.moveAnchorTo(range.anchorKey, offset) : range;\n    });\n\n    value = applyRangeAdjustments(value,\n    // if focus of range is here\n    function (_ref6) {\n      var focusKey = _ref6.focusKey;\n      return focusKey == node.key;\n    },\n    // adjust if it is in or past the removal range\n    function (range) {\n      return range.focusOffset >= rangeOffset ? range.moveFocus(-length) : range.focusOffset > offset ? range.moveFocusTo(range.focusKey, offset) : range;\n    });\n\n    node = node.removeText(offset, length);\n    document = document.updateNode(node);\n    value = value.set('document', document);\n    return value;\n  },\n\n\n  /**\n   * Set `properties` on mark on text at `offset` and `length` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_mark: function set_mark(value, operation) {\n    var path = operation.path,\n        offset = operation.offset,\n        length = operation.length,\n        mark = operation.mark,\n        properties = operation.properties;\n    var _value9 = value,\n        document = _value9.document;\n\n    var node = document.assertPath(path);\n    node = node.updateMark(offset, length, mark, properties);\n    document = document.updateNode(node);\n    value = value.set('document', document);\n    return value;\n  },\n\n\n  /**\n   * Set `properties` on a node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_node: function set_node(value, operation) {\n    var path = operation.path,\n        properties = operation.properties;\n    var _value10 = value,\n        document = _value10.document;\n\n    var node = document.assertPath(path);\n    node = node.merge(properties);\n    document = document.updateNode(node);\n    value = value.set('document', document);\n    return value;\n  },\n\n\n  /**\n   * Set `properties` on the selection.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_selection: function set_selection(value, operation) {\n    var properties = operation.properties;\n    var anchorPath = properties.anchorPath,\n        focusPath = properties.focusPath,\n        props = objectWithoutProperties(properties, ['anchorPath', 'focusPath']);\n    var _value11 = value,\n        document = _value11.document,\n        selection = _value11.selection;\n\n\n    if (anchorPath !== undefined) {\n      props.anchorKey = anchorPath === null ? null : document.assertPath(anchorPath).key;\n    }\n\n    if (focusPath !== undefined) {\n      props.focusKey = focusPath === null ? null : document.assertPath(focusPath).key;\n    }\n\n    selection = selection.merge(props);\n    selection = selection.normalize(document);\n    value = value.set('selection', selection);\n    return value;\n  },\n\n\n  /**\n   * Set `properties` on `value`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_value: function set_value(value, operation) {\n    var properties = operation.properties;\n\n    value = value.merge(properties);\n    return value;\n  },\n\n\n  /**\n   * Split a node by `path` at `offset`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  split_node: function split_node(value, operation) {\n    var path = operation.path,\n        position = operation.position,\n        properties = operation.properties;\n    var _value12 = value,\n        document = _value12.document;\n\n    // Calculate a few things...\n\n    var node = document.assertPath(path);\n    var parent = document.getParent(node.key);\n    var index = parent.nodes.indexOf(node);\n\n    // Split the node by its parent.\n    parent = parent.splitNode(index, position);\n\n    if (properties) {\n      var splitNode = parent.nodes.get(index + 1);\n\n      if (splitNode.object !== 'text') {\n        parent = parent.updateNode(splitNode.merge(properties));\n      }\n    }\n\n    document = document.updateNode(parent);\n    var next = document.getNextText(node.key);\n\n    value = applyRangeAdjustments(value,\n    // check if range is affected\n    function (_ref7) {\n      var startKey = _ref7.startKey,\n          startOffset = _ref7.startOffset,\n          endKey = _ref7.endKey,\n          endOffset = _ref7.endOffset;\n      return node.key == startKey && position <= startOffset || node.key == endKey && position <= endOffset;\n    },\n    // update its start / end as needed\n    function (range) {\n      var _range2 = range,\n          startKey = _range2.startKey,\n          startOffset = _range2.startOffset,\n          endKey = _range2.endKey,\n          endOffset = _range2.endOffset;\n\n      var normalize = false;\n\n      if (node.key == startKey && position <= startOffset) {\n        range = range.moveStartTo(next.key, startOffset - position);\n        normalize = true;\n      }\n\n      if (node.key == endKey && position <= endOffset) {\n        range = range.moveEndTo(next.key, endOffset - position);\n        normalize = true;\n      }\n\n      // Normalize the selection if we changed it\n      if (normalize) return range.normalize(document);\n      return range;\n    });\n\n    // Return the updated value.\n    value = value.set('document', document);\n    return value;\n  }\n};\n\n/**\n * Apply an `operation` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} operation\n * @return {Value} value\n */\n\nfunction applyOperation(value, operation) {\n  operation = Operation.create(operation);\n  var _operation = operation,\n      type = _operation.type;\n\n  var apply = APPLIERS[type];\n\n  if (!apply) {\n    throw new Error('Unknown operation type: \"' + type + '\".');\n  }\n\n  debug$3(type, operation);\n  value = apply(value, operation);\n  return value;\n}\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$4 = Debug('slate:change');\n\n/**\n * Change.\n *\n * @type {Change}\n */\n\nvar Change = function () {\n\n  /**\n   * Create a new `Change` with `attrs`.\n   *\n   * @param {Object} attrs\n   *   @property {Value} value\n   */\n\n  function Change(attrs) {\n    classCallCheck(this, Change);\n    var value = attrs.value;\n\n    this.value = value;\n    this.operations = new immutable.List();\n\n    this.flags = _extends({\n      normalize: true\n    }, pick(attrs, ['merge', 'save', 'normalize']));\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  /**\n   * Check if `any` is a `Change`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  createClass(Change, [{\n    key: 'applyOperation',\n\n\n    /**\n     * Apply an `operation` to the current value, saving the operation to the\n     * history if needed.\n     *\n     * @param {Operation|Object} operation\n     * @param {Object} options\n     * @return {Change}\n     */\n\n    value: function applyOperation$$1(operation) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var operations = this.operations,\n          flags = this.flags;\n      var value = this.value;\n      var _value = value,\n          history = _value.history;\n\n      // Add in the current `value` in case the operation was serialized.\n\n      if (isPlainObject(operation)) {\n        operation = _extends({}, operation, { value: value });\n      }\n\n      operation = Operation.create(operation);\n\n      // Default options to the change-level flags, this allows for setting\n      // specific options for all of the operations of a given change.\n      options = _extends({}, flags, options);\n\n      // Derive the default option values.\n      var _options = options,\n          _options$merge = _options.merge,\n          merge = _options$merge === undefined ? operations.size == 0 ? null : true : _options$merge,\n          _options$save = _options.save,\n          save = _options$save === undefined ? true : _options$save,\n          _options$skip = _options.skip,\n          skip = _options$skip === undefined ? null : _options$skip;\n\n      // Apply the operation to the value.\n\n      debug$4('apply', { operation: operation, save: save, merge: merge });\n      value = applyOperation(value, operation);\n\n      // If needed, save the operation to the history.\n      if (history && save) {\n        history = history.save(operation, { merge: merge, skip: skip });\n        value = value.set('history', history);\n      }\n\n      // Update the mutable change object.\n      this.value = value;\n      this.operations = operations.push(operation);\n      return this;\n    }\n\n    /**\n     * Apply a series of `operations` to the current value.\n     *\n     * @param {Array|List} operations\n     * @param {Object} options\n     * @return {Change}\n     */\n\n  }, {\n    key: 'applyOperations',\n    value: function applyOperations(operations, options) {\n      var _this = this;\n\n      operations.forEach(function (op) {\n        return _this.applyOperation(op, options);\n      });\n      return this;\n    }\n\n    /**\n     * Call a change `fn` with arguments.\n     *\n     * @param {Function} fn\n     * @param {Mixed} ...args\n     * @return {Change}\n     */\n\n  }, {\n    key: 'call',\n    value: function call(fn) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      fn.apply(undefined, [this].concat(args));\n      return this;\n    }\n\n    /**\n     * Applies a series of change mutations and defers normalization until the end.\n     *\n     * @param {Function} customChange - function that accepts a change object and executes change operations\n     * @return {Change}\n     */\n\n  }, {\n    key: 'withoutNormalization',\n    value: function withoutNormalization(customChange) {\n      var original = this.flags.normalize;\n      this.setOperationFlag('normalize', false);\n\n      try {\n        customChange(this);\n        // if the change function worked then run normalization\n        this.normalizeDocument();\n      } finally {\n        // restore the flag to whatever it was\n        this.setOperationFlag('normalize', original);\n      }\n      return this;\n    }\n\n    /**\n     * Set an operation flag by `key` to `value`.\n     *\n     * @param {String} key\n     * @param {Any} value\n     * @return {Change}\n     */\n\n  }, {\n    key: 'setOperationFlag',\n    value: function setOperationFlag(key, value) {\n      this.flags[key] = value;\n      return this;\n    }\n\n    /**\n     * Get the `value` of the specified flag by its `key`. Optionally accepts an `options`\n     * object with override flags.\n     *\n     * @param {String} key\n     * @param {Object} options\n     * @return {Change}\n     */\n\n  }, {\n    key: 'getFlag',\n    value: function getFlag(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      return options[key] !== undefined ? options[key] : this.flags[key];\n    }\n\n    /**\n     * Unset an operation flag by `key`.\n     *\n     * @param {String} key\n     * @return {Change}\n     */\n\n  }, {\n    key: 'unsetOperationFlag',\n    value: function unsetOperationFlag(key) {\n      delete this.flags[key];\n      return this;\n    }\n  }, {\n    key: 'object',\n    get: function get$$1() {\n      return 'change';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }]);\n  return Change;\n}();\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nChange.isChange = isType.bind(null, 'CHANGE');\nChange.prototype[MODEL_TYPES.CHANGE] = true;\n\n/**\n * Add a change method for each of the changes.\n */\n\nObject.keys(Changes$7).forEach(function (type) {\n  Change.prototype[type] = function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    debug$4(type, { args: args });\n    this.call.apply(this, [Changes$7[type]].concat(args));\n    return this;\n  };\n});\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar Operations = {\n  apply: applyOperation,\n  invert: invertOperation\n};\n\nvar index = {\n  Block: Block,\n  Changes: Changes$7,\n  Character: Character,\n  Data: Data,\n  Document: Document,\n  History: History,\n  Inline: Inline,\n  Leaf: Leaf,\n  Mark: Mark,\n  Node: Node,\n  Operation: Operation,\n  Operations: Operations,\n  Range: Range,\n  Schema: Schema,\n  Stack: Stack,\n  Text: Text,\n  Value: Value,\n  resetKeyGenerator: resetKeyGenerator,\n  setKeyGenerator: setKeyGenerator,\n  resetMemoization: resetMemoization,\n  useMemoization: useMemoization\n};\n\nexports.Block = Block;\nexports.Change = Change;\nexports.Changes = Changes$7;\nexports.Character = Character;\nexports.Data = Data;\nexports.Document = Document;\nexports.History = History;\nexports.Inline = Inline;\nexports.Leaf = Leaf;\nexports.Mark = Mark;\nexports.Node = Node;\nexports.Operation = Operation;\nexports.Operations = Operations;\nexports.Range = Range;\nexports.Schema = Schema;\nexports.Stack = Stack;\nexports.Text = Text;\nexports.Value = Value;\nexports.resetKeyGenerator = resetKeyGenerator;\nexports.setKeyGenerator = setKeyGenerator;\nexports.resetMemoization = resetMemoization;\nexports.useMemoization = useMemoization;\nexports.default = index;\n//# sourceMappingURL=slate.js.map\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","_interopDefault","ex","isType","type","any","MODEL_TYPES","setKeyGenerator","func","generate","resetKeyGenerator","n","memoize","object","properties","_loop","property","original","Error","_len","arguments","length","args","Array","_key","ENABLED","apply","CACHE_KEY","__cache_key","__cache","Map","__cache_no_args","takesArguments","cachedValue","keys","concat","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","undefined","_iterator2","Symbol","iterator","_step2","done","next","map","get","value","err","return","LEAF","UNDEFINED","v","parent","child","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","key","set","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","resetMemoization","Number","MAX_SAFE_INTEGER","useMemoization","enabled","getFirst","node","getFirstText","getLast","getLastText","assertKey","arg","isSurrogate","code","SURROGATE_START","SURROGATE_END","isWord","char","remaining","SPACE","test","CHAMELEON","charAt","charCodeAt","slice","rest","PUNCTUATION","getCharOffset","text","getWordOffset","i","started","l","resolveSchema","schema","document","blocks","inlines","plugins","reverse","forEach","plugin","rules","nodes","_plugin$schema","_plugin$schema$docume","_plugin$schema$blocks","_plugin$schema$inline","d","_extends","data","bs","is","resolveNodeRule","_key2","mergeWith","customizer","obj","isVoid","first","last","target","source","invertOperation","op","Operation","create","debug$2","inverse","_inverse","_op2","newPath","path","inversePath","inverseNewPath","pathLast","newPathLast","every","e","_inverse2","_path","_inverse3","_inversePath","_path2","_inverse4","_last","_inversePath2","_op5","_inverse5","inverseNode","merge","inverseProperties","pick","Object","_inverse6","_inverse7","_inverse8","_inverse9","_op6","_inverse10","_properties","mark","inverseMark","_inverseProperties","_op7","_properties2","selection","anchorPath","focusPath","props","objectWithoutProperties","anchorKey","assertPath","focusKey","inverseSelection","inverseProps","getPath","_inverse11","_op8","_inverse12","_properties3","_value","inverseValue","_inverseProperties2","normalizeNodeAndChildren","change","normalizeNode","getFirstInvalidDescendant","refindNode","refindPath","iterate","c","normalize","validate","iterations","max","stack","applyRangeAdjustments","checkAffected","adjustRange","decorations","decoration","filter","clearAtomicRangesIfContains","offset","offsetEnd","range","isAtomic","startKey","startOffset","endKey","endOffset","deselect","applyOperation","operation","APPLIERS","debug$3","defineProperty","isPlainObject","logger","immutable","direction","esrever","Debug","isEqual","slateSchemaViolations","omit","isEmpty","BLOCK","CHANGE","CHARACTER","DOCUMENT","HISTORY","INLINE","MARK","OPERATION","RANGE","SCHEMA","STACK","TEXT","VALUE","_typeof","constructor","prototype","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","descriptor","enumerable","configurable","writable","protoProps","staticProps","assign","hasOwnProperty","call","inherits","subClass","superClass","setPrototypeOf","__proto__","indexOf","possibleConstructorReturn","self","ReferenceError","slicedToArray","arr","isArray","_arr","_n","_d","_e","_i","_s","push","toConsumableArray","arr2","from","DEFAULTS","List","Block","_Record","getPrototypeOf","toJSON","options","toArray","preserveKeys","toJS","get$$1","deprecate","some","getText","attrs","isBlock","fromJSON","createList","isList","list","_object$data","_object$isVoid","_object$key","_object$nodes","block","createChildren","isBlockList","item","Record","fromJS","bind","DEFAULTS$1","Inline","isInline","elements","inline","isInlineList","Data","isMap","DEFAULTS$2","Mark","getComponent","__getComponent","isMark","createSet","Set","isSet","marks","createProperties","isMarkSet","Changes","PROXY_TRANSFORMS","method","match","collapseToStart","collapseToEnd","setBlock","Changes.setBlock","setBlocks","setInline","Changes.setInline","setInlines","addMark","Changes.addMark","isExpanded","addMarkAtRange","add","sel","select","_marks","getActiveMarksAtRange","_sel","addMarks","Changes.addMarks","delete","Changes.delete","deleteAtRange","insertBlock","Changes.insertBlock","insertBlockAtRange","getNode","collapseToEndOf","insertFragment","Changes.insertFragment","fragment","size","_value2","startText","endText","startInline","lastText","lastInline","getClosestInline","firstChild","lastChild","getTexts","isAppending","hasEdgeAtStartOf","hasEdgeAtEndOf","isInserting","hasBlocks","insertFragmentAtRange","newTexts","includes","newText","takeLast","collapseToStartOf","move","insertInline","Changes.insertInline","insertInlineAtRange","insertText","Changes.insertText","getInsertMarksAtRange","insertTextAtRange","splitBlock","Changes.splitBlock","depth","splitBlockAtRange","removeMark","Changes.removeMark","removeMarkAtRange","remove","_marks2","_sel2","replaceMark","Changes.replaceMark","oldMark","newMark","toggleMark","Changes.toggleMark","activeMarks","has","exists","wrapText","Changes.wrapText","prefix","suffix","wrapTextAtRange","isCollapsed","moveStart","moveEnd","isForward","flip","DEFAULTS$3","Document","isDocument","Range","hasAnchorAtStartOf","anchorOffset","hasAnchorAtEndOf","hasAnchorBetween","start","end","hasAnchorIn","hasDescendant","hasFocusAtEndOf","focusOffset","hasFocusAtStartOf","hasFocusBetween","hasFocusIn","isAtStartOf","isAtEndOf","focus","isFocused","blur","isBackward","moveAnchor","moveFocus","moveAnchorTo","moveFocusTo","moveAnchorOffsetTo","moveFocusOffsetTo","moveOffsetsTo","moveToAnchor","moveToFocus","moveAnchorToStartOf","moveAnchorToEndOf","moveFocusToStartOf","moveFocusToEndOf","moveToRangeOf","anchorOffsetType","focusOffsetType","warn","anchorNode","getDescendant","focusNode","anchorText","getTextAtOffset","getOffset","focusText","_offset","areDescendantsSorted","m","isRange","_object$anchorKey","_object$anchorOffset","_object$focusKey","_object$focusOffset","_object$isBackward","_object$isFocused","_object$marks","_object$isAtomic","DEFAULTS$4","MOVE_METHODS","_ref","_ref2","p","s","_ref3","EDGE_METHODS","_ref4","_ref5","hasEdge","anchor","ALIAS_METHODS","_ref6","_ref7","alias","DEFAULTS$5","Character","isCharacter","split","character","isCharacterList","DEFAULTS$6","Leaf","getCharacters","characters","updateMark","equals","newMarks","withMutations","collection","set$$1","union","isLeaf","createLeaves","leaves","invalid","result","cache","findLast","leaf","index","firstLeaf","unshift","splitLeaves","left","right","find","of","take","skip","_object$text","isLeafList","DEFAULTS$7","Text","getString","reduce","string","searchLeafAtOffset","newFirst","_Leaf$splitLeaves","_Leaf$splitLeaves2","before","_Leaf$splitLeaves3","bundle","_Leaf$splitLeaves4","after","middle","x","setLeaves","getDecorations","__getDecorations","getLeaves","_this2","hasStart","hasEnd","_Leaf$splitLeaves5","_Leaf$splitLeaves6","_Leaf$splitLeaves7","_Leaf$splitLeaves8","getActiveMarksBetweenOffsets","getActiveMarks","leafEnd","leafStart","intersect","_this3","getMarksBetweenOffsets","getMarks","array","getMarksAsArray","OrderedSet","getMarksAtIndex","_searchLeafAtOffset","hasNode","_searchLeafAtOffset2","delta","beforeText","afterText","nextLeaves","splice","regenerateKey","_Leaf$splitLeaves9","_Leaf$splitLeaves10","_Leaf$splitLeaves11","_Leaf$splitLeaves12","removeText","_searchLeafAtOffset3","_leaves2","_Leaf$splitLeaves13","_Leaf$splitLeaves14","r","_Leaf$splitLeaves15","_Leaf$splitLeaves16","_Leaf$splitLeaves17","_Leaf$splitLeaves18","splitText","splitted","one","two","mergeText","validateNode","flatMap","isText","_attrs","_object$leaves","isTextList","Node","second","getKeysAsArray","firstIndex","secondIndex","assertChild","getChild","assertDescendant","descendant","assertNode","getDescendantAtPath","filterDescendants","matches","forEachDescendant","findDescendant","found","ret","getAncestors","hasChild","ancestors","getBlocks","getBlocksAsArray","isLeafBlock","getBlocksAtRange","getBlocksAtRangeAsArray","isUnset","_range","startBlock","getClosestBlock","endBlock","getBlocksByType","getBlocksByTypeAsArray","t","getCharactersAtRange","_range2","getTextsAtRange","getClosest","getClosestVoid","getCommonAncestor","oneParent","getParent","twoParent","getDepth","startAt","getFurthestAncestor","descendantFound","getFragmentAtRange","_range3","previous","position","splitNode","updateNode","getNextText","_index","_position","startNode","getNextSibling","endNode","startIndex","endIndex","getFurthest","getFurthestBlock","getFurthestInline","getFurthestOnlyChildAncestor","shift","takeUntil","getInlines","getInlinesAsArray","isLeafInline","getInlinesAtRange","getInlinesAtRangeAsArray","_this","getTextsAtRangeAsArray","getInlinesByType","getInlinesByTypeAsArray","desc","getKeys","getOrderedMarks","getMarksAtRange","getOrderedMarksAtRange","getMarksAtPosition","_range4","getOrderedMarksBetweenPositions","_range5","texts","getTextsBetweenPositionsAsArray","_range6","toSet","_range7","_endText","getPreviousText","startMarks","endMarks","currentMarks","closestBlock","getMarksByType","getMarksByTypeAsArray","getOrderedMarksByType","getNextBlock","skipUntil","getNodeAtPath","memo","getOffsetAtRange","_range8","ancestor","getPlaceholder","__getPlaceholder","getPreviousBlock","getPreviousSibling","getSelectionIndexes","isSelected","getTextDirection","dir","getTextsAsArray","_range9","_range10","hasInlines","hasVoidParent","insertNode","mapDescendants","insert","isInRange","_range11","mergeNode","withIndex","removeNode","mapChildren","removeDescendant","findIndex","_child$splitText","_child$splitText2","befores","afters","isNode","kind","isNodeList","getOwnPropertyNames","String","getCharOffsetForward","getCharOffsetBackward","getWordOffsetBackward","o","getWordOffsetForward","Changes$1","Changes$1.addMarkAtRange","getFlag","addMarkByKey","Changes$1.addMarksAtRange","Changes$1.deleteAtRange","snapshotSelection","isStartVoid","isEndVoid","isHanging","prevText","startVoid","nextText","removeNodeByKey","endVoid","_prevText","removeTextByKey","startLength","endLength","startChild","endChild","startParent","startParentIndex","endParentIndex","startChildIndex","endChildIndex","middles","_parent","_index2","lonely","moveNodeByKey","mergeNodeByKey","normalizeNodeByKey","Changes$1.deleteCharBackwardAtRange","deleteBackwardAtRange","Changes$1.deleteLineBackwardAtRange","Changes$1.deleteWordBackwardAtRange","Changes$1.deleteBackwardAtRange","voidParent","prev","prevBlock","prevVoid","traversed","Changes$1.deleteCharForwardAtRange","deleteForwardAtRange","Changes$1.deleteLineForwardAtRange","Changes$1.deleteWordForwardAtRange","Changes$1.deleteForwardAtRange","nextBlock","moveToStartOf","_nextBlock","nextVoid","_next","Changes$1.insertBlockAtRange","extra","insertNodeByKey","splitDescendantsByKey","Changes$1.insertFragmentAtRange","collapseTo","isAtStart","firstBlock","lastBlock","lonelyChild","lonelyParent","nextChild","nextNodes","lastIndex","inlineChild","inlineIndex","Changes$1.insertInlineAtRange","splitNodeByKey","Changes$1.insertTextAtRange","insertTextByKey","commonAncestor","normalizeAncestor","normalizeKey","Changes$1.removeMarkAtRange","removeMarkByKey","Changes$1.setBlocksAtRange","sets","setNodeByKey","Changes$1.setBlockAtRange","setBlocksAtRange","Changes$1.setInlinesAtRange","Changes$1.setInlineAtRange","setInlinesAtRange","Changes$1.splitBlockAtRange","height","h","Changes$1.splitInlineAtRange","Infinity","Changes$1.toggleMarkAtRange","Changes$1.unwrapBlockAtRange","isSuperset","toOrderedSet","toList","wrappers","children","b","firstMatch","lastMatch","firstText","normalizeDocument","Changes$1.unwrapInlineAtRange","Changes$1.wrapBlockAtRange","clear","firstblock","lastblock","siblings","p1","p2","indexes","ind","Changes$1.wrapInlineAtRange","inlineParent","wrapInlineByKey","endInline","inlinekey","rng","startInner","startInnerIndex","endInner","startInlines","endInlines","Changes$1.wrapTextAtRange","OPERATION_ATTRIBUTES","add_mark","insert_node","insert_text","merge_node","move_node","remove_mark","remove_node","remove_text","set_mark","set_node","set_selection","set_value","split_node","debug","DEFAULTS$8","redos","Stack","undos","History","save","history","_history","prevBatch","peek","prevOperation","batch","pop","_batch","isHistory","_object$redos","_object$undos","CORE_SCHEMA_RULES","invalids","objects","insertBefore","insertAfter","Boolean","getPluginsWith","_len2","run","_len3","_key3","render","_len4","_key4","reduceRight","_attrs$plugins","isStack","DEFAULTS$9","debug$1","DEFAULTS$10","Schema","getRule","getParentRules","parents","rule","_rule","fail","violation","context","operations","CHILD_OBJECT_INVALID","CHILD_TYPE_INVALID","CHILD_UNKNOWN","FIRST_CHILD_OBJECT_INVALID","FIRST_CHILD_TYPE_INVALID","LAST_CHILD_OBJECT_INVALID","LAST_CHILD_TYPE_INVALID","CHILD_REQUIRED","NODE_TEXT_INVALID","PARENT_OBJECT_INVALID","PARENT_TYPE_INVALID","_node","NODE_DATA_INVALID","_node2","NODE_IS_VOID_INVALID","_node3","NODE_MARK_INVALID","ctx","fn","def","_ret","_rule$first","types","_rule$last","_objects","_types","_child","nextDef","min","defs","_child2","isSchema","DEFAULTS$11","Value","Change","preserveData","preserveDecorations","preserveHistory","preserveSelection","preserveSchema","_document","withPath","isBlurred","getNextInline","getPreviousInline","isValue","_object$document","_object$selection","_object$schema","_selection","json","ATTRIBUTES","_v","_v2","_v3","_v4","_v5","isOperation","_v6","isOperationList","DEFAULTS$12","Changes$4","Changes$4.select","_options$snapshot","snapshot","k","moved","Changes$4.selectAll","Changes$4.snapshotSelection","Changes$4.moveAnchorCharBackward","anchorBlock","previousText","isInVoid","isPreviousInVoid","Changes$4.moveAnchorCharForward","isNextInVoid","Changes$4.moveFocusCharBackward","focusBlock","Changes$4.moveFocusCharForward","MOVE_DIRECTIONS","direction$$1","collapse","ALIAS_METHODS$1","PROXY_TRANSFORMS$1","DIRECTIONS","OBJECTS","PREFIXES","edges","edge","getDirectionNode","directionKey","Changes$7","Changes$2","Changes$2.addMarkByKey","by","ax","ay","Math","applyOperations","Changes$2.insertFragmentByKey","Changes$2.insertNodeByKey","Changes$2.insertTextByKey","Changes$2.mergeNodeByKey","Changes$2.moveNodeByKey","newKey","newIndex","Changes$2.removeMarkByKey","Changes$2.removeAllMarksByKey","state","Changes$2.removeNodeByKey","Changes$2.setTextByKey","textNode","replaceTextByKey","Changes$2.replaceTextByKey","activeMark","Changes$2.removeTextByKey","removals","Changes$2.replaceNodeByKey","newNode","Changes$2.setMarkByKey","Changes$2.setNodeByKey","Changes$2.splitNodeByKey","_options$normalize","_options$target","Changes$2.splitDescendantsByKey","textKey","textOffset","a","prevIndex","Changes$2.unwrapInlineByKey","unwrapInlineAtRange","Changes$2.unwrapBlockByKey","unwrapBlockAtRange","Changes$2.unwrapNodeByKey","isFirst","isLast","parentParent","parentIndex","Changes$2.wrapBlockByKey","Changes$2.wrapInlineByKey","Changes$2.wrapNodeByKey","wrapBlockByKey","Changes$3","Changes$3.redo","_op","Changes$3.undo","_history2","Changes$5","Changes$5.setValue","Changes$6","Changes$6.normalize","Changes$6.normalizeDocument","Changes$6.normalizeNodeByKey","oneIndex","twoIndex","newParentPath","oldParentPath","oldIndex","_value7","moveStartTo","moveEndTo","rangeOffset","_value11","debug$4","flags","applyOperation$$1","_options","_options$merge","_options$save","_options$skip","withoutNormalization","customChange","setOperationFlag","unsetOperationFlag","isChange","Operations","invert","default"]
}
