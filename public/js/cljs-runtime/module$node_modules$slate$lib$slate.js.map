{
"version":3,
"file":"module$node_modules$slate$lib$slate.js",
"lineCount":354,
"mappings":"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",
"sources":["node_modules/slate/lib/slate.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$slate$lib$slate\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar isPlainObject = _interopDefault(require('is-plain-object'));\nvar logger = _interopDefault(require('slate-dev-logger'));\nvar immutable = require('immutable');\nvar direction = _interopDefault(require('direction'));\nvar esrever = require('esrever');\nvar Debug = _interopDefault(require('debug'));\nvar isEqual = _interopDefault(require('lodash/isEqual'));\nvar slateSchemaViolations = require('slate-schema-violations');\nvar pick = _interopDefault(require('lodash/pick'));\nvar omit = _interopDefault(require('lodash/omit'));\nvar isEmpty = _interopDefault(require('is-empty'));\n\n/**\n * Slate-specific model types.\n *\n * @type {Object}\n */\n\nvar MODEL_TYPES = {\n  BLOCK: '@@__SLATE_BLOCK__@@',\n  CHANGE: '@@__SLATE_CHANGE__@@',\n  CHARACTER: '@@__SLATE_CHARACTER__@@',\n  DOCUMENT: '@@__SLATE_DOCUMENT__@@',\n  HISTORY: '@@__SLATE_HISTORY__@@',\n  INLINE: '@@__SLATE_INLINE__@@',\n  LEAF: '@@__SLATE_LEAF__@@',\n  MARK: '@@__SLATE_MARK__@@',\n  OPERATION: '@@__SLATE_OPERATION__@@',\n  RANGE: '@@__SLATE_RANGE__@@',\n  SCHEMA: '@@__SLATE_SCHEMA__@@',\n  STACK: '@@__SLATE_STACK__@@',\n  TEXT: '@@__SLATE_TEXT__@@',\n  VALUE: '@@__SLATE_VALUE__@@'\n\n  /**\n   * Export type identification function\n   *\n   * @param {string} type\n   * @param {any} any\n   * @return {boolean}\n   */\n\n};function isType(type, any) {\n  return !!(any && any[MODEL_TYPES[type]]);\n}\n\n/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nvar n = void 0;\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nvar generate = void 0;\n\n/**\n * Create a key, using a provided key if available.\n *\n * @param {String|Void} key\n * @return {String}\n */\n\nfunction create(key) {\n  if (key == null) {\n    return generate();\n  }\n\n  if (typeof key === 'string') {\n    return key;\n  }\n\n  throw new Error('Keys must be strings, but you passed: ' + key);\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setGenerator(func) {\n  generate = func;\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetGenerator() {\n  n = 0;\n  generate = function generate() {\n    return '' + n++;\n  };\n}\n\n/**\n * Set the initial state.\n */\n\nresetGenerator();\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar KeyUtils = {\n  create: create,\n  setGenerator: setGenerator,\n  resetGenerator: resetGenerator\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/**\n * Dependencies.\n */\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  data: new immutable.Map(),\n  isVoid: false,\n  key: undefined,\n  nodes: new immutable.List(),\n  type: undefined\n\n  /**\n   * Block.\n   *\n   * @type {Block}\n   */\n\n};\nvar Block = function (_Record) {\n  inherits(Block, _Record);\n\n  function Block() {\n    classCallCheck(this, Block);\n    return possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).apply(this, arguments));\n  }\n\n  createClass(Block, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the block.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        type: this.type,\n        isVoid: this.isVoid,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS(options) {\n      return this.toJSON(options);\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'block';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n\n    /**\n     * Check if the block is empty.\n     * Returns true if block is not void and all it's children nodes are empty.\n     * Void node is never empty, regardless of it's content.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get$$1() {\n      return !this.isVoid && !this.nodes.some(function (child) {\n        return !child.isEmpty;\n      });\n    }\n\n    /**\n     * Get the concatenated text of all the block's children.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get$$1() {\n      return this.getText();\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Block` from `attrs`.\n     *\n     * @param {Object|String|Block} attrs\n     * @return {Block}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Block.isBlock(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs == 'string') {\n        attrs = { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Block.fromJSON(attrs);\n      }\n\n      throw new Error('`Block.create` only accepts objects, strings or blocks, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Blocks` from `attrs`.\n     *\n     * @param {Array<Block|Object>|List<Block|Object>} attrs\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(attrs) || Array.isArray(attrs)) {\n        var list = new immutable.List(attrs.map(Block.create));\n        return list;\n      }\n\n      throw new Error('`Block.createList` only accepts arrays or lists, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Block` from a JSON `object`.\n     *\n     * @param {Object|Block} object\n     * @return {Block}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Block.isBlock(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$isVoid = object.isVoid,\n          isVoid = _object$isVoid === undefined ? false : _object$isVoid,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes,\n          type = object.type;\n\n\n      if (typeof type != 'string') {\n        throw new Error('`Block.fromJSON` requires a `type` string.');\n      }\n\n      var block = new Block({\n        key: key,\n        type: type,\n        isVoid: !!isVoid,\n        data: immutable.Map(data),\n        nodes: Block.createChildren(nodes)\n      });\n\n      return block;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Block`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlockList',\n\n\n    /**\n     * Check if `any` is a block list.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isBlockList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Block.isBlock(item);\n      });\n    }\n  }]);\n  return Block;\n}(immutable.Record(DEFAULTS));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nBlock.fromJS = Block.fromJSON;\nBlock.isBlock = isType.bind(null, 'BLOCK');\nBlock.prototype[MODEL_TYPES.BLOCK] = true;\n\n/**\n * Dependencies.\n */\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$1 = {\n  data: new immutable.Map(),\n  isVoid: false,\n  key: undefined,\n  nodes: new immutable.List(),\n  type: undefined\n\n  /**\n   * Inline.\n   *\n   * @type {Inline}\n   */\n\n};\nvar Inline = function (_Record) {\n  inherits(Inline, _Record);\n\n  function Inline() {\n    classCallCheck(this, Inline);\n    return possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));\n  }\n\n  createClass(Inline, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the inline.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        type: this.type,\n        isVoid: this.isVoid,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS(options) {\n      return this.toJSON(options);\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'inline';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n\n    /**\n     * Check if the inline is empty.\n     * Returns true if inline is not void and all it's children nodes are empty.\n     * Void node is never empty, regardless of it's content.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get$$1() {\n      return !this.isVoid && !this.nodes.some(function (child) {\n        return !child.isEmpty;\n      });\n    }\n\n    /**\n     * Get the concatenated text of all the inline's children.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get$$1() {\n      return this.getText();\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Inline` with `attrs`.\n     *\n     * @param {Object|String|Inline} attrs\n     * @return {Inline}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Inline.isInline(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs == 'string') {\n        attrs = { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Inline.fromJSON(attrs);\n      }\n\n      throw new Error('`Inline.create` only accepts objects, strings or inlines, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Inlines` from an array.\n     *\n     * @param {Array<Inline|Object>|List<Inline|Object>} elements\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Inline.create));\n        return list;\n      }\n\n      throw new Error('`Inline.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a `Inline` from a JSON `object`.\n     *\n     * @param {Object|Inline} object\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Inline.isInline(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$isVoid = object.isVoid,\n          isVoid = _object$isVoid === undefined ? false : _object$isVoid,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes,\n          type = object.type;\n\n\n      if (typeof type != 'string') {\n        throw new Error('`Inline.fromJS` requires a `type` string.');\n      }\n\n      var inline = new Inline({\n        key: key,\n        type: type,\n        isVoid: !!isVoid,\n        data: new immutable.Map(data),\n        nodes: Inline.createChildren(nodes)\n      });\n\n      return inline;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Inline`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInlineList',\n\n\n    /**\n     * Check if `any` is a list of inlines.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isInlineList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Inline.isInline(item);\n      });\n    }\n  }]);\n  return Inline;\n}(immutable.Record(DEFAULTS$1));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nInline.fromJS = Inline.fromJSON;\nInline.isInline = isType.bind(null, 'INLINE');\nInline.prototype[MODEL_TYPES.INLINE] = true;\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nvar Data = function () {\n  function Data() {\n    classCallCheck(this, Data);\n  }\n\n  createClass(Data, null, [{\n    key: 'create',\n\n    /**\n     * Create a new `Data` with `attrs`.\n     *\n     * @param {Object|Data|Map} attrs\n     * @return {Data} data\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (immutable.Map.isMap(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Data.fromJSON(attrs);\n      }\n\n      throw new Error('`Data.create` only accepts objects or maps, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Data` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Data}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      return new immutable.Map(object);\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }]);\n  return Data;\n}();\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nData.fromJS = Data.fromJSON;\n\n/**\n * GLOBAL: True if memoization should is enabled.\n *\n * @type {Boolean}\n */\n\nvar ENABLED = true;\n\n/**\n * GLOBAL: Changing this cache key will clear all previous cached results.\n *\n * @type {Number}\n */\n\nvar CACHE_KEY = 0;\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Object}\n */\n\nvar LEAF = {};\n\n/**\n * A value to represent a memoized undefined value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Object}\n */\n\nvar UNDEFINED = {};\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nvar UNSET = undefined;\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  var _loop = function _loop(property) {\n    var original = object[property];\n\n    if (!original) {\n      throw new Error(\"Object does not have a property named \\\"\" + property + \"\\\".\");\n    }\n\n    object[property] = function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // If memoization is disabled, call into the original method.\n      if (!ENABLED) return original.apply(this, args);\n\n      // If the cache key is different, previous caches must be cleared.\n      if (CACHE_KEY !== this.__cache_key) {\n        this.__cache_key = CACHE_KEY;\n        this.__cache = new Map(); // eslint-disable-line no-undef,no-restricted-globals\n        this.__cache_no_args = {};\n      }\n\n      if (!this.__cache) {\n        this.__cache = new Map(); // eslint-disable-line no-undef,no-restricted-globals\n      }\n\n      if (!this.__cache_no_args) {\n        this.__cache_no_args = {};\n      }\n\n      var takesArguments = args.length !== 0;\n\n      var cachedValue = void 0;\n      var keys = void 0;\n\n      if (takesArguments) {\n        keys = [property].concat(args);\n        cachedValue = getIn(this.__cache, keys);\n      } else {\n        cachedValue = this.__cache_no_args[property];\n      }\n\n      // If we've got a result already, return it.\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue;\n      }\n\n      // Otherwise calculate what it should be once and cache it.\n      var value = original.apply(this, args);\n      var v = value === undefined ? UNDEFINED : value;\n\n      if (takesArguments) {\n        this.__cache = setIn(this.__cache, keys, v);\n      } else {\n        this.__cache_no_args[property] = v;\n      }\n\n      return value;\n    };\n  };\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n\n      _loop(property);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var key = _step2.value;\n\n      map = map.get(key);\n      if (map === UNSET) return UNSET;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return map.get(LEAF);\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  var parent = map;\n  var child = void 0;\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var key = _step3.value;\n\n      child = parent.get(key);\n\n      // If the path was not created yet...\n      if (child === UNSET) {\n        child = new Map(); // eslint-disable-line no-undef,no-restricted-globals\n        parent.set(key, child);\n      }\n\n      parent = child;\n    }\n\n    // The whole path has been created, so set the value to the bottom most map.\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  child.set(LEAF, value);\n  return map;\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction resetMemoization() {\n  CACHE_KEY++;\n\n  if (CACHE_KEY >= Number.MAX_SAFE_INTEGER) {\n    CACHE_KEY = 0;\n  }\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled;\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$2 = {\n  data: new immutable.Map(),\n  type: undefined\n\n  /**\n   * Mark.\n   *\n   * @type {Mark}\n   */\n\n};\nvar Mark = function (_Record) {\n  inherits(Mark, _Record);\n\n  function Mark() {\n    classCallCheck(this, Mark);\n    return possibleConstructorReturn(this, (Mark.__proto__ || Object.getPrototypeOf(Mark)).apply(this, arguments));\n  }\n\n  createClass(Mark, [{\n    key: 'getComponent',\n\n\n    /**\n     * Get the component for the node from a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Component|Void}\n     */\n\n    value: function getComponent(schema) {\n      return schema.__getComponent(this);\n    }\n\n    /**\n     * Return a JSON representation of the mark.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON()\n      };\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS() {\n      return this.toJSON();\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     */\n\n    get: function get$$1() {\n      return 'mark';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Mark` with `attrs`.\n     *\n     * @param {Object|Mark} attrs\n     * @return {Mark}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Mark.isMark(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs == 'string') {\n        attrs = { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Mark.fromJSON(attrs);\n      }\n\n      throw new Error('`Mark.create` only accepts objects, strings or marks, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a set of marks.\n     *\n     * @param {Array<Object|Mark>} elements\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'createSet',\n    value: function createSet(elements) {\n      if (immutable.Set.isSet(elements) || Array.isArray(elements)) {\n        var marks = new immutable.Set(elements.map(Mark.create));\n        return marks;\n      }\n\n      if (elements == null) {\n        return immutable.Set();\n      }\n\n      throw new Error('`Mark.createSet` only accepts sets, arrays or null, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a dictionary of settable mark properties from `attrs`.\n     *\n     * @param {Object|String|Mark} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Mark.isMark(attrs)) {\n        return {\n          data: attrs.data,\n          type: attrs.type\n        };\n      }\n\n      if (typeof attrs == 'string') {\n        return { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        var props = {};\n        if ('type' in attrs) props.type = attrs.type;\n        if ('data' in attrs) props.data = Data.create(attrs.data);\n        return props;\n      }\n\n      throw new Error('`Mark.createProperties` only accepts objects, strings or marks, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Mark` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Mark}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          type = object.type;\n\n\n      if (typeof type != 'string') {\n        throw new Error('`Mark.fromJS` requires a `type` string.');\n      }\n\n      var mark = new Mark({\n        type: type,\n        data: new immutable.Map(data)\n      });\n\n      return mark;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Mark`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isMarkSet',\n\n\n    /**\n     * Check if `any` is a set of marks.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isMarkSet(any) {\n      return immutable.Set.isSet(any) && any.every(function (item) {\n        return Mark.isMark(item);\n      });\n    }\n  }]);\n  return Mark;\n}(immutable.Record(DEFAULTS$2));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nMark.fromJS = Mark.fromJSON;\nMark.isMark = isType.bind(null, 'MARK');\nMark.prototype[MODEL_TYPES.MARK] = true;\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Mark.prototype, ['getComponent']);\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes = {};\n\n/**\n * Mix in the changes that pass through to their at-range equivalents because\n * they don't have any effect on the selection.\n */\n\nvar PROXY_TRANSFORMS = ['deleteBackward', 'deleteCharBackward', 'deleteLineBackward', 'deleteWordBackward', 'deleteForward', 'deleteCharForward', 'deleteWordForward', 'deleteLineForward', 'setBlocks', 'setInlines', 'splitInline', 'unwrapBlock', 'unwrapInline', 'wrapBlock', 'wrapInline'];\n\nPROXY_TRANSFORMS.forEach(function (method) {\n  Changes[method] = function (change) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var value = change.value;\n    var selection = value.selection;\n\n    var methodAtRange = method + 'AtRange';\n    change[methodAtRange].apply(change, [selection].concat(args));\n\n    if (method.match(/Backward$/)) {\n      change.collapseToStart();\n    } else if (method.match(/Forward$/)) {\n      change.collapseToEnd();\n    }\n  };\n});\n\nChanges.setBlock = function () {\n  logger.deprecate('slate@0.33.0', 'The `setBlock` method of Slate changes has been renamed to `setBlocks`.');\n\n  Changes.setBlocks.apply(Changes, arguments);\n};\n\nChanges.setInline = function () {\n  logger.deprecate('slate@0.33.0', 'The `setInline` method of Slate changes has been renamed to `setInlines`.');\n\n  Changes.setInlines.apply(Changes, arguments);\n};\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMark = function (change, mark) {\n  mark = Mark.create(mark);\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    change.addMarkAtRange(selection, mark);\n  } else if (selection.marks) {\n    var marks = selection.marks.add(mark);\n    var sel = selection.set('marks', marks);\n    change.select(sel);\n  } else {\n    var _marks = document.getActiveMarksAtRange(selection).add(mark);\n    var _sel = selection.set('marks', _marks);\n    change.select(_sel);\n  }\n};\n\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMarks = function (change, marks) {\n  marks.forEach(function (mark) {\n    return change.addMark(mark);\n  });\n};\n\n/**\n * Delete at the current selection.\n *\n * @param {Change} change\n */\n\nChanges.delete = function (change) {\n  var value = change.value;\n  var selection = value.selection;\n\n  change.deleteAtRange(selection);\n\n  // Ensure that the selection is collapsed to the start, because in certain\n  // cases when deleting across inline nodes, when splitting the inline node the\n  // end point of the selection will end up after the split point.\n  change.collapseToStart();\n};\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Block} block\n */\n\nChanges.insertBlock = function (change, block) {\n  block = Block.create(block);\n  var value = change.value;\n  var selection = value.selection;\n\n  change.insertBlockAtRange(selection, block);\n\n  // If the node was successfully inserted, update the selection.\n  var node = change.value.document.getNode(block.key);\n  if (node) change.collapseToEndOf(node);\n};\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Change} change\n * @param {Document} fragment\n */\n\nChanges.insertFragment = function (change, fragment) {\n  if (!fragment.nodes.size) return;\n\n  var value = change.value;\n  var _value = value,\n      document = _value.document,\n      selection = _value.selection;\n  var _value2 = value,\n      startText = _value2.startText,\n      endText = _value2.endText,\n      startInline = _value2.startInline;\n\n  var lastText = fragment.getLastText();\n  var lastInline = fragment.getClosestInline(lastText.key);\n  var firstChild = fragment.nodes.first();\n  var lastChild = fragment.nodes.last();\n  var keys = document.getTexts().map(function (text) {\n    return text.key;\n  });\n  var isAppending = !startInline || selection.hasEdgeAtStartOf(startText) || selection.hasEdgeAtEndOf(endText);\n\n  var isInserting = firstChild.hasBlockChildren() || lastChild.hasBlockChildren();\n\n  change.insertFragmentAtRange(selection, fragment);\n  value = change.value;\n  document = value.document;\n\n  var newTexts = document.getTexts().filter(function (n) {\n    return !keys.includes(n.key);\n  });\n  var newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first();\n\n  if (newText && (lastInline || isInserting)) {\n    change.select(selection.collapseToEndOf(newText));\n  } else if (newText) {\n    change.select(selection.collapseToStartOf(newText).move(lastText.text.length));\n  } else {\n    change.select(selection.collapseToStart().move(lastText.text.length));\n  }\n};\n\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Inline} inline\n */\n\nChanges.insertInline = function (change, inline) {\n  inline = Inline.create(inline);\n  var value = change.value;\n  var selection = value.selection;\n\n  change.insertInlineAtRange(selection, inline);\n\n  // If the node was successfully inserted, update the selection.\n  var node = change.value.document.getNode(inline.key);\n  if (node) change.collapseToEndOf(node);\n};\n\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Change} change\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nChanges.insertText = function (change, text, marks) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection);\n  change.insertTextAtRange(selection, text, marks);\n\n  // If the text was successfully inserted, and the selection had marks on it,\n  // unset the selection's marks.\n  if (selection.marks && document != change.value.document) {\n    change.select({ marks: null });\n  }\n};\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Change} change\n * @param {Number} depth (optional)\n */\n\nChanges.splitBlock = function (change) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var value = change.value;\n  var selection = value.selection,\n      document = value.document;\n\n  var marks = selection.marks || document.getInsertMarksAtRange(selection);\n  change.splitBlockAtRange(selection, depth).collapseToEnd();\n\n  if (marks && marks.size !== 0) {\n    change.select({ marks: marks });\n  }\n};\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.removeMark = function (change, mark) {\n  mark = Mark.create(mark);\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    change.removeMarkAtRange(selection, mark);\n  } else if (selection.marks) {\n    var marks = selection.marks.remove(mark);\n    var sel = selection.set('marks', marks);\n    change.select(sel);\n  } else {\n    var _marks2 = document.getActiveMarksAtRange(selection).remove(mark);\n    var _sel2 = selection.set('marks', _marks2);\n    change.select(_sel2);\n  }\n};\n\n/**\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} oldMark\n * @param {Mark} newMark\n */\n\nChanges.replaceMark = function (change, oldMark, newMark) {\n  change.removeMark(oldMark);\n  change.addMark(newMark);\n};\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.toggleMark = function (change, mark) {\n  mark = Mark.create(mark);\n  var value = change.value;\n\n  var exists = value.activeMarks.has(mark);\n\n  if (exists) {\n    change.removeMark(mark);\n  } else {\n    change.addMark(mark);\n  }\n};\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Change} change\n * @param {String} prefix\n * @param {String} suffix\n */\n\nChanges.wrapText = function (change, prefix) {\n  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prefix;\n  var value = change.value;\n  var selection = value.selection;\n\n  change.wrapTextAtRange(selection, prefix, suffix);\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    change.moveStart(0 - prefix.length);\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  change.moveEnd(0 - suffix.length);\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward != change.value.selection.isForward) {\n    change.flip();\n  }\n};\n\n/**\n * Dependencies.\n */\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$3 = {\n  data: new immutable.Map(),\n  key: undefined,\n  nodes: new immutable.List()\n\n  /**\n   * Document.\n   *\n   * @type {Document}\n   */\n\n};\nvar Document = function (_Record) {\n  inherits(Document, _Record);\n\n  function Document() {\n    classCallCheck(this, Document);\n    return possibleConstructorReturn(this, (Document.__proto__ || Object.getPrototypeOf(Document)).apply(this, arguments));\n  }\n\n  createClass(Document, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the document.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS(options) {\n      return this.toJSON(options);\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'document';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n\n    /**\n     * Check if the document is empty.\n     * Returns true if all it's children nodes are empty.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get$$1() {\n      return !this.nodes.some(function (child) {\n        return !child.isEmpty;\n      });\n    }\n\n    /**\n     * Get the concatenated text of all the document's children.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get$$1() {\n      return this.getText();\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Document` with `attrs`.\n     *\n     * @param {Object|Array|List|Text} attrs\n     * @return {Document}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Document.isDocument(attrs)) {\n        return attrs;\n      }\n\n      if (immutable.List.isList(attrs) || Array.isArray(attrs)) {\n        attrs = { nodes: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Document.fromJSON(attrs);\n      }\n\n      throw new Error('`Document.create` only accepts objects, arrays, lists or documents, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Document` from a JSON `object`.\n     *\n     * @param {Object|Document} object\n     * @return {Document}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Document.isDocument(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes;\n\n\n      var document = new Document({\n        key: key,\n        data: new immutable.Map(data),\n        nodes: Document.createChildren(nodes)\n      });\n\n      return document;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Document`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }]);\n  return Document;\n}(immutable.Record(DEFAULTS$3));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nDocument.fromJS = Document.fromJSON;\nDocument.isDocument = isType.bind(null, 'DOCUMENT');\nDocument.prototype[MODEL_TYPES.DOCUMENT] = true;\n\n/**\n * Compare paths `a` and `b` to see which is before or after.\n *\n * @param {List} a\n * @param {List} b\n * @return {Number|Null}\n */\n\nfunction compare(a, b) {\n  // PERF: if the paths are the same we can exit early.\n  if (a.size !== b.size) return null;\n\n  for (var i = 0; i < a.size; i++) {\n    var av = a.get(i);\n    var bv = b.get(i);\n\n    // If a's value is ever less than b's, it's before.\n    if (av < bv) return -1;\n\n    // If b's value is ever less than a's, it's after.\n    if (av > bv) return 1;\n  }\n\n  // Otherwise they were equal the whole way, it's the same.\n  return 0;\n}\n\n/**\n * Create a path from `attrs`.\n *\n * @param {Array|List} attrs\n * @return {List}\n */\n\nfunction create$1(attrs) {\n  if (attrs == null) {\n    return null;\n  }\n\n  if (immutable.List.isList(attrs)) {\n    return attrs;\n  }\n\n  if (Array.isArray(attrs)) {\n    return immutable.List(attrs);\n  }\n\n  throw new Error('Paths can only be created from arrays or lists, but you passed: ' + attrs);\n}\n\n/**\n * Crop paths `a` and `b` to an equal size, defaulting to the shortest.\n *\n * @param {List} a\n * @param {List} b\n */\n\nfunction crop(a, b) {\n  var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min(a, b);\n\n  var ca = a.slice(0, size);\n  var cb = b.slice(0, size);\n  return [ca, cb];\n}\n\n/**\n * Decrement a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction decrement(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.size - 1;\n\n  return increment(path, 0 - n, index);\n}\n\n/**\n * Increment a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction increment(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.size - 1;\n\n  var value = path.get(index);\n  var newValue = value + n;\n  var newPath = path.set(index, newValue);\n  return newPath;\n}\n\n/**\n * Is a `path` above another `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAbove(path, target) {\n  var _crop = crop(path, target),\n      _crop2 = slicedToArray(_crop, 2),\n      p = _crop2[0],\n      t = _crop2[1];\n\n  return path.size < target.size && compare(p, t) === 0;\n}\n\n/**\n * Is a `path` after another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAfter(path, target) {\n  var _crop3 = crop(path, target),\n      _crop4 = slicedToArray(_crop3, 2),\n      p = _crop4[0],\n      t = _crop4[1];\n\n  return compare(p, t) === 1;\n}\n\n/**\n * Is a `path` before another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isBefore(path, target) {\n  var _crop5 = crop(path, target),\n      _crop6 = slicedToArray(_crop5, 2),\n      p = _crop6[0],\n      t = _crop6[1];\n\n  return compare(p, t) === -1;\n}\n\n/**\n * Lift a `path` to refer to its parent.\n *\n * @param {List} path\n * @return {Array}\n */\n\nfunction lift(path) {\n  var parent = path.slice(0, -1);\n  return parent;\n}\n\n/**\n * Get the maximum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction max(a, b) {\n  var n = Math.max(a.size, b.size);\n  return n;\n}\n\n/**\n * Get the minimum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction min(a, b) {\n  var n = Math.min(a.size, b.size);\n  return n;\n}\n\n/**\n * Get the common ancestor path of path `a` and path `b`.\n *\n * @param {List} a\n * @param {List} b\n * @return {List}\n */\n\nfunction relate(a, b) {\n  var array = [];\n\n  for (var i = 0; i < a.size && i < b.size; i++) {\n    var av = a.get(i);\n    var bv = b.get(i);\n\n    // If the values aren't equal, they've diverged and don't share an ancestor.\n    if (av !== bv) break;\n\n    // Otherwise, the current value is still a common ancestor.\n    array.push(av);\n  }\n\n  var path = create$1(array);\n  return path;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar PathUtils = {\n  compare: compare,\n  create: create$1,\n  crop: crop,\n  decrement: decrement,\n  increment: increment,\n  isAbove: isAbove,\n  isAfter: isAfter,\n  isBefore: isBefore,\n  lift: lift,\n  max: max,\n  min: min,\n  relate: relate\n};\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$4 = {\n  anchorKey: null,\n  anchorOffset: 0,\n  anchorPath: null,\n  focusKey: null,\n  focusOffset: 0,\n  focusPath: null,\n  isAtomic: false,\n  isBackward: null,\n  isFocused: false,\n  marks: null\n\n  /**\n   * Range.\n   *\n   * @type {Range}\n   */\n\n};\nvar Range = function (_Record) {\n  inherits(Range, _Record);\n\n  function Range() {\n    classCallCheck(this, Range);\n    return possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).apply(this, arguments));\n  }\n\n  createClass(Range, [{\n    key: 'hasAnchorAtStartOf',\n\n\n    /**\n     * Check whether anchor point of the range is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n    value: function hasAnchorAtStartOf(node) {\n      // PERF: Do a check for a `0` offset first since it's quickest.\n      if (this.anchorOffset != 0) return false;\n      var first = getFirstText(node);\n      return this.anchorKey == first.key;\n    }\n\n    /**\n     * Check whether anchor point of the range is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasAnchorAtEndOf',\n    value: function hasAnchorAtEndOf(node) {\n      var last = getLastText(node);\n      return this.anchorKey == last.key && this.anchorOffset == last.text.length;\n    }\n\n    /**\n     * Check whether the anchor edge of a range is in a `node` and at an\n     * offset between `start` and `end`.\n     *\n     * @param {Node} node\n     * @param {Number} start\n     * @param {Number} end\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasAnchorBetween',\n    value: function hasAnchorBetween(node, start, end) {\n      return this.anchorOffset <= end && start <= this.anchorOffset && this.hasAnchorIn(node);\n    }\n\n    /**\n     * Check whether the anchor edge of a range is in a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasAnchorIn',\n    value: function hasAnchorIn(node) {\n      return node.object == 'text' ? node.key == this.anchorKey : this.anchorKey != null && node.hasDescendant(this.anchorKey);\n    }\n\n    /**\n     * Check whether focus point of the range is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusAtEndOf',\n    value: function hasFocusAtEndOf(node) {\n      var last = getLastText(node);\n      return this.focusKey == last.key && this.focusOffset == last.text.length;\n    }\n\n    /**\n     * Check whether focus point of the range is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusAtStartOf',\n    value: function hasFocusAtStartOf(node) {\n      if (this.focusOffset != 0) return false;\n      var first = getFirstText(node);\n      return this.focusKey == first.key;\n    }\n\n    /**\n     * Check whether the focus edge of a range is in a `node` and at an\n     * offset between `start` and `end`.\n     *\n     * @param {Node} node\n     * @param {Number} start\n     * @param {Number} end\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusBetween',\n    value: function hasFocusBetween(node, start, end) {\n      return start <= this.focusOffset && this.focusOffset <= end && this.hasFocusIn(node);\n    }\n\n    /**\n     * Check whether the focus edge of a range is in a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusIn',\n    value: function hasFocusIn(node) {\n      return node.object == 'text' ? node.key == this.focusKey : this.focusKey != null && node.hasDescendant(this.focusKey);\n    }\n\n    /**\n     * Check whether the range is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtStartOf',\n    value: function isAtStartOf(node) {\n      return this.isCollapsed && this.hasAnchorAtStartOf(node);\n    }\n\n    /**\n     * Check whether the range is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtEndOf',\n    value: function isAtEndOf(node) {\n      return this.isCollapsed && this.hasAnchorAtEndOf(node);\n    }\n\n    /**\n     * Focus the range.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'focus',\n    value: function focus() {\n      return this.merge({\n        isFocused: true\n      });\n    }\n\n    /**\n     * Blur the range.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'blur',\n    value: function blur() {\n      return this.merge({\n        isFocused: false\n      });\n    }\n\n    /**\n     * Unset the range.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'deselect',\n    value: function deselect() {\n      return this.merge({\n        anchorKey: null,\n        anchorOffset: 0,\n        anchorPath: null,\n        focusKey: null,\n        focusOffset: 0,\n        focusPath: null,\n        isFocused: false,\n        isBackward: false\n      });\n    }\n\n    /**\n     * Flip the range.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'flip',\n    value: function flip() {\n      return this.merge({\n        anchorKey: this.focusKey,\n        anchorOffset: this.focusOffset,\n        anchorPath: this.focusPath,\n        focusKey: this.anchorKey,\n        focusOffset: this.anchorOffset,\n        focusPath: this.anchorPath,\n        isBackward: this.isBackward == null ? null : !this.isBackward\n      });\n    }\n\n    /**\n     * Move the anchor offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchor',\n    value: function moveAnchor() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var anchorKey = this.anchorKey,\n          focusKey = this.focusKey,\n          focusOffset = this.focusOffset,\n          isBackward = this.isBackward;\n\n      var anchorOffset = this.anchorOffset + n;\n      return this.merge({\n        anchorOffset: anchorOffset,\n        isBackward: anchorKey == focusKey ? anchorOffset > focusOffset : isBackward\n      });\n    }\n\n    /**\n     * Move the anchor offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocus',\n    value: function moveFocus() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var anchorKey = this.anchorKey,\n          anchorOffset = this.anchorOffset,\n          focusKey = this.focusKey,\n          isBackward = this.isBackward;\n\n      var focusOffset = this.focusOffset + n;\n      return this.merge({\n        focusOffset: focusOffset,\n        isBackward: focusKey == anchorKey ? anchorOffset > focusOffset : isBackward\n      });\n    }\n\n    /**\n     * Move the range's anchor point to a new `key` or `path` and `offset`.\n     *\n     * @param {String|List} key or path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorTo',\n    value: function moveAnchorTo(key, offset) {\n      var anchorKey = this.anchorKey,\n          focusKey = this.focusKey,\n          focusOffset = this.focusOffset,\n          anchorPath = this.anchorPath,\n          focusPath = this.focusPath,\n          isBackward = this.isBackward;\n\n\n      if (typeof key === 'string') {\n        var isAnchor = key === anchorKey;\n        var isFocus = key === focusKey;\n        return this.merge({\n          anchorKey: key,\n          anchorPath: isFocus ? focusPath : isAnchor ? anchorPath : null,\n          anchorOffset: offset,\n          isBackward: isFocus ? offset > focusOffset : isAnchor ? isBackward : null\n        });\n      } else {\n        var path = key;\n        var _isAnchor = path && path.equals(anchorPath);\n        var _isFocus = path && path.equals(focusPath);\n        return this.merge({\n          anchorPath: path,\n          anchorKey: _isAnchor ? anchorKey : _isFocus ? focusKey : null,\n          anchorOffset: offset,\n          isBackward: _isFocus ? offset > focusOffset : _isAnchor ? isBackward : null\n        });\n      }\n    }\n\n    /**\n     * Move the range's focus point to a new `key` or `path` and `offset`.\n     *\n     * @param {String|List} key or path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusTo',\n    value: function moveFocusTo(key, offset) {\n      var focusKey = this.focusKey,\n          anchorKey = this.anchorKey,\n          anchorOffset = this.anchorOffset,\n          anchorPath = this.anchorPath,\n          focusPath = this.focusPath,\n          isBackward = this.isBackward;\n\n\n      if (typeof key === 'string') {\n        var isAnchor = key === anchorKey;\n        var isFocus = key === focusKey;\n        return this.merge({\n          focusKey: key,\n          focusPath: isAnchor ? anchorPath : isFocus ? focusPath : null,\n          focusOffset: offset,\n          isBackward: isAnchor ? offset < anchorOffset : isFocus ? isBackward : null\n        });\n      } else {\n        var path = key;\n        var _isAnchor2 = path && path.equals(anchorPath);\n        var _isFocus2 = path && path.equals(focusPath);\n        return this.merge({\n          focusPath: path,\n          focusKey: _isFocus2 ? focusKey : _isAnchor2 ? anchorKey : null,\n          focusOffset: offset,\n          isBackward: _isAnchor2 ? offset < anchorOffset : _isFocus2 ? isBackward : null\n        });\n      }\n    }\n\n    /**\n     * Move the range to `anchorOffset`.\n     *\n     * @param {Number} anchorOffset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorOffsetTo',\n    value: function moveAnchorOffsetTo(anchorOffset) {\n      return this.merge({\n        anchorOffset: anchorOffset,\n        isBackward: this.anchorKey == this.focusKey ? anchorOffset > this.focusOffset : this.isBackward\n      });\n    }\n\n    /**\n     * Move the range to `focusOffset`.\n     *\n     * @param {Number} focusOffset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusOffsetTo',\n    value: function moveFocusOffsetTo(focusOffset) {\n      return this.merge({\n        focusOffset: focusOffset,\n        isBackward: this.anchorKey == this.focusKey ? this.anchorOffset > focusOffset : this.isBackward\n      });\n    }\n\n    /**\n     * Move the range to `anchorOffset` and `focusOffset`.\n     *\n     * @param {Number} anchorOffset\n     * @param {Number} focusOffset (optional)\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveOffsetsTo',\n    value: function moveOffsetsTo(anchorOffset) {\n      var focusOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : anchorOffset;\n\n      return this.moveAnchorOffsetTo(anchorOffset).moveFocusOffsetTo(focusOffset);\n    }\n\n    /**\n     * Move the focus point to the anchor point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToAnchor',\n    value: function moveToAnchor() {\n      return this.moveFocusTo(this.anchorKey, this.anchorOffset);\n    }\n\n    /**\n     * Move the anchor point to the focus point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToFocus',\n    value: function moveToFocus() {\n      return this.moveAnchorTo(this.focusKey, this.focusOffset);\n    }\n\n    /**\n     * Move the range's anchor point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorToStartOf',\n    value: function moveAnchorToStartOf(node) {\n      node = getFirstText(node);\n      return this.moveAnchorTo(node.key, 0);\n    }\n\n    /**\n     * Move the range's anchor point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorToEndOf',\n    value: function moveAnchorToEndOf(node) {\n      node = getLastText(node);\n      return this.moveAnchorTo(node.key, node.text.length);\n    }\n\n    /**\n     * Move the range's focus point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusToStartOf',\n    value: function moveFocusToStartOf(node) {\n      node = getFirstText(node);\n      return this.moveFocusTo(node.key, 0);\n    }\n\n    /**\n     * Move the range's focus point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusToEndOf',\n    value: function moveFocusToEndOf(node) {\n      node = getLastText(node);\n      return this.moveFocusTo(node.key, node.text.length);\n    }\n\n    /**\n     * Move to the entire range of `start` and `end` nodes.\n     *\n     * @param {Node} start\n     * @param {Node} end (optional)\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToRangeOf',\n    value: function moveToRangeOf(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;\n\n      var range = this.isBackward ? this.flip() : this;\n      return range.moveAnchorToStartOf(start).moveFocusToEndOf(end);\n    }\n\n    /**\n     * Normalize the range, relative to a `node`, ensuring that the anchor\n     * and focus nodes of the range always refer to leaf text nodes.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(node) {\n      var range = this;\n      var anchorKey = range.anchorKey,\n          anchorOffset = range.anchorOffset,\n          anchorPath = range.anchorPath,\n          focusKey = range.focusKey,\n          focusOffset = range.focusOffset,\n          focusPath = range.focusPath,\n          isBackward = range.isBackward;\n\n\n      var anchorOffsetType = typeof anchorOffset === 'undefined' ? 'undefined' : _typeof(anchorOffset);\n      var focusOffsetType = typeof focusOffset === 'undefined' ? 'undefined' : _typeof(focusOffset);\n\n      if (anchorOffsetType != 'number' || focusOffsetType != 'number') {\n        logger.warn('The range offsets should be numbers, but they were of type \"' + anchorOffsetType + '\" and \"' + focusOffsetType + '\".');\n      }\n\n      // If either point in the range is unset, make sure it is fully unset.\n      if (anchorKey == null && anchorPath == null || focusKey == null && focusPath == null) {\n        return range.merge({\n          anchorKey: null,\n          anchorOffset: 0,\n          anchorPath: null,\n          focusKey: null,\n          focusOffset: 0,\n          focusPath: null,\n          isBackward: false\n        });\n      }\n\n      // Get the anchor and focus nodes.\n      var anchorNode = node.getNode(anchorKey || anchorPath);\n      var focusNode = node.getNode(focusKey || focusPath);\n\n      // If the range is malformed, warn and zero it out.\n      if (!anchorNode || !focusNode) {\n        logger.warn('The range was invalid and was reset. The range in question was:', range);\n\n        var first = node.getFirstText();\n        var path = first && node.getPath(first.key);\n        return range.merge({\n          anchorKey: first ? first.key : null,\n          anchorOffset: 0,\n          anchorPath: first ? path : null,\n          focusKey: first ? first.key : null,\n          focusOffset: 0,\n          focusPath: first ? path : null,\n          isBackward: false\n        });\n      }\n\n      // If the anchor node isn't a text node, match it to one.\n      if (anchorNode.object != 'text') {\n        logger.warn('The range anchor was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:', anchorNode);\n\n        var anchorText = anchorNode.getTextAtOffset(anchorOffset);\n        var offset = anchorNode.getOffset(anchorText.key);\n        anchorOffset = anchorOffset - offset;\n        anchorNode = anchorText;\n      }\n\n      // If the focus node isn't a text node, match it to one.\n      if (focusNode.object != 'text') {\n        logger.warn('The range focus was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:', focusNode);\n\n        var focusText = focusNode.getTextAtOffset(focusOffset);\n        var _offset = focusNode.getOffset(focusText.key);\n        focusOffset = focusOffset - _offset;\n        focusNode = focusText;\n      }\n\n      anchorKey = anchorNode.key;\n      focusKey = focusNode.key;\n      anchorPath = node.getPath(anchorKey);\n      focusPath = node.getPath(focusKey);\n\n      // If `isBackward` is not set, derive it.\n      if (isBackward == null) {\n        var result = PathUtils.compare(anchorPath, focusPath);\n        isBackward = result === 0 ? anchorOffset > focusOffset : result === 1;\n      }\n\n      // Merge in any updated properties.\n      return range.merge({\n        anchorKey: anchorKey,\n        anchorOffset: anchorOffset,\n        anchorPath: anchorPath,\n        focusKey: focusKey,\n        focusOffset: focusOffset,\n        focusPath: focusPath,\n        isBackward: isBackward\n      });\n    }\n\n    /**\n     * Return a JSON representation of the range.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        anchorKey: this.anchorKey,\n        anchorOffset: this.anchorOffset,\n        anchorPath: this.anchorPath && this.anchorPath.toArray(),\n        focusKey: this.focusKey,\n        focusOffset: this.focusOffset,\n        focusPath: this.focusPath && this.focusPath.toArray(),\n        isAtomic: this.isAtomic,\n        isBackward: this.isBackward,\n        isFocused: this.isFocused,\n        marks: this.marks == null ? null : this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n\n      if (!options.preserveKeys) {\n        delete object.anchorKey;\n        delete object.focusKey;\n      }\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS() {\n      return this.toJSON();\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'range';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n\n    /**\n     * Check whether the range is blurred.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlurred',\n    get: function get$$1() {\n      return !this.isFocused;\n    }\n\n    /**\n     * Check whether the range is collapsed.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCollapsed',\n    get: function get$$1() {\n      return this.anchorKey == this.focusKey && this.anchorOffset == this.focusOffset;\n    }\n\n    /**\n     * Check whether the range is expanded.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isExpanded',\n    get: function get$$1() {\n      return !this.isCollapsed;\n    }\n\n    /**\n     * Check whether the range is forward.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isForward',\n    get: function get$$1() {\n      return this.isBackward == null ? null : !this.isBackward;\n    }\n\n    /**\n     * Check whether the range's keys are set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSet',\n    get: function get$$1() {\n      return this.anchorKey != null && this.focusKey != null || this.anchorPath != null && this.focusPath != null;\n    }\n\n    /**\n     * Check whether the range's keys are not set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isUnset',\n    get: function get$$1() {\n      return !this.isSet;\n    }\n\n    /**\n     * Get the start key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startKey',\n    get: function get$$1() {\n      return this.isBackward ? this.focusKey : this.anchorKey;\n    }\n\n    /**\n     * Get the start offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startOffset',\n    get: function get$$1() {\n      return this.isBackward ? this.focusOffset : this.anchorOffset;\n    }\n\n    /**\n     * Get the start path.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startPath',\n    get: function get$$1() {\n      return this.isBackward ? this.focusPath : this.anchorPath;\n    }\n\n    /**\n     * Get the end key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endKey',\n    get: function get$$1() {\n      return this.isBackward ? this.anchorKey : this.focusKey;\n    }\n\n    /**\n     * Get the end offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endOffset',\n    get: function get$$1() {\n      return this.isBackward ? this.anchorOffset : this.focusOffset;\n    }\n\n    /**\n     * Get the end path.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endPath',\n    get: function get$$1() {\n      return this.isBackward ? this.anchorPath : this.focusPath;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Range` with `attrs`.\n     *\n     * @param {Object|Range} attrs\n     * @return {Range}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Range.isRange(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Range.fromJSON(attrs);\n      }\n\n      throw new Error('`Range.create` only accepts objects or ranges, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Ranges` from `elements`.\n     *\n     * @param {Array<Range|Object>|List<Range|Object>} elements\n     * @return {List<Range>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Range.create));\n        return list;\n      }\n\n      throw new Error('`Range.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a dictionary of settable range properties from `attrs`.\n     *\n     * @param {Object|String|Range} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Range.isRange(a)) {\n        return {\n          anchorKey: a.anchorKey,\n          anchorOffset: a.anchorOffset,\n          anchorPath: a.anchorPath,\n          focusKey: a.focusKey,\n          focusOffset: a.focusOffset,\n          focusPath: a.focusPath,\n          isAtomic: a.isAtomic,\n          isBackward: a.isBackward,\n          isFocused: a.isFocused,\n          marks: a.marks\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('anchorKey' in a) p.anchorKey = a.anchorKey;\n        if ('anchorOffset' in a) p.anchorOffset = a.anchorOffset;\n        if ('anchorPath' in a) p.anchorPath = PathUtils.create(a.anchorPath);\n        if ('focusKey' in a) p.focusKey = a.focusKey;\n        if ('focusOffset' in a) p.focusOffset = a.focusOffset;\n        if ('focusPath' in a) p.focusPath = PathUtils.create(a.focusPath);\n        if ('isAtomic' in a) p.isAtomic = a.isAtomic;\n        if ('isBackward' in a) p.isBackward = a.isBackward;\n        if ('isFocused' in a) p.isFocused = a.isFocused;\n        if ('marks' in a) p.marks = a.marks == null ? null : Mark.createSet(a.marks);\n\n        // If only a path is set, or only a key is set, ensure that the other is\n        // set to null so that it can be normalized back to the right value.\n        // Otherwise we won't realize that the path and key don't match anymore.\n        if ('anchorPath' in a && !('anchorKey' in a)) p.anchorKey = null;\n        if ('anchorKey' in a && !('anchorPath' in a)) p.anchorPath = null;\n        if ('focusPath' in a && !('focusKey' in a)) p.focusKey = null;\n        if ('focusKey' in a && !('focusPath' in a)) p.focusPath = null;\n\n        return p;\n      }\n\n      throw new Error('`Range.createProperties` only accepts objects or ranges, but you passed it: ' + a);\n    }\n\n    /**\n     * Create a `Range` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Range}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$anchorKey = object.anchorKey,\n          anchorKey = _object$anchorKey === undefined ? null : _object$anchorKey,\n          _object$anchorOffset = object.anchorOffset,\n          anchorOffset = _object$anchorOffset === undefined ? 0 : _object$anchorOffset,\n          _object$anchorPath = object.anchorPath,\n          anchorPath = _object$anchorPath === undefined ? null : _object$anchorPath,\n          _object$focusKey = object.focusKey,\n          focusKey = _object$focusKey === undefined ? null : _object$focusKey,\n          _object$focusOffset = object.focusOffset,\n          focusOffset = _object$focusOffset === undefined ? 0 : _object$focusOffset,\n          _object$focusPath = object.focusPath,\n          focusPath = _object$focusPath === undefined ? null : _object$focusPath,\n          _object$isAtomic = object.isAtomic,\n          isAtomic = _object$isAtomic === undefined ? false : _object$isAtomic,\n          _object$isBackward = object.isBackward,\n          isBackward = _object$isBackward === undefined ? null : _object$isBackward,\n          _object$isFocused = object.isFocused,\n          isFocused = _object$isFocused === undefined ? false : _object$isFocused,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? null : _object$marks;\n\n\n      var range = new Range({\n        anchorKey: anchorKey,\n        anchorOffset: anchorOffset,\n        anchorPath: PathUtils.create(anchorPath),\n        focusKey: focusKey,\n        focusOffset: focusOffset,\n        focusPath: PathUtils.create(focusPath),\n        isAtomic: isAtomic,\n        isBackward: isBackward,\n        isFocused: isFocused,\n        marks: marks == null ? null : new immutable.Set(marks.map(Mark.fromJSON))\n      });\n\n      return range;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }, {\n    key: 'isRange',\n\n\n    /**\n     * Check if an `obj` is a `Range`.\n     *\n     * @param {Any} obj\n     * @return {Boolean}\n     */\n\n    value: function isRange(obj) {\n      return !!(obj && obj[MODEL_TYPES.RANGE]);\n    }\n  }]);\n  return Range;\n}(immutable.Record(DEFAULTS$4));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nRange.fromJS = Range.fromJSON;\nRange.prototype[MODEL_TYPES.RANGE] = true;\n\n/**\n * Mix in some \"move\" convenience methods.\n */\n\nvar MOVE_METHODS = [['move', ''], ['move', 'To'], ['move', 'ToStartOf'], ['move', 'ToEndOf']];\n\nMOVE_METHODS.forEach(function (_ref) {\n  var _ref2 = slicedToArray(_ref, 2),\n      p = _ref2[0],\n      s = _ref2[1];\n\n  Range.prototype['' + p + s] = function () {\n    var _ref3;\n\n    return (_ref3 = this[p + 'Anchor' + s].apply(this, arguments))[p + 'Focus' + s].apply(_ref3, arguments);\n  };\n});\n\n/**\n * Mix in the \"start\", \"end\" and \"edge\" convenience methods.\n */\n\nvar EDGE_METHODS = [['has', 'AtStartOf', true], ['has', 'AtEndOf', true], ['has', 'Between', true], ['has', 'In', true], ['collapseTo', ''], ['move', ''], ['moveTo', ''], ['move', 'To'], ['move', 'OffsetTo']];\n\nEDGE_METHODS.forEach(function (_ref4) {\n  var _ref5 = slicedToArray(_ref4, 3),\n      p = _ref5[0],\n      s = _ref5[1],\n      hasEdge = _ref5[2];\n\n  var anchor = p + 'Anchor' + s;\n  var focus = p + 'Focus' + s;\n\n  Range.prototype[p + 'Start' + s] = function () {\n    return this.isBackward ? this[focus].apply(this, arguments) : this[anchor].apply(this, arguments);\n  };\n\n  Range.prototype[p + 'End' + s] = function () {\n    return this.isBackward ? this[anchor].apply(this, arguments) : this[focus].apply(this, arguments);\n  };\n\n  if (hasEdge) {\n    Range.prototype[p + 'Edge' + s] = function () {\n      return this[anchor].apply(this, arguments) || this[focus].apply(this, arguments);\n    };\n  }\n});\n\n/**\n * Mix in some aliases for convenience / parallelism with the browser APIs.\n */\n\nvar ALIAS_METHODS = [['collapseTo', 'moveTo'], ['collapseToAnchor', 'moveToAnchor'], ['collapseToFocus', 'moveToFocus'], ['collapseToStart', 'moveToStart'], ['collapseToEnd', 'moveToEnd'], ['collapseToStartOf', 'moveToStartOf'], ['collapseToEndOf', 'moveToEndOf'], ['extend', 'moveFocus'], ['extendTo', 'moveFocusTo'], ['extendToStartOf', 'moveFocusToStartOf'], ['extendToEndOf', 'moveFocusToEndOf']];\n\nALIAS_METHODS.forEach(function (_ref6) {\n  var _ref7 = slicedToArray(_ref6, 2),\n      alias = _ref7[0],\n      method = _ref7[1];\n\n  Range.prototype[alias] = function () {\n    return this[method].apply(this, arguments);\n  };\n});\n\n/**\n * Get the first text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getFirstText(node) {\n  return node.object == 'text' ? node : node.getFirstText();\n}\n\n/**\n * Get the last text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getLastText(node) {\n  return node.object == 'text' ? node : node.getLastText();\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$5 = {\n  marks: new immutable.Set(),\n  text: ''\n\n  /**\n   * Character.\n   *\n   * @type {Character}\n   */\n\n};\nvar Character = function (_Record) {\n  inherits(Character, _Record);\n\n  function Character() {\n    classCallCheck(this, Character);\n    return possibleConstructorReturn(this, (Character.__proto__ || Object.getPrototypeOf(Character)).apply(this, arguments));\n  }\n\n  createClass(Character, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the character.\n     *\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        text: this.text,\n        marks: this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS() {\n      return this.toJSON();\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'character';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a `Character` with `attrs`.\n     *\n     * @param {Object|String|Character} attrs\n     * @return {Character}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Character.isCharacter(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs == 'string') {\n        attrs = { text: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Character.fromJSON(attrs);\n      }\n\n      throw new Error('`Character.create` only accepts objects, strings or characters, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Characters` from `elements`.\n     *\n     * @param {String|Array<Object|Character|String>|List<Object|Character|String>} elements\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (typeof elements == 'string') {\n        elements = elements.split('');\n      }\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Character.create));\n        return list;\n      }\n\n      throw new Error('`Block.createList` only accepts strings, arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a `Character` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Character}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var text = object.text,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? [] : _object$marks;\n\n\n      if (typeof text != 'string') {\n        throw new Error('`Character.fromJSON` requires a block `text` string.');\n      }\n\n      var character = new Character({\n        text: text,\n        marks: new immutable.Set(marks)\n      });\n\n      return character;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Character`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCharacterList',\n\n\n    /**\n     * Check if `any` is a character list.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isCharacterList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Character.isCharacter(item);\n      });\n    }\n  }]);\n  return Character;\n}(immutable.Record(DEFAULTS$5));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nCharacter.fromJS = Character.fromJSON;\nCharacter.isCharacter = isType.bind(null, 'CHARACTER');\nCharacter.prototype[MODEL_TYPES.CHARACTER] = true;\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$6 = {\n  marks: immutable.Set(),\n  text: ''\n\n  /**\n   * Leaf.\n   *\n   * @type {Leaf}\n   */\n\n};\nvar Leaf = function (_Record) {\n  inherits(Leaf, _Record);\n\n  function Leaf() {\n    classCallCheck(this, Leaf);\n    return possibleConstructorReturn(this, (Leaf.__proto__ || Object.getPrototypeOf(Leaf)).apply(this, arguments));\n  }\n\n  createClass(Leaf, [{\n    key: 'getCharacters',\n\n\n    /**\n     * Return leaf as a list of characters\n     *\n     * @return {List<Character>}\n     */\n\n    value: function getCharacters() {\n      logger.deprecate('slate@0.34.0', 'The `characters` property of Slate objects is deprecated');\n\n      var marks = this.marks;\n\n      var characters = Character.createList(this.text.split('').map(function (char) {\n        return Character.create({\n          text: char,\n          marks: marks\n        });\n      }));\n\n      return characters;\n    }\n\n    /**\n     * Update a `mark` at leaf, replace with newMark\n     *\n     * @param {Mark} mark\n     * @param {Mark} newMark\n     * @returns {Leaf}\n     */\n\n  }, {\n    key: 'updateMark',\n    value: function updateMark(mark, newMark) {\n      var marks = this.marks;\n\n      if (newMark.equals(mark)) return this;\n      if (!marks.has(mark)) return this;\n      var newMarks = marks.withMutations(function (collection) {\n        collection.remove(mark).add(newMark);\n      });\n      return this.set('marks', newMarks);\n    }\n\n    /**\n     * Add a `set` of marks at `index` and `length`.\n     *\n     * @param {Set<Mark>} set\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'addMarks',\n    value: function addMarks(set$$1) {\n      var marks = this.marks;\n\n      return this.set('marks', marks.union(set$$1));\n    }\n\n    /**\n     * Remove a `mark` at `index` and `length`.\n     *\n     * @param {Mark} mark\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(mark) {\n      var marks = this.marks;\n\n      return this.set('marks', marks.remove(mark));\n    }\n\n    /**\n     * Return a JSON representation of the leaf.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        text: this.text,\n        marks: this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS() {\n      return this.toJSON();\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'leaf';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Leaf` with `attrs`.\n     *\n     * @param {Object|Leaf} attrs\n     * @return {Leaf}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Leaf.isLeaf(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs == 'string') {\n        attrs = { text: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Leaf.fromJSON(attrs);\n      }\n\n      throw new Error('`Leaf.create` only accepts objects, strings or leaves, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a valid List of `Leaf` from `leaves`\n     *\n     * @param {List<Leaf>} leaves\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'createLeaves',\n    value: function createLeaves(leaves) {\n      if (leaves.size <= 1) return leaves;\n\n      var invalid = false;\n\n      // TODO: we can make this faster with [List] and then flatten\n      var result = immutable.List().withMutations(function (cache) {\n        // Search from the leaves left end to find invalid node;\n        leaves.findLast(function (leaf, index) {\n          var firstLeaf = cache.first();\n\n          // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\n          if (firstLeaf) {\n            // If marks equals, then the two leaves can be connected\n            if (firstLeaf.marks.equals(leaf.marks)) {\n              invalid = true;\n              cache.set(0, firstLeaf.set('text', '' + leaf.text + firstLeaf.text));\n              return;\n            }\n\n            // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\n            if (firstLeaf.text === '') {\n              invalid = true;\n              cache.set(0, leaf);\n              return;\n            }\n\n            // If the current leaf is empty, drop the leaf\n            if (leaf.text === '') {\n              invalid = true;\n              return;\n            }\n          }\n\n          cache.unshift(leaf);\n        });\n      });\n\n      if (!invalid) return leaves;\n      return result;\n    }\n\n    /**\n     * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\n     * Corner Cases:\n     *   1. if offset is smaller than 0, then return [List(), leaves]\n     *   2. if offset is bigger than the text length, then return [leaves, List()]\n     *\n     * @param {List<Leaf> leaves\n     * @return {Array<List<Leaf>>}\n     */\n\n  }, {\n    key: 'splitLeaves',\n    value: function splitLeaves(leaves, offset) {\n      if (offset < 0) return [immutable.List(), leaves];\n\n      if (leaves.size === 0) {\n        return [immutable.List(), immutable.List()];\n      }\n\n      var endOffset = 0;\n      var index = -1;\n      var left = void 0,\n          right = void 0;\n\n      leaves.find(function (leaf) {\n        index++;\n        var startOffset = endOffset;\n        var text = leaf.text;\n\n        endOffset += text.length;\n\n        if (endOffset < offset) return false;\n        if (startOffset > offset) return false;\n\n        var length = offset - startOffset;\n        left = leaf.set('text', text.slice(0, length));\n        right = leaf.set('text', text.slice(length));\n        return true;\n      });\n\n      if (!left) return [leaves, immutable.List()];\n\n      if (left.text === '') {\n        if (index === 0) {\n          return [immutable.List.of(left), leaves];\n        }\n\n        return [leaves.take(index), leaves.skip(index)];\n      }\n\n      if (right.text === '') {\n        if (index === leaves.size - 1) {\n          return [leaves, immutable.List.of(right)];\n        }\n\n        return [leaves.take(index + 1), leaves.skip(index + 1)];\n      }\n\n      return [leaves.take(index).push(left), leaves.skip(index + 1).unshift(right)];\n    }\n\n    /**\n     * Create a `Leaf` list from `attrs`.\n     *\n     * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(attrs) || Array.isArray(attrs)) {\n        var list = new immutable.List(attrs.map(Leaf.create));\n        return list;\n      }\n\n      throw new Error('`Leaf.createList` only accepts arrays or lists, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Leaf` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Leaf}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$text = object.text,\n          text = _object$text === undefined ? '' : _object$text,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? [] : _object$marks;\n\n\n      var leaf = new Leaf({\n        text: text,\n        marks: immutable.Set(marks.map(Mark.fromJSON))\n      });\n\n      return leaf;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Leaf`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafList',\n\n\n    /**\n     * Check if `any` is a list of leaves.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isLeafList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Leaf.isLeaf(item);\n      });\n    }\n  }]);\n  return Leaf;\n}(immutable.Record(DEFAULTS$6));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nLeaf.fromJS = Leaf.fromJSON;\nLeaf.isLeaf = isType.bind(null, 'LEAF');\nLeaf.prototype[MODEL_TYPES.LEAF] = true;\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$7 = {\n  leaves: immutable.List(),\n  key: undefined\n\n  /**\n   * Text.\n   *\n   * @type {Text}\n   */\n\n};\nvar Text = function (_Record) {\n  inherits(Text, _Record);\n\n  function Text() {\n    classCallCheck(this, Text);\n    return possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).apply(this, arguments));\n  }\n\n  createClass(Text, [{\n    key: 'getString',\n\n\n    /**\n     * Get the concatenated text of the node, cached for text getter\n     *\n     * @returns {String}\n     */\n\n    value: function getString() {\n      return this.leaves.reduce(function (string, leaf) {\n        return string + leaf.text;\n      }, '');\n    }\n\n    /**\n     * Get the concatenated characters of the node;\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'searchLeafAtOffset',\n\n\n    /**\n     * Find the 'first' leaf at offset; By 'first' the alorighthm prefers `endOffset === offset` than `startOffset === offset`\n     * Corner Cases:\n     *   1. if offset is negative, return the first leaf;\n     *   2. if offset is larger than text length, the leaf is null, startOffset, endOffset and index is of the last leaf\n     *\n     * @param {number}\n     * @returns {Object}\n     *   @property {number} startOffset\n     *   @property {number} endOffset\n     *   @property {number} index\n     *   @property {Leaf} leaf\n     */\n\n    value: function searchLeafAtOffset(offset) {\n      var endOffset = 0;\n      var startOffset = 0;\n      var index = -1;\n\n      var leaf = this.leaves.find(function (l) {\n        index++;\n        startOffset = endOffset;\n        endOffset = startOffset + l.text.length;\n        return endOffset >= offset;\n      });\n\n      return {\n        leaf: leaf,\n        endOffset: endOffset,\n        index: index,\n        startOffset: startOffset\n      };\n    }\n\n    /**\n     * Add a `mark` at `index` and `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Mark} mark\n     * @return {Text}\n     */\n\n  }, {\n    key: 'addMark',\n    value: function addMark(index, length, mark) {\n      var marks = immutable.Set.of(mark);\n      return this.addMarks(index, length, marks);\n    }\n\n    /**\n     * Add a `set` of marks at `index` and `length`.\n     * Corner Cases:\n     *   1. If empty text, and if length === 0 and index === 0, will make sure the text contain an empty leaf with the given mark.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Set<Mark>} set\n     * @return {Text}\n     */\n\n  }, {\n    key: 'addMarks',\n    value: function addMarks(index, length, set$$1) {\n      if (this.text === '' && length === 0 && index === 0) {\n        var _leaves = this.leaves;\n\n        var first = _leaves.first();\n\n        if (!first) {\n          return this.set('leaves', immutable.List.of(Leaf.fromJSON({ text: '', marks: set$$1 })));\n        }\n\n        var newFirst = first.addMarks(set$$1);\n        if (newFirst === first) return this;\n        return this.set('leaves', immutable.List.of(newFirst));\n      }\n\n      if (this.text === '') return this;\n      if (length === 0) return this;\n      if (index >= this.text.length) return this;\n\n      var _Leaf$splitLeaves = Leaf.splitLeaves(this.leaves, index),\n          _Leaf$splitLeaves2 = slicedToArray(_Leaf$splitLeaves, 2),\n          before = _Leaf$splitLeaves2[0],\n          bundle = _Leaf$splitLeaves2[1];\n\n      var _Leaf$splitLeaves3 = Leaf.splitLeaves(bundle, length),\n          _Leaf$splitLeaves4 = slicedToArray(_Leaf$splitLeaves3, 2),\n          middle = _Leaf$splitLeaves4[0],\n          after = _Leaf$splitLeaves4[1];\n\n      var leaves = before.concat(middle.map(function (x) {\n        return x.addMarks(set$$1);\n      }), after);\n      return this.setLeaves(leaves);\n    }\n\n    /**\n     * Get the decorations for the node from a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getDecorations',\n    value: function getDecorations(schema) {\n      return schema.__getDecorations(this);\n    }\n\n    /**\n     * Derive the leaves for a list of `decorations`.\n     *\n     * @param {Array|Void} decorations (optional)\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'getLeaves',\n    value: function getLeaves() {\n      var _this2 = this;\n\n      var decorations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var leaves = this.leaves;\n\n      if (leaves.size === 0) return immutable.List.of(Leaf.create({}));\n      if (!decorations || decorations.length === 0) return leaves;\n      if (this.text.length === 0) return leaves;\n      var key = this.key;\n\n\n      decorations.forEach(function (range) {\n        var startKey = range.startKey,\n            endKey = range.endKey,\n            startOffset = range.startOffset,\n            endOffset = range.endOffset,\n            marks = range.marks;\n\n        var hasStart = startKey == key;\n        var hasEnd = endKey == key;\n\n        if (hasStart && hasEnd) {\n          var index = hasStart ? startOffset : 0;\n          var length = hasEnd ? endOffset - index : _this2.text.length - index;\n\n          if (length < 1) return;\n          if (index >= _this2.text.length) return;\n\n          if (index !== 0 || length < _this2.text.length) {\n            var _Leaf$splitLeaves5 = Leaf.splitLeaves(leaves, index),\n                _Leaf$splitLeaves6 = slicedToArray(_Leaf$splitLeaves5, 2),\n                before = _Leaf$splitLeaves6[0],\n                bundle = _Leaf$splitLeaves6[1];\n\n            var _Leaf$splitLeaves7 = Leaf.splitLeaves(bundle, length),\n                _Leaf$splitLeaves8 = slicedToArray(_Leaf$splitLeaves7, 2),\n                middle = _Leaf$splitLeaves8[0],\n                after = _Leaf$splitLeaves8[1];\n\n            leaves = before.concat(middle.map(function (x) {\n              return x.addMarks(marks);\n            }), after);\n            return;\n          }\n        }\n\n        leaves = leaves.map(function (x) {\n          return x.addMarks(marks);\n        });\n      });\n\n      if (leaves === this.leaves) return leaves;\n      return Leaf.createLeaves(leaves);\n    }\n\n    /**\n     * Get all of the active marks on between two offsets\n     * Corner Cases:\n     *   1. if startOffset is equal or bigger than endOffset, then return Set();\n     *   2. If no text is selected between start and end, then return Set()\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getActiveMarksBetweenOffsets',\n    value: function getActiveMarksBetweenOffsets(startOffset, endOffset) {\n      if (startOffset <= 0 && endOffset >= this.text.length) {\n        return this.getActiveMarks();\n      }\n\n      if (startOffset >= endOffset) return immutable.Set();\n      // For empty text in a paragraph, use getActiveMarks;\n      if (this.text === '') return this.getActiveMarks();\n\n      var result = null;\n      var leafEnd = 0;\n\n      this.leaves.forEach(function (leaf) {\n        var leafStart = leafEnd;\n        leafEnd = leafStart + leaf.text.length;\n\n        if (leafEnd <= startOffset) return;\n        if (leafStart >= endOffset) return false;\n\n        if (!result) {\n          result = leaf.marks;\n          return;\n        }\n\n        result = result.intersect(leaf.marks);\n        if (result && result.size === 0) return false;\n        return false;\n      });\n\n      return result || immutable.Set();\n    }\n\n    /**\n     * Get all of the active marks on the text\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getActiveMarks',\n    value: function getActiveMarks() {\n      var _this3 = this;\n\n      if (this.leaves.size === 0) return immutable.Set();\n\n      var result = this.leaves.first().marks;\n      if (result.size === 0) return result;\n\n      return result.withMutations(function (x) {\n        _this3.leaves.forEach(function (c) {\n          x.intersect(c.marks);\n          if (x.size === 0) return false;\n        });\n      });\n    }\n  }, {\n    key: 'getFirstText',\n    value: function getFirstText() {\n      return this;\n    }\n  }, {\n    key: 'getLastText',\n    value: function getLastText() {\n      return this;\n    }\n\n    /**\n     * Get all of the marks on between two offsets\n     * Corner Cases:\n     *   1. if startOffset is equal or bigger than endOffset, then return Set();\n     *   2. If no text is selected between start and end, then return Set()\n     *\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarksBetweenOffsets',\n    value: function getMarksBetweenOffsets(startOffset, endOffset) {\n      if (startOffset <= 0 && endOffset >= this.text.length) {\n        return this.getMarks();\n      }\n\n      if (startOffset >= endOffset) return immutable.Set();\n      // For empty text in a paragraph, use getActiveMarks;\n      if (this.text === '') return this.getActiveMarks();\n\n      var result = null;\n      var leafEnd = 0;\n\n      this.leaves.forEach(function (leaf) {\n        var leafStart = leafEnd;\n        leafEnd = leafStart + leaf.text.length;\n\n        if (leafEnd <= startOffset) return;\n        if (leafStart >= endOffset) return false;\n\n        if (!result) {\n          result = leaf.marks;\n          return;\n        }\n\n        result = result.union(leaf.marks);\n      });\n\n      return result || immutable.Set();\n    }\n\n    /**\n     * Get all of the marks on the text.\n     *\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarks',\n    value: function getMarks() {\n      var array = this.getMarksAsArray();\n      return new immutable.OrderedSet(array);\n    }\n\n    /**\n     * Get all of the marks on the text as an array\n     *\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getMarksAsArray',\n    value: function getMarksAsArray() {\n      if (this.leaves.size === 0) return [];\n      var first = this.leaves.first().marks;\n      if (this.leaves.size === 1) return first.toArray();\n\n      var result = [];\n\n      this.leaves.forEach(function (leaf) {\n        result.push(leaf.marks.toArray());\n      });\n\n      return Array.prototype.concat.apply(first.toArray(), result);\n    }\n\n    /**\n     * Get the marks on the text at `index`.\n     * Corner Cases:\n     *   1. if no text is before the index, and index !== 0, then return Set()\n     *   2. (for insert after split node or mark at range) if index === 0, and text === '', then return the leaf.marks\n     *   3. if index === 0, text !== '', return Set()\n     *\n     *\n     * @param {Number} index\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getMarksAtIndex',\n    value: function getMarksAtIndex(index) {\n      var _searchLeafAtOffset = this.searchLeafAtOffset(index),\n          leaf = _searchLeafAtOffset.leaf;\n\n      if (!leaf) return immutable.Set();\n      return leaf.marks;\n    }\n\n    /**\n     * Get a node by `key`, to parallel other nodes.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNode',\n    value: function getNode(key) {\n      return this.key == key ? this : null;\n    }\n\n    /**\n     * Check if the node has a node by `key`, to parallel other nodes.\n     *\n     * @param {String} key\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasNode',\n    value: function hasNode(key) {\n      return !!this.getNode(key);\n    }\n\n    /**\n     * Insert `text` at `index`.\n     *\n     * @param {Numbder} offset\n     * @param {String} text\n     * @param {Set} marks (optional)\n     * @return {Text}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(offset, text, marks) {\n      if (this.text === '') {\n        return this.set('leaves', immutable.List.of(Leaf.create({ text: text, marks: marks })));\n      }\n\n      if (text.length === 0) return this;\n      if (!marks) marks = immutable.Set();\n\n      var _searchLeafAtOffset2 = this.searchLeafAtOffset(offset),\n          startOffset = _searchLeafAtOffset2.startOffset,\n          leaf = _searchLeafAtOffset2.leaf,\n          index = _searchLeafAtOffset2.index;\n\n      var delta = offset - startOffset;\n      var beforeText = leaf.text.slice(0, delta);\n      var afterText = leaf.text.slice(delta);\n      var leaves = this.leaves;\n\n\n      if (leaf.marks.equals(marks)) {\n        return this.set('leaves', leaves.set(index, leaf.set('text', beforeText + text + afterText)));\n      }\n\n      var nextLeaves = leaves.splice(index, 1, leaf.set('text', beforeText), Leaf.create({ text: text, marks: marks }), leaf.set('text', afterText));\n\n      return this.setLeaves(nextLeaves);\n    }\n\n    /**\n     * Regenerate the node's key.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'regenerateKey',\n    value: function regenerateKey() {\n      var key = KeyUtils.create();\n      return this.set('key', key);\n    }\n\n    /**\n     * Remove a `mark` at `index` and `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Mark} mark\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(index, length, mark) {\n      if (this.text === '' && index === 0 && length === 0) {\n        var first = this.leaves.first();\n        if (!first) return this;\n        var newFirst = first.removeMark(mark);\n        if (newFirst === first) return this;\n        return this.set('leaves', immutable.List.of(newFirst));\n      }\n\n      if (length <= 0) return this;\n      if (index >= this.text.length) return this;\n\n      var _Leaf$splitLeaves9 = Leaf.splitLeaves(this.leaves, index),\n          _Leaf$splitLeaves10 = slicedToArray(_Leaf$splitLeaves9, 2),\n          before = _Leaf$splitLeaves10[0],\n          bundle = _Leaf$splitLeaves10[1];\n\n      var _Leaf$splitLeaves11 = Leaf.splitLeaves(bundle, length),\n          _Leaf$splitLeaves12 = slicedToArray(_Leaf$splitLeaves11, 2),\n          middle = _Leaf$splitLeaves12[0],\n          after = _Leaf$splitLeaves12[1];\n\n      var leaves = before.concat(middle.map(function (x) {\n        return x.removeMark(mark);\n      }), after);\n      return this.setLeaves(leaves);\n    }\n\n    /**\n     * Remove text from the text node at `start` for `length`.\n     *\n     * @param {Number} start\n     * @param {Number} length\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(start, length) {\n      if (length <= 0) return this;\n      if (start >= this.text.length) return this;\n\n      // PERF: For simple backspace, we can operate directly on the leaf\n      if (length === 1) {\n        var _searchLeafAtOffset3 = this.searchLeafAtOffset(start + 1),\n            leaf = _searchLeafAtOffset3.leaf,\n            index = _searchLeafAtOffset3.index,\n            startOffset = _searchLeafAtOffset3.startOffset;\n\n        var offset = start - startOffset;\n\n        if (leaf) {\n          if (leaf.text.length === 1) {\n            var _leaves2 = this.leaves.remove(index);\n            return this.setLeaves(_leaves2);\n          }\n\n          var beforeText = leaf.text.slice(0, offset);\n          var afterText = leaf.text.slice(offset + length);\n          var text = beforeText + afterText;\n\n          if (text.length > 0) {\n            return this.set('leaves', this.leaves.set(index, leaf.set('text', text)));\n          }\n        }\n      }\n\n      var _Leaf$splitLeaves13 = Leaf.splitLeaves(this.leaves, start),\n          _Leaf$splitLeaves14 = slicedToArray(_Leaf$splitLeaves13, 2),\n          before = _Leaf$splitLeaves14[0],\n          bundle = _Leaf$splitLeaves14[1];\n\n      var after = Leaf.splitLeaves(bundle, length)[1];\n      var leaves = Leaf.createLeaves(before.concat(after));\n\n      if (leaves.size === 1) {\n        var first = leaves.first();\n\n        if (first.text === '') {\n          return this.set('leaves', immutable.List.of(first.set('marks', this.getActiveMarks())));\n        }\n      }\n\n      return this.set('leaves', leaves);\n    }\n\n    /**\n     * Return a JSON representation of the text.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        leaves: this.getLeaves().toArray().map(function (r) {\n          return r.toJSON();\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS(options) {\n      return this.toJSON(options);\n    }\n\n    /**\n     * Update a `mark` at `index` and `length` with `properties`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Mark} mark\n     * @param {Object} properties\n     * @return {Text}\n     */\n\n  }, {\n    key: 'updateMark',\n    value: function updateMark(index, length, mark, properties) {\n      var newMark = mark.merge(properties);\n\n      if (this.text === '' && length === 0 && index === 0) {\n        var _leaves3 = this.leaves;\n\n        var first = _leaves3.first();\n        if (!first) return this;\n        var newFirst = first.updateMark(mark, newMark);\n        if (newFirst === first) return this;\n        return this.set('leaves', immutable.List.of(newFirst));\n      }\n\n      if (length <= 0) return this;\n      if (index >= this.text.length) return this;\n\n      var _Leaf$splitLeaves15 = Leaf.splitLeaves(this.leaves, index),\n          _Leaf$splitLeaves16 = slicedToArray(_Leaf$splitLeaves15, 2),\n          before = _Leaf$splitLeaves16[0],\n          bundle = _Leaf$splitLeaves16[1];\n\n      var _Leaf$splitLeaves17 = Leaf.splitLeaves(bundle, length),\n          _Leaf$splitLeaves18 = slicedToArray(_Leaf$splitLeaves17, 2),\n          middle = _Leaf$splitLeaves18[0],\n          after = _Leaf$splitLeaves18[1];\n\n      var leaves = before.concat(middle.map(function (x) {\n        return x.updateMark(mark, newMark);\n      }), after);\n\n      return this.setLeaves(leaves);\n    }\n\n    /**\n     * Split this text and return two different texts\n     * @param {Number} position\n     * @returns {Array<Text>}\n     */\n\n  }, {\n    key: 'splitText',\n    value: function splitText(offset) {\n      var splitted = Leaf.splitLeaves(this.leaves, offset);\n      var one = this.set('leaves', splitted[0]);\n      var two = this.set('leaves', splitted[1]).regenerateKey();\n      return [one, two];\n    }\n\n    /**\n     * merge this text and another text at the end\n     * @param {Text} text\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'mergeText',\n    value: function mergeText(text) {\n      var leaves = this.leaves.concat(text.leaves);\n      return this.setLeaves(leaves);\n    }\n\n    /**\n     * Normalize the text node with a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Function|Void}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(schema) {\n      return schema.normalizeNode(this);\n    }\n\n    /**\n     * Validate the text node against a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Error|Void}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(schema) {\n      return schema.validateNode(this);\n    }\n\n    /**\n     * Get the first invalid descendant\n     * PERF: Do not cache this method; because it can cause cycle reference\n     *\n     * @param {Schema} schema\n     * @returns {Text|Null}\n     */\n\n  }, {\n    key: 'getFirstInvalidDescendant',\n    value: function getFirstInvalidDescendant(schema) {\n      return this.validate(schema) ? this : null;\n    }\n\n    /**\n     * Set leaves with normalized `leaves`\n     *\n     * @param {Schema} schema\n     * @returns {Text|Null}\n     */\n\n  }, {\n    key: 'setLeaves',\n    value: function setLeaves(leaves) {\n      var result = Leaf.createLeaves(leaves);\n\n      if (result.size === 1) {\n        var first = result.first();\n\n        if (!first.marks || first.marks.size === 0) {\n          if (first.text === '') {\n            return this.set('leaves', immutable.List());\n          }\n        }\n      }\n\n      return this.set('leaves', Leaf.createLeaves(leaves));\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'text';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n\n    /**\n     * Is the node empty?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get$$1() {\n      return this.text == '';\n    }\n\n    /**\n     * Get the concatenated text of the node.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get$$1() {\n      return this.getString();\n    }\n  }, {\n    key: 'characters',\n    get: function get$$1() {\n      return this.leaves.flatMap(function (x) {\n        return x.getCharacters();\n      });\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Text` with `attrs`.\n     *\n     * @param {Object|Array|List|String|Text} attrs\n     * @return {Text}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      if (Text.isText(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs == 'string') {\n        attrs = { leaves: [{ text: attrs }] };\n      }\n\n      if (isPlainObject(attrs)) {\n        if (attrs.text) {\n          var _attrs = attrs,\n              text = _attrs.text,\n              marks = _attrs.marks,\n              key = _attrs.key;\n\n          attrs = { key: key, leaves: [{ text: text, marks: marks }] };\n        }\n\n        return Text.fromJSON(attrs);\n      }\n\n      throw new Error('`Text.create` only accepts objects, arrays, strings or texts, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Texts` from `elements`.\n     *\n     * @param {Array<Text|Object>|List<Text|Object>} elements\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Text.create));\n        return list;\n      }\n\n      throw new Error('`Text.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a `Text` from a JSON `object`.\n     *\n     * @param {Object|Text} object\n     * @return {Text}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Text.isText(object)) {\n        return object;\n      }\n\n      var _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key;\n      var leaves = object.leaves;\n\n\n      if (!leaves) {\n        if (object.ranges) {\n          logger.deprecate('slate@0.27.0', 'The `ranges` property of Slate objects has been renamed to `leaves`.');\n\n          leaves = object.ranges;\n        } else {\n          leaves = immutable.List();\n        }\n      }\n\n      if (Array.isArray(leaves)) {\n        leaves = immutable.List(leaves.map(function (x) {\n          return Leaf.create(x);\n        }));\n      } else if (immutable.List.isList(leaves)) {\n        leaves = leaves.map(function (x) {\n          return Leaf.create(x);\n        });\n      } else {\n        throw new Error('leaves must be either Array or Immutable.List');\n      }\n\n      var node = new Text({\n        leaves: Leaf.createLeaves(leaves),\n        key: key\n      });\n\n      return node;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `Text`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isTextList',\n\n\n    /**\n     * Check if `any` is a list\u00a0of texts.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isTextList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Text.isText(item);\n      });\n    }\n  }]);\n  return Text;\n}(immutable.Record(DEFAULTS$7));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nText.fromJS = Text.fromJSON;\nText.isText = isType.bind(null, 'TEXT');\nText.prototype[MODEL_TYPES.TEXT] = true;\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Text.prototype, ['getDecorations', 'getActiveMarks', 'getMarks', 'getMarksAsArray', 'normalize', 'validate', 'getString']);\n\n/**\n * Node.\n *\n * And interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Node}\n */\n\nvar Node = function () {\n  function Node() {\n    classCallCheck(this, Node);\n  }\n\n  createClass(Node, [{\n    key: 'addMark',\n\n\n    /**\n     * Add mark to text at `offset` and `length` in node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {Number} length\n     * @param {Mark} mark\n     * @return {Node}\n     */\n\n    value: function addMark(path, offset, length, mark) {\n      var node = this.assertDescendant(path);\n      path = this.resolvePath(path);\n      node = node.addMark(offset, length, mark);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n\n    /**\n     * Recursively filter all descendant nodes with `iterator`.\n     *\n     * @param {Function} iterator\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'filterDescendants',\n    value: function filterDescendants(iterator) {\n      var matches = [];\n\n      this.forEachDescendant(function (node, i, nodes) {\n        if (iterator(node, i, nodes)) matches.push(node);\n      });\n\n      return immutable.List(matches);\n    }\n\n    /**\n     * Recursively find all descendant nodes by `iterator`.\n     *\n     * @param {Function} iterator\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'findDescendant',\n    value: function findDescendant(iterator) {\n      var found = null;\n\n      this.forEachDescendant(function (node, i, nodes) {\n        if (iterator(node, i, nodes)) {\n          found = node;\n          return false;\n        }\n      });\n\n      return found;\n    }\n\n    /**\n     * Recursively iterate over all descendant nodes with `iterator`. If the\n     * iterator returns false it will break the loop.\n     *\n     * @param {Function} iterator\n     */\n\n  }, {\n    key: 'forEachDescendant',\n    value: function forEachDescendant(iterator) {\n      var ret = void 0;\n\n      this.nodes.forEach(function (child, i, nodes) {\n        if (iterator(child, i, nodes) === false) {\n          ret = false;\n          return false;\n        }\n\n        if (child.object != 'text') {\n          ret = child.forEachDescendant(iterator);\n          return ret;\n        }\n      });\n\n      return ret;\n    }\n\n    /**\n     * Get a set of the active marks in a `range`.\n     *\n     * @param {Range} range\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getActiveMarksAtRange',\n    value: function getActiveMarksAtRange(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return immutable.Set();\n\n      if (range.isCollapsed) {\n        var _range = range,\n            _startKey = _range.startKey,\n            _startOffset = _range.startOffset;\n\n        return this.getMarksAtPosition(_startKey, _startOffset).toSet();\n      }\n\n      var _range2 = range,\n          startKey = _range2.startKey,\n          endKey = _range2.endKey,\n          startOffset = _range2.startOffset,\n          endOffset = _range2.endOffset;\n\n      var startText = this.getDescendant(startKey);\n\n      if (startKey !== endKey) {\n        while (startKey !== endKey && endOffset === 0) {\n          var _endText = this.getPreviousText(endKey);\n          endKey = _endText.key;\n          endOffset = _endText.text.length;\n        }\n\n        while (startKey !== endKey && startOffset === startText.text.length) {\n          startText = this.getNextText(startKey);\n          startKey = startText.key;\n          startOffset = 0;\n        }\n      }\n\n      if (startKey === endKey) {\n        return startText.getActiveMarksBetweenOffsets(startOffset, endOffset);\n      }\n\n      var startMarks = startText.getActiveMarksBetweenOffsets(startOffset, startText.text.length);\n      if (startMarks.size === 0) return immutable.Set();\n      var endText = this.getDescendant(endKey);\n      var endMarks = endText.getActiveMarksBetweenOffsets(0, endOffset);\n      var marks = startMarks.intersect(endMarks);\n      // If marks is already empty, the active marks is empty\n      if (marks.size === 0) return marks;\n\n      var text = this.getNextText(startKey);\n\n      while (text.key !== endKey) {\n        if (text.text.length !== 0) {\n          marks = marks.intersect(text.getActiveMarks());\n          if (marks.size === 0) return immutable.Set();\n        }\n\n        text = this.getNextText(text.key);\n      }\n      return marks;\n    }\n\n    /**\n     * Get a list of the ancestors of a descendant.\n     *\n     * @param {List|String} path\n     * @return {List<Node>|Null}\n     */\n\n  }, {\n    key: 'getAncestors',\n    value: function getAncestors(path) {\n      var _this = this;\n\n      path = this.resolvePath(path);\n      if (!path) return null;\n\n      var ancestors = [];\n\n      path.forEach(function (p, i) {\n        var current = path.slice(0, i);\n        var parent = _this.getNode(current);\n        ancestors.push(parent);\n      });\n\n      return immutable.List(ancestors);\n    }\n\n    /**\n     * Get the leaf block descendants of the node.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocks',\n    value: function getBlocks() {\n      var array = this.getBlocksAsArray();\n      return new immutable.List(array);\n    }\n\n    /**\n     * Get the leaf block descendants of the node.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocksAsArray',\n    value: function getBlocksAsArray() {\n      return this.nodes.reduce(function (array, child) {\n        if (child.object != 'block') return array;\n        if (!child.isLeafBlock()) return array.concat(child.getBlocksAsArray());\n        array.push(child);\n        return array;\n      }, []);\n    }\n\n    /**\n     * Get the leaf block descendants in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocksAtRange',\n    value: function getBlocksAtRange(range) {\n      var array = this.getBlocksAtRangeAsArray(range);\n      // Eliminate duplicates by converting to an `OrderedSet` first.\n      return new immutable.List(new immutable.OrderedSet(array));\n    }\n\n    /**\n     * Get the leaf block descendants in a `range` as an array\n     *\n     * @param {Range} range\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getBlocksAtRangeAsArray',\n    value: function getBlocksAtRangeAsArray(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return [];\n\n      var _range3 = range,\n          startKey = _range3.startKey,\n          endKey = _range3.endKey;\n\n      var startBlock = this.getClosestBlock(startKey);\n\n      // PERF: the most common case is when the range is in a single block node,\n      // where we can avoid a lot of iterating of the tree.\n      if (startKey === endKey) return [startBlock];\n\n      var endBlock = this.getClosestBlock(endKey);\n      var blocks = this.getBlocksAsArray();\n      var start = blocks.indexOf(startBlock);\n      var end = blocks.indexOf(endBlock);\n      return blocks.slice(start, end + 1);\n    }\n\n    /**\n     * Get all of the leaf blocks that match a `type`.\n     *\n     * @param {String} type\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocksByType',\n    value: function getBlocksByType(type) {\n      var array = this.getBlocksByTypeAsArray(type);\n      return new immutable.List(array);\n    }\n\n    /**\n     * Get all of the leaf blocks that match a `type` as an array\n     *\n     * @param {String} type\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getBlocksByTypeAsArray',\n    value: function getBlocksByTypeAsArray(type) {\n      return this.nodes.reduce(function (array, node) {\n        if (node.object != 'block') {\n          return array;\n        } else if (node.isLeafBlock() && node.type == type) {\n          array.push(node);\n          return array;\n        } else {\n          return array.concat(node.getBlocksByTypeAsArray(type));\n        }\n      }, []);\n    }\n\n    /**\n     * Get all of the characters for every text node.\n     *\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'getCharacters',\n    value: function getCharacters() {\n      var characters = this.getTexts().flatMap(function (t) {\n        return t.characters;\n      });\n      return characters;\n    }\n\n    /**\n     * Get a list of the characters in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'getCharactersAtRange',\n    value: function getCharactersAtRange(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return immutable.List();\n      var _range4 = range,\n          startKey = _range4.startKey,\n          endKey = _range4.endKey,\n          startOffset = _range4.startOffset,\n          endOffset = _range4.endOffset;\n\n\n      if (startKey === endKey) {\n        var endText = this.getDescendant(endKey);\n        return endText.characters.slice(startOffset, endOffset);\n      }\n\n      return this.getTextsAtRange(range).flatMap(function (t) {\n        if (t.key === startKey) {\n          return t.characters.slice(startOffset);\n        }\n\n        if (t.key === endKey) {\n          return t.characters.slice(0, endOffset);\n        }\n        return t.characters;\n      });\n    }\n\n    /**\n     * Get a child node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getChild',\n    value: function getChild(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      var child = path.size === 1 ? this.nodes.get(path.first()) : null;\n      return child;\n    }\n\n    /**\n     * Get closest parent of node that matches an `iterator`.\n     *\n     * @param {List|String} path\n     * @param {Function} iterator\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosest',\n    value: function getClosest(path, iterator) {\n      var _this2 = this;\n\n      var ancestors = this.getAncestors(path);\n      if (!ancestors) return null;\n\n      var closest = ancestors.findLast(function (node) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        // We never want to include the top-level node.\n        if (node === _this2) return false;\n        return iterator.apply(undefined, [node].concat(args));\n      });\n\n      return closest || null;\n    }\n\n    /**\n     * Get the closest block parent of a node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestBlock',\n    value: function getClosestBlock(path) {\n      var closest = this.getClosest(path, function (n) {\n        return n.object === 'block';\n      });\n      return closest;\n    }\n\n    /**\n     * Get the closest inline parent of a node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestInline',\n    value: function getClosestInline(path) {\n      var closest = this.getClosest(path, function (n) {\n        return n.object === 'inline';\n      });\n      return closest;\n    }\n\n    /**\n     * Get the closest void parent of a node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestVoid',\n    value: function getClosestVoid(path) {\n      var closest = this.getClosest(path, function (p) {\n        return p.isVoid;\n      });\n      return closest;\n    }\n\n    /**\n     * Get the common ancestor of nodes `a` and `b`.\n     *\n     * @param {List} a\n     * @param {List} b\n     * @return {Node}\n     */\n\n  }, {\n    key: 'getCommonAncestor',\n    value: function getCommonAncestor(a, b) {\n      a = this.resolvePath(a);\n      b = this.resolvePath(b);\n      if (!a || !b) return null;\n\n      var path = PathUtils.relate(a, b);\n      var node = this.getNode(path);\n      return node;\n    }\n\n    /**\n     * Get the decorations for the node from a `stack`.\n     *\n     * @param {Stack} stack\n     * @return {List}\n     */\n\n  }, {\n    key: 'getDecorations',\n    value: function getDecorations(stack) {\n      var decorations = stack.find('decorateNode', this);\n      var list = Range.createList(decorations || []);\n      return list;\n    }\n\n    /**\n     * Get the depth of a descendant, with optional `startAt`.\n     *\n     * @param {List|String} path\n     * @param {Number} startAt\n     * @return {Number|Null}\n     */\n\n  }, {\n    key: 'getDepth',\n    value: function getDepth(path) {\n      var startAt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      path = this.resolvePath(path);\n      if (!path) return null;\n\n      var node = this.getNode(path);\n      var depth = node ? path.size - 1 + startAt : null;\n      return depth;\n    }\n\n    /**\n     * Get a descendant node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getDescendant',\n    value: function getDescendant(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n\n      var array = path.toArray();\n      var descendant = this;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var index = _step.value;\n\n          if (!descendant) return null;\n          if (!descendant.nodes) return null;\n          descendant = descendant.nodes.get(index);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return descendant;\n    }\n\n    /**\n     * Get the first invalid descendant\n     *\n     * @param {Schema} schema\n     * @return {Node|Text|Null}\n     */\n\n  }, {\n    key: 'getFirstInvalidDescendant',\n    value: function getFirstInvalidDescendant(schema) {\n      var result = null;\n\n      this.nodes.find(function (n) {\n        result = n.validate(schema) ? n : n.getFirstInvalidDescendant(schema);\n        return result;\n      });\n\n      return result;\n    }\n\n    /**\n     * Get the first child text node.\n     *\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFirstText',\n    value: function getFirstText() {\n      var descendant = null;\n\n      var found = this.nodes.find(function (node) {\n        if (node.object === 'text') return true;\n        descendant = node.getFirstText();\n        return !!descendant;\n      });\n\n      return descendant || found;\n    }\n\n    /**\n     * Get a fragment of the node at a `range`.\n     *\n     * @param {Range} range\n     * @return {Document}\n     */\n\n  }, {\n    key: 'getFragmentAtRange',\n    value: function getFragmentAtRange(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return Document.create();\n\n      var node = this;\n\n      // Make sure the children exist.\n      var _range5 = range,\n          startKey = _range5.startKey,\n          startOffset = _range5.startOffset,\n          endKey = _range5.endKey,\n          endOffset = _range5.endOffset;\n\n      var startText = node.assertDescendant(startKey);\n      var endText = node.assertDescendant(endKey);\n\n      // Split at the start and end.\n      var child = startText;\n      var previous = void 0;\n      var parent = void 0;\n\n      while (parent = node.getParent(child.key)) {\n        var index = parent.nodes.indexOf(child);\n        var position = child.object == 'text' ? startOffset : child.nodes.indexOf(previous);\n\n        parent = parent.splitNode(index, position);\n        node = node.replaceNode(parent.key, parent);\n        previous = parent.nodes.get(index + 1);\n        child = parent;\n      }\n\n      child = startKey == endKey ? node.getNextText(startKey) : endText;\n\n      while (parent = node.getParent(child.key)) {\n        var _index = parent.nodes.indexOf(child);\n        var _position = child.object == 'text' ? startKey == endKey ? endOffset - startOffset : endOffset : child.nodes.indexOf(previous);\n\n        parent = parent.splitNode(_index, _position);\n        node = node.replaceNode(parent.key, parent);\n        previous = parent.nodes.get(_index + 1);\n        child = parent;\n      }\n\n      // Get the start and end nodes.\n      var startNode = node.getNextSibling(node.getFurthestAncestor(startKey).key);\n      var endNode = startKey == endKey ? node.getNextSibling(node.getNextSibling(node.getFurthestAncestor(endKey).key).key) : node.getNextSibling(node.getFurthestAncestor(endKey).key);\n\n      // Get children range of nodes from start to end nodes\n      var startIndex = node.nodes.indexOf(startNode);\n      var endIndex = node.nodes.indexOf(endNode);\n      var nodes = node.nodes.slice(startIndex, endIndex);\n\n      // Return a new document fragment.\n      return Document.create({ nodes: nodes });\n    }\n\n    /**\n     * Get the furthest parent of a node that matches an `iterator`.\n     *\n     * @param {Path} path\n     * @param {Function} iterator\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthest',\n    value: function getFurthest(path, iterator) {\n      var _this3 = this;\n\n      var ancestors = this.getAncestors(path);\n      if (!ancestors) return null;\n\n      var furthest = ancestors.find(function (node) {\n        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        // We never want to include the top-level node.\n        if (node === _this3) return false;\n        return iterator.apply(undefined, [node].concat(args));\n      });\n\n      return furthest || null;\n    }\n\n    /**\n     * Get the furthest ancestor of a node.\n     *\n     * @param {Path} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestAncestor',\n    value: function getFurthestAncestor(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      var furthest = path.size ? this.nodes.get(path.first()) : null;\n      return furthest;\n    }\n\n    /**\n     * Get the furthest block parent of a node.\n     *\n     * @param {Path} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestBlock',\n    value: function getFurthestBlock(path) {\n      var furthest = this.getFurthest(path, function (n) {\n        return n.object === 'block';\n      });\n      return furthest;\n    }\n\n    /**\n     * Get the furthest inline parent of a node.\n     *\n     * @param {Path} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestInline',\n    value: function getFurthestInline(path) {\n      var furthest = this.getFurthest(path, function (n) {\n        return n.object === 'inline';\n      });\n      return furthest;\n    }\n\n    /**\n     * Get the furthest ancestor of a node that has only one child.\n     *\n     * @param {Path} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestOnlyChildAncestor',\n    value: function getFurthestOnlyChildAncestor(path) {\n      var ancestors = this.getAncestors(path);\n      if (!ancestors) return null;\n\n      var furthest = ancestors.rest().reverse().takeUntil(function (p) {\n        return p.nodes.size > 1;\n      }).last();\n\n      return furthest || null;\n    }\n\n    /**\n     * Get the closest inline nodes for each text node in the node.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlines',\n    value: function getInlines() {\n      var array = this.getInlinesAsArray();\n      var list = new immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get the closest inline nodes for each text node in the node, as an array.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlinesAsArray',\n    value: function getInlinesAsArray() {\n      var array = [];\n\n      this.nodes.forEach(function (child) {\n        if (child.object == 'text') return;\n\n        if (child.isLeafInline()) {\n          array.push(child);\n        } else {\n          array = array.concat(child.getInlinesAsArray());\n        }\n      });\n\n      return array;\n    }\n\n    /**\n     * Get the closest inline nodes for each text node in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlinesAtRange',\n    value: function getInlinesAtRange(range) {\n      var array = this.getInlinesAtRangeAsArray(range);\n      // Remove duplicates by converting it to an `OrderedSet` first.\n      var list = new immutable.List(new immutable.OrderedSet(array));\n      return list;\n    }\n\n    /**\n     * Get the closest inline nodes for each text node in a `range` as an array.\n     *\n     * @param {Range} range\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getInlinesAtRangeAsArray',\n    value: function getInlinesAtRangeAsArray(range) {\n      var _this4 = this;\n\n      range = range.normalize(this);\n      if (range.isUnset) return [];\n\n      var array = this.getTextsAtRangeAsArray(range).map(function (text) {\n        return _this4.getClosestInline(text.key);\n      }).filter(function (exists) {\n        return exists;\n      });\n\n      return array;\n    }\n\n    /**\n     * Get all of the leaf inline nodes that match a `type`.\n     *\n     * @param {String} type\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlinesByType',\n    value: function getInlinesByType(type) {\n      var array = this.getInlinesByTypeAsArray(type);\n      var list = new immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get all of the leaf inline nodes that match a `type` as an array.\n     *\n     * @param {String} type\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getInlinesByTypeAsArray',\n    value: function getInlinesByTypeAsArray(type) {\n      var array = this.nodes.reduce(function (inlines, node) {\n        if (node.object == 'text') {\n          return inlines;\n        } else if (node.isLeafInline() && node.type == type) {\n          inlines.push(node);\n          return inlines;\n        } else {\n          return inlines.concat(node.getInlinesByTypeAsArray(type));\n        }\n      }, []);\n\n      return array;\n    }\n\n    /**\n     * Get a set of the marks in a `range`.\n     *\n     * @param {Range} range\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getInsertMarksAtRange',\n    value: function getInsertMarksAtRange(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return immutable.Set();\n\n      if (range.isCollapsed) {\n        // PERF: range is not cachable, use key and offset as proxies for cache\n        return this.getMarksAtPosition(range.startKey, range.startOffset);\n      }\n\n      var _range6 = range,\n          startKey = _range6.startKey,\n          startOffset = _range6.startOffset;\n\n      var text = this.getDescendant(startKey);\n      var marks = text.getMarksAtIndex(startOffset + 1);\n      return marks;\n    }\n\n    /**\n     * Get an object mapping all the keys in the node to their paths.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'getKeysToPathsTable',\n    value: function getKeysToPathsTable() {\n      var ret = defineProperty({}, this.key, []);\n\n      this.nodes.forEach(function (node, i) {\n        ret[node.key] = [i];\n\n        if (node.object !== 'text') {\n          var nested = node.getKeysToPathsTable();\n\n          for (var key in nested) {\n            var path = nested[key];\n            ret[key] = [i].concat(toConsumableArray(path));\n          }\n        }\n      });\n\n      return ret;\n    }\n\n    /**\n     * Get the last child text node.\n     *\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getLastText',\n    value: function getLastText() {\n      var descendant = null;\n\n      var found = this.nodes.findLast(function (node) {\n        if (node.object == 'text') return true;\n        descendant = node.getLastText();\n        return descendant;\n      });\n\n      return descendant || found;\n    }\n\n    /**\n     * Get all of the marks for all of the characters of every text node.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getMarks',\n    value: function getMarks() {\n      var array = this.getMarksAsArray();\n      var set$$1 = new immutable.Set(array);\n      return set$$1;\n    }\n\n    /**\n     * Get all of the marks as an array.\n     *\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getMarksAsArray',\n    value: function getMarksAsArray() {\n      var _ref;\n\n      var result = [];\n\n      this.nodes.forEach(function (node) {\n        result.push(node.getMarksAsArray());\n      });\n\n      // PERF: use only one concat rather than multiple for speed.\n      var array = (_ref = []).concat.apply(_ref, result);\n      return array;\n    }\n\n    /**\n     * Get a set of marks in a `position`, the equivalent of a collapsed range\n     *\n     * @param {string} key\n     * @param {number} offset\n     * @return {Set}\n     */\n\n  }, {\n    key: 'getMarksAtPosition',\n    value: function getMarksAtPosition(key, offset) {\n      var text = this.getDescendant(key);\n      var currentMarks = text.getMarksAtIndex(offset);\n      if (offset !== 0) return currentMarks;\n      var closestBlock = this.getClosestBlock(key);\n\n      if (closestBlock.text === '') {\n        // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\n        return currentMarks;\n      }\n\n      var previous = this.getPreviousText(key);\n      if (!previous) return immutable.Set();\n\n      if (closestBlock.hasDescendant(previous.key)) {\n        return previous.getMarksAtIndex(previous.text.length);\n      }\n\n      return currentMarks;\n    }\n\n    /**\n     * Get a set of the marks in a `range`.\n     *\n     * @param {Range} range\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getMarksAtRange',\n    value: function getMarksAtRange(range) {\n      var marks = new immutable.Set(this.getOrderedMarksAtRange(range));\n      return marks;\n    }\n\n    /**\n     * Get all of the marks that match a `type`.\n     *\n     * @param {String} type\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getMarksByType',\n    value: function getMarksByType(type) {\n      var array = this.getMarksByTypeAsArray(type);\n      var set$$1 = new immutable.Set(array);\n      return set$$1;\n    }\n\n    /**\n     * Get all of the marks that match a `type` as an array.\n     *\n     * @param {String} type\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getMarksByTypeAsArray',\n    value: function getMarksByTypeAsArray(type) {\n      var array = this.nodes.reduce(function (memo, node) {\n        return node.object == 'text' ? memo.concat(node.getMarksAsArray().filter(function (m) {\n          return m.type == type;\n        })) : memo.concat(node.getMarksByTypeAsArray(type));\n      }, []);\n\n      return array;\n    }\n\n    /**\n     * Get the block node before a descendant text node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextBlock',\n    value: function getNextBlock(key) {\n      var child = this.assertDescendant(key);\n      var last = void 0;\n\n      if (child.object == 'block') {\n        last = child.getLastText();\n      } else {\n        var block = this.getClosestBlock(key);\n        last = block.getLastText();\n      }\n\n      var next = this.getNextText(last.key);\n      if (!next) return null;\n\n      var closest = this.getClosestBlock(next.key);\n      return closest;\n    }\n\n    /**\n     * Get the next node in the tree from a node.\n     *\n     * This will not only check for siblings but instead move up the tree\n     * returning the next ancestor if no sibling is found.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextNode',\n    value: function getNextNode(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (!path.size) return null;\n\n      for (var i = path.size; i > 0; i--) {\n        var p = path.slice(0, i);\n        var target = PathUtils.increment(p);\n        var node = this.getNode(target);\n        if (node) return node;\n      }\n\n      return null;\n    }\n\n    /**\n     * Get the next sibling of a node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextSibling',\n    value: function getNextSibling(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (!path.size) return null;\n      var p = PathUtils.increment(path);\n      var sibling = this.getNode(p);\n      return sibling;\n    }\n\n    /**\n     * Get the text node after a descendant text node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextText',\n    value: function getNextText(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (!path.size) return null;\n      var next = this.getNextNode(path);\n      if (!next) return null;\n      var text = next.getFirstText();\n      return text;\n    }\n\n    /**\n     * Get a node in the tree.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNode',\n    value: function getNode(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      var node = path.size ? this.getDescendant(path) : this;\n      return node;\n    }\n\n    /**\n     * Get the offset for a descendant text node by `key`.\n     *\n     * @param {String} key\n     * @return {Number}\n     */\n\n  }, {\n    key: 'getOffset',\n    value: function getOffset(key) {\n      this.assertDescendant(key);\n\n      // Calculate the offset of the nodes before the highest child.\n      var child = this.getFurthestAncestor(key);\n      var offset = this.nodes.takeUntil(function (n) {\n        return n == child;\n      }).reduce(function (memo, n) {\n        return memo + n.text.length;\n      }, 0);\n\n      // Recurse if need be.\n      var ret = this.hasChild(key) ? offset : offset + child.getOffset(key);\n      return ret;\n    }\n\n    /**\n     * Get the offset from a `range`.\n     *\n     * @param {Range} range\n     * @return {Number}\n     */\n\n  }, {\n    key: 'getOffsetAtRange',\n    value: function getOffsetAtRange(range) {\n      range = range.normalize(this);\n\n      if (range.isUnset) {\n        throw new Error('The range cannot be unset to calculcate its offset.');\n      }\n\n      if (range.isExpanded) {\n        throw new Error('The range must be collapsed to calculcate its offset.');\n      }\n\n      var _range7 = range,\n          startKey = _range7.startKey,\n          startOffset = _range7.startOffset;\n\n      var offset = this.getOffset(startKey) + startOffset;\n      return offset;\n    }\n\n    /**\n     * Get all of the marks for all of the characters of every text node.\n     *\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getOrderedMarks',\n    value: function getOrderedMarks() {\n      var array = this.getMarksAsArray();\n      var set$$1 = new immutable.OrderedSet(array);\n      return set$$1;\n    }\n\n    /**\n     * Get a set of the marks in a `range`.\n     *\n     * @param {Range} range\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getOrderedMarksAtRange',\n    value: function getOrderedMarksAtRange(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return immutable.OrderedSet();\n\n      if (range.isCollapsed) {\n        // PERF: range is not cachable, use key and offset as proxies for cache\n        return this.getMarksAtPosition(range.startKey, range.startOffset);\n      }\n\n      var _range8 = range,\n          startKey = _range8.startKey,\n          startOffset = _range8.startOffset,\n          endKey = _range8.endKey,\n          endOffset = _range8.endOffset;\n\n      var marks = this.getOrderedMarksBetweenPositions(startKey, startOffset, endKey, endOffset);\n\n      return marks;\n    }\n\n    /**\n     * Get a set of the marks in a `range`.\n     * PERF: arguments use key and offset for utilizing cache\n     *\n     * @param {string} startKey\n     * @param {number} startOffset\n     * @param {string} endKey\n     * @param {number} endOffset\n     * @returns {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getOrderedMarksBetweenPositions',\n    value: function getOrderedMarksBetweenPositions(startKey, startOffset, endKey, endOffset) {\n      if (startKey === endKey) {\n        var startText = this.getDescendant(startKey);\n        return startText.getMarksBetweenOffsets(startOffset, endOffset);\n      }\n\n      var texts = this.getTextsBetweenPositionsAsArray(startKey, endKey);\n\n      return immutable.OrderedSet().withMutations(function (result) {\n        texts.forEach(function (text) {\n          if (text.key === startKey) {\n            result.union(text.getMarksBetweenOffsets(startOffset, text.text.length));\n          } else if (text.key === endKey) {\n            result.union(text.getMarksBetweenOffsets(0, endOffset));\n          } else {\n            result.union(text.getMarks());\n          }\n        });\n      });\n    }\n\n    /**\n     * Get all of the marks that match a `type`.\n     *\n     * @param {String} type\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getOrderedMarksByType',\n    value: function getOrderedMarksByType(type) {\n      var array = this.getMarksByTypeAsArray(type);\n      var set$$1 = new immutable.OrderedSet(array);\n      return set$$1;\n    }\n\n    /**\n     * Get the parent of a descendant node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getParent',\n    value: function getParent(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (!path.size) return null;\n      var parentPath = PathUtils.lift(path);\n      var parent = this.getNode(parentPath);\n      return parent;\n    }\n\n    /**\n     * Find the path to a node.\n     *\n     * @param {String|List} key\n     * @return {List}\n     */\n\n  }, {\n    key: 'getPath',\n    value: function getPath(key) {\n      // Handle the case of passing in a path directly, to match other methods.\n      if (immutable.List.isList(key)) return key;\n\n      var dict = this.getKeysToPathsTable();\n      var path = dict[key];\n      return path ? immutable.List(path) : null;\n    }\n\n    /**\n     * Get the block node before a descendant text node by `key`.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousBlock',\n    value: function getPreviousBlock(key) {\n      var child = this.assertDescendant(key);\n      var first = void 0;\n\n      if (child.object == 'block') {\n        first = child.getFirstText();\n      } else {\n        var block = this.getClosestBlock(key);\n        first = block.getFirstText();\n      }\n\n      var previous = this.getPreviousText(first.key);\n      if (!previous) return null;\n\n      var closest = this.getClosestBlock(previous.key);\n      return closest;\n    }\n\n    /**\n     * Get the previous node from a node in the tree.\n     *\n     * This will not only check for siblings but instead move up the tree\n     * returning the previous ancestor if no sibling is found.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousNode',\n    value: function getPreviousNode(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (!path.size) return null;\n\n      for (var i = path.size; i > 0; i--) {\n        var p = path.slice(0, i);\n        if (p.last() === 0) continue;\n\n        var target = PathUtils.decrement(p);\n        var node = this.getNode(target);\n        if (node) return node;\n      }\n\n      return null;\n    }\n\n    /**\n     * Get the previous sibling of a node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousSibling',\n    value: function getPreviousSibling(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (!path.size) return null;\n      if (path.last() === 0) return null;\n      var p = PathUtils.decrement(path);\n      var sibling = this.getNode(p);\n      return sibling;\n    }\n\n    /**\n     * Get the text node after a descendant text node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousText',\n    value: function getPreviousText(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (!path.size) return null;\n      var previous = this.getPreviousNode(path);\n      if (!previous) return null;\n      var text = previous.getLastText();\n      return text;\n    }\n\n    /**\n     * Get the indexes of the selection for a `range`, given an extra flag for\n     * whether the node `isSelected`, to determine whether not finding matches\n     * means everything is selected or nothing is.\n     *\n     * @param {Range} range\n     * @param {Boolean} isSelected\n     * @return {Object|Null}\n     */\n\n  }, {\n    key: 'getSelectionIndexes',\n    value: function getSelectionIndexes(range) {\n      var isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var startKey = range.startKey,\n          endKey = range.endKey;\n\n      // PERF: if we're not selected, we can exit early.\n\n      if (!isSelected) {\n        return null;\n      }\n\n      // if we've been given an invalid selection we can exit early.\n      if (range.isUnset) {\n        return null;\n      }\n\n      // PERF: if the start and end keys are the same, just check for the child\n      // that contains that single key.\n      if (startKey == endKey) {\n        var child = this.getFurthestAncestor(startKey);\n        var index = child ? this.nodes.indexOf(child) : null;\n        return { start: index, end: index + 1 };\n      }\n\n      // Otherwise, check all of the children...\n      var start = null;\n      var end = null;\n\n      this.nodes.forEach(function (child, i) {\n        if (child.object == 'text') {\n          if (start == null && child.key == startKey) start = i;\n          if (end == null && child.key == endKey) end = i + 1;\n        } else {\n          if (start == null && child.hasDescendant(startKey)) start = i;\n          if (end == null && child.hasDescendant(endKey)) end = i + 1;\n        }\n\n        // PERF: exit early if both start and end have been found.\n        return start == null || end == null;\n      });\n\n      if (isSelected && start == null) start = 0;\n      if (isSelected && end == null) end = this.nodes.size;\n      return start == null ? null : { start: start, end: end };\n    }\n\n    /**\n     * Get the concatenated text string of all child nodes.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'getText',\n    value: function getText() {\n      var text = this.nodes.reduce(function (string, node) {\n        return string + node.text;\n      }, '');\n\n      return text;\n    }\n\n    /**\n     * Get the descendent text node at an `offset`.\n     *\n     * @param {String} offset\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getTextAtOffset',\n    value: function getTextAtOffset(offset) {\n      // PERF: Add a few shortcuts for the obvious cases.\n      if (offset === 0) return this.getFirstText();\n      if (offset === this.text.length) return this.getLastText();\n      if (offset < 0 || offset > this.text.length) return null;\n\n      var length = 0;\n      var text = this.getTexts().find(function (node, i, nodes) {\n        length += node.text.length;\n        return length > offset;\n      });\n\n      return text;\n    }\n\n    /**\n     * Get the direction of the node's text.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'getTextDirection',\n    value: function getTextDirection() {\n      var dir = direction(this.text);\n      return dir === 'neutral' ? null : dir;\n    }\n\n    /**\n     * Recursively get all of the child text nodes in order of appearance.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getTexts',\n    value: function getTexts() {\n      var array = this.getTextsAsArray();\n      var list = new immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Recursively get all the leaf text nodes in order of appearance, as array.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getTextsAsArray',\n    value: function getTextsAsArray() {\n      var array = [];\n\n      this.nodes.forEach(function (node) {\n        if (node.object == 'text') {\n          array.push(node);\n        } else {\n          array = array.concat(node.getTextsAsArray());\n        }\n      });\n\n      return array;\n    }\n\n    /**\n     * Get all of the text nodes in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getTextsAtRange',\n    value: function getTextsAtRange(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return immutable.List();\n      var _range9 = range,\n          startKey = _range9.startKey,\n          endKey = _range9.endKey;\n\n      var list = new immutable.List(this.getTextsBetweenPositionsAsArray(startKey, endKey));\n\n      return list;\n    }\n\n    /**\n     * Get all of the text nodes in a `range` as an array.\n     *\n     * @param {Range} range\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getTextsAtRangeAsArray',\n    value: function getTextsAtRangeAsArray(range) {\n      range = range.normalize(this);\n      if (range.isUnset) return [];\n      var _range10 = range,\n          startKey = _range10.startKey,\n          endKey = _range10.endKey;\n\n      var texts = this.getTextsBetweenPositionsAsArray(startKey, endKey);\n      return texts;\n    }\n\n    /**\n     * Get all of the text nodes in a `range` as an array.\n     * PERF: use key in arguments for cache\n     *\n     * @param {string} startKey\n     * @param {string} endKey\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'getTextsBetweenPositionsAsArray',\n    value: function getTextsBetweenPositionsAsArray(startKey, endKey) {\n      var startText = this.getDescendant(startKey);\n\n      // PERF: the most common case is when the range is in a single text node,\n      // where we can avoid a lot of iterating of the tree.\n      if (startKey == endKey) return [startText];\n\n      var endText = this.getDescendant(endKey);\n      var texts = this.getTextsAsArray();\n      var start = texts.indexOf(startText);\n      var end = texts.indexOf(endText, start);\n      var ret = texts.slice(start, end + 1);\n      return ret;\n    }\n\n    /**\n     * Check if the node has block children.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasBlockChildren',\n    value: function hasBlockChildren() {\n      return !!(this.nodes && this.nodes.find(function (n) {\n        return n.object === 'block';\n      }));\n    }\n\n    /**\n     * Check if a child node exists.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasChild',\n    value: function hasChild(path) {\n      var child = this.getChild(path);\n      return !!child;\n    }\n\n    /**\n     * Check if a node has inline children.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasInlineChildren',\n    value: function hasInlineChildren() {\n      return !!(this.nodes && this.nodes.find(function (n) {\n        return n.object === 'inline' || n.object === 'text';\n      }));\n    }\n\n    /**\n     * Recursively check if a child node exists.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasDescendant',\n    value: function hasDescendant(path) {\n      var descendant = this.getDescendant(path);\n      return !!descendant;\n    }\n\n    /**\n     * Recursively check if a node exists.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasNode',\n    value: function hasNode(path) {\n      var node = this.getNode(path);\n      return !!node;\n    }\n\n    /**\n     * Check if a node has a void parent.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasVoidParent',\n    value: function hasVoidParent(path) {\n      var closest = this.getClosestVoid(path);\n      return !!closest;\n    }\n\n    /**\n     * Insert a `node`.\n     *\n     * @param {List|String} path\n     * @param {Node} node\n     * @return {Node}\n     */\n\n  }, {\n    key: 'insertNode',\n    value: function insertNode(path, node) {\n      path = this.resolvePath(path);\n      var index = path.last();\n      var parentPath = PathUtils.lift(path);\n      var parent = this.assertNode(parentPath);\n      var nodes = parent.nodes.splice(index, 0, node);\n      parent = parent.set('nodes', nodes);\n      var ret = this.replaceNode(parentPath, parent);\n      return ret;\n    }\n\n    /**\n     * Insert `text` at `offset` in node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {String} text\n     * @param {Set} marks\n     * @return {Node}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(path, offset, text, marks) {\n      var node = this.assertDescendant(path);\n      path = this.resolvePath(path);\n      node = node.insertText(offset, text, marks);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n\n    /**\n     * Check whether the node is a leaf block.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafBlock',\n    value: function isLeafBlock() {\n      return this.object === 'block' && this.nodes.every(function (n) {\n        return n.object !== 'block';\n      });\n    }\n\n    /**\n     * Check whether the node is a leaf inline.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafInline',\n    value: function isLeafInline() {\n      return this.object === 'inline' && this.nodes.every(function (n) {\n        return n.object !== 'inline';\n      });\n    }\n\n    /**\n     * Map all child nodes, updating them in their parents. This method is\n     * optimized to not return a new node if no changes are made.\n     *\n     * @param {Function} iterator\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mapChildren',\n    value: function mapChildren(iterator) {\n      var _this5 = this;\n\n      var nodes = this.nodes;\n\n\n      nodes.forEach(function (node, i) {\n        var ret = iterator(node, i, _this5.nodes);\n        if (ret !== node) nodes = nodes.set(ret.key, ret);\n      });\n\n      var ret = this.set('nodes', nodes);\n      return ret;\n    }\n\n    /**\n     * Map all descendant nodes, updating them in their parents. This method is\n     * optimized to not return a new node if no changes are made.\n     *\n     * @param {Function} iterator\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mapDescendants',\n    value: function mapDescendants(iterator) {\n      var _this6 = this;\n\n      var nodes = this.nodes;\n\n\n      nodes.forEach(function (node, index) {\n        var ret = node;\n        if (ret.object !== 'text') ret = ret.mapDescendants(iterator);\n        ret = iterator(ret, index, _this6.nodes);\n        if (ret === node) return;\n\n        nodes = nodes.set(index, ret);\n      });\n\n      var ret = this.set('nodes', nodes);\n      return ret;\n    }\n\n    /**\n     * Merge a node backwards its previous sibling.\n     *\n     * @param {List|Key} path\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mergeNode',\n    value: function mergeNode(path) {\n      var b = this.assertNode(path);\n      path = this.resolvePath(path);\n\n      if (path.last() === 0) {\n        throw new Error('Unable to merge node because it has no previous sibling: ' + b);\n      }\n\n      var withPath = PathUtils.decrement(path);\n      var a = this.assertNode(withPath);\n\n      if (a.object !== b.object) {\n        throw new Error('Unable to merge two different kinds of nodes: ' + a + ' and ' + b);\n      }\n\n      var newNode = a.object === 'text' ? a.mergeText(b) : a.set('nodes', a.nodes.concat(b.nodes));\n\n      var ret = this;\n      ret = ret.removeNode(path);\n      ret = ret.removeNode(withPath);\n      ret = ret.insertNode(withPath, newNode);\n      return ret;\n    }\n\n    /**\n     * Move a node by `path` to `newPath`.\n     *\n     * A `newIndex` can be provided when move nodes by `key`, to account for not\n     * being able to have a key for a location in the tree that doesn't exist yet.\n     *\n     * @param {List|Key} path\n     * @param {List|Key} newPath\n     * @param {Number} newIndex\n     * @return {Node}\n     */\n\n  }, {\n    key: 'moveNode',\n    value: function moveNode(path, newPath) {\n      var newIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var node = this.assertNode(path);\n      path = this.resolvePath(path);\n      newPath = this.resolvePath(newPath, newIndex);\n\n      var newParentPath = PathUtils.lift(newPath);\n      this.assertNode(newParentPath);\n\n      var _PathUtils$crop = PathUtils.crop(path, newPath),\n          _PathUtils$crop2 = slicedToArray(_PathUtils$crop, 2),\n          p = _PathUtils$crop2[0],\n          np = _PathUtils$crop2[1];\n\n      var position = PathUtils.compare(p, np);\n\n      // If the old path ends above and before a node in the new path, then\n      // removing it will alter the target, so we need to adjust the new path.\n      if (path.size < newPath.size && position === -1) {\n        newPath = PathUtils.decrement(newPath, 1, p.size - 1);\n      }\n\n      var ret = this;\n      ret = ret.removeNode(path);\n      ret = ret.insertNode(newPath, node);\n      return ret;\n    }\n\n    /**\n     * Attempt to \"refind\" a node by a previous `path`, falling back to looking\n     * it up by `key` again.\n     *\n     * @param {List|String} path\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'refindNode',\n    value: function refindNode(path, key) {\n      var node = this.getDescendant(path);\n      var found = node && node.key === key ? node : this.getDescendant(key);\n      return found;\n    }\n\n    /**\n     * Attempt to \"refind\" the path to a node by a previous `path`, falling back\n     * to looking it up by `key`.\n     *\n     * @param {List|String} path\n     * @param {String} key\n     * @return {List|Null}\n     */\n\n  }, {\n    key: 'refindPath',\n    value: function refindPath(path, key) {\n      var node = this.getDescendant(path);\n      var found = node && node.key === key ? path : this.getPath(key);\n      return found;\n    }\n\n    /**\n     * Regenerate the node's key.\n     *\n     * @return {Node}\n     */\n\n  }, {\n    key: 'regenerateKey',\n    value: function regenerateKey() {\n      var key = KeyUtils.create();\n      var node = this.set('key', key);\n      return node;\n    }\n\n    /**\n     * Remove mark from text at `offset` and `length` in node.\n     *\n     * @param {List} path\n     * @param {Number} offset\n     * @param {Number} length\n     * @param {Mark} mark\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(path, offset, length, mark) {\n      var node = this.assertDescendant(path);\n      path = this.resolvePath(path);\n      node = node.removeMark(offset, length, mark);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n\n    /**\n     * Remove a node.\n     *\n     * @param {List|String} path\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeNode',\n    value: function removeNode(path) {\n      this.assertDescendant(path);\n      path = this.resolvePath(path);\n      var deep = path.flatMap(function (x) {\n        return immutable.List(['nodes', x]);\n      });\n      var ret = this.deleteIn(deep);\n      return ret;\n    }\n\n    /**\n     * Remove `text` at `offset` in node.\n     *\n     * @param {List|Key} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(path, offset, text) {\n      var node = this.assertDescendant(path);\n      node = node.removeText(offset, text.length);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n\n    /**\n     * Replace a `node` in the tree.\n     *\n     * @param {List|Key} path\n     * @param {Node} node\n     * @return {Node}\n     */\n\n  }, {\n    key: 'replaceNode',\n    value: function replaceNode(path, node) {\n      path = this.resolvePath(path);\n\n      if (!path) {\n        throw new Error('Unable to replace a node because it could not be found in the first place: ' + path);\n      }\n\n      if (!path.size) return node;\n      this.assertNode(path);\n      var deep = path.flatMap(function (x) {\n        return immutable.List(['nodes', x]);\n      });\n      var ret = this.setIn(deep, node);\n      return ret;\n    }\n\n    /**\n     * Resolve a path from a path list or key string.\n     *\n     * An `index` can be provided, in which case paths created from a key string\n     * will have the index pushed onto them. This is helpful in cases where you\n     * want to accept either a `path` or a `key, index` combination for targeting\n     * a location in the tree that doesn't exist yet, like when inserting.\n     *\n     * @param {List|String} value\n     * @param {Number} index\n     * @return {List}\n     */\n\n  }, {\n    key: 'resolvePath',\n    value: function resolvePath(path, index) {\n      if (typeof path === 'string') {\n        path = this.getPath(path);\n\n        if (index != null) {\n          path = path.concat(index);\n        }\n      } else {\n        path = PathUtils.create(path);\n      }\n\n      return path;\n    }\n\n    /**\n     * Set `properties` on a node.\n     *\n     * @param {List|String} path\n     * @param {Object} properties\n     * @return {Node}\n     */\n\n  }, {\n    key: 'setNode',\n    value: function setNode(path, properties) {\n      var node = this.assertNode(path);\n      node = node.merge(properties);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n\n    /**\n     * Set `properties` on `mark` on text at `offset` and `length` in node.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {Number} length\n     * @param {Mark} mark\n     * @param {Object} properties\n     * @return {Node}\n     */\n\n  }, {\n    key: 'setMark',\n    value: function setMark(path, offset, length, mark, properties) {\n      var node = this.assertNode(path);\n      node = node.updateMark(offset, length, mark, properties);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n\n    /**\n     * Split a node by `path` at `position` with optional `properties` to apply\n     * to the newly split node.\n     *\n     * @param {List|String} path\n     * @param {Number} position\n     * @param {Object} properties\n     * @return {Node}\n     */\n\n  }, {\n    key: 'splitNode',\n    value: function splitNode(path, position, properties) {\n      var child = this.assertNode(path);\n      path = this.resolvePath(path);\n      var a = void 0;\n      var b = void 0;\n\n      if (child.object === 'text') {\n        \n        var _child$splitText = child.splitText(position);\n\n        var _child$splitText2 = slicedToArray(_child$splitText, 2);\n\n        a = _child$splitText2[0];\n        b = _child$splitText2[1];\n      } else {\n        var befores = child.nodes.take(position);\n        var afters = child.nodes.skip(position);\n        a = child.set('nodes', befores);\n        b = child.set('nodes', afters).regenerateKey();\n      }\n\n      if (properties && child.object !== 'text') {\n        b = b.merge(properties);\n      }\n\n      var ret = this;\n      ret = ret.removeNode(path);\n      ret = ret.insertNode(path, b);\n      ret = ret.insertNode(path, a);\n      return ret;\n    }\n\n    /**\n     * Normalize the node with a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Function|Void}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(schema) {\n      return schema.normalizeNode(this);\n    }\n\n    /**\n     * Validate the node against a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Error|Void}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(schema) {\n      return schema.validateNode(this);\n    }\n\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'getNodeAtPath',\n    value: function getNodeAtPath(path) {\n      logger.deprecate('0.35.0', 'The `Node.getNodeAtPath` method has been combined into `Node.getNode`.');\n\n      return this.getNode(path);\n    }\n  }, {\n    key: 'getDescendantAtPath',\n    value: function getDescendantAtPath(path) {\n      logger.deprecate('0.35.0', 'The `Node.getDescendantAtPath` has been combined into `Node.getDescendant`.');\n\n      return this.getDescendant(path);\n    }\n  }, {\n    key: 'getKeys',\n    value: function getKeys() {\n      logger.deprecate('0.35.0', 'The `Node.getKeys` method is deprecated.');\n\n      var keys = this.getKeysAsArray();\n      return new immutable.Set(keys);\n    }\n  }, {\n    key: 'getKeysAsArray',\n    value: function getKeysAsArray() {\n      logger.deprecate('0.35.0', 'The `Node.getKeysAsArray` method is deprecated.');\n\n      var dict = this.getKeysToPathsTable();\n      var keys = [];\n\n      for (var key in dict) {\n        if (this.key !== key) {\n          keys.push(key);\n        }\n      }\n\n      return keys;\n    }\n  }, {\n    key: 'areDescendantsSorted',\n    value: function areDescendantsSorted(first, second) {\n      var _this7 = this;\n\n      logger.deprecate('0.35.0', 'The `Node.areDescendantsSorted` method is deprecated. Use the new `PathUtils.compare` helper instead.');\n\n      first = KeyUtils.create(first);\n      second = KeyUtils.create(second);\n\n      var keys = this.getKeysAsArray().filter(function (k) {\n        return k !== _this7.key;\n      });\n      var firstIndex = keys.indexOf(first);\n      var secondIndex = keys.indexOf(second);\n      if (firstIndex == -1 || secondIndex == -1) return null;\n\n      return firstIndex < secondIndex;\n    }\n  }, {\n    key: 'isInRange',\n    value: function isInRange(range) {\n      logger.deprecate('0.35.0', 'The `Node.isInRange` method is deprecated. Use the new `PathUtils.compare` helper instead.');\n\n      range = range.normalize(this);\n\n      var node = this;\n      var _range11 = range,\n          startKey = _range11.startKey,\n          endKey = _range11.endKey,\n          isCollapsed = _range11.isCollapsed;\n\n      // PERF: solve the most common cast where the start or end key are inside\n      // the node, for collapsed selections.\n\n      if (node.key == startKey || node.key == endKey || node.hasDescendant(startKey) || node.hasDescendant(endKey)) {\n        return true;\n      }\n\n      // PERF: if the selection is collapsed and the previous check didn't return\n      // true, then it must be false.\n      if (isCollapsed) {\n        return false;\n      }\n\n      // Otherwise, look through all of the leaf text nodes in the range, to see\n      // if any of them are inside the node.\n      var texts = node.getTextsAtRange(range);\n      var memo = false;\n\n      texts.forEach(function (text) {\n        if (node.hasDescendant(text.key)) memo = true;\n        return memo;\n      });\n\n      return memo;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Node` with `attrs`.\n     *\n     * @param {Object|Node} attrs\n     * @return {Node}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Node.isNode(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        var object = attrs.object;\n\n\n        if (!object && attrs.kind) {\n          logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n\n          object = attrs.kind;\n        }\n\n        switch (object) {\n          case 'block':\n            return Block.create(attrs);\n          case 'document':\n            return Document.create(attrs);\n          case 'inline':\n            return Inline.create(attrs);\n          case 'text':\n            return Text.create(attrs);\n\n          default:\n            {\n              throw new Error('`Node.create` requires a `object` string.');\n            }\n        }\n      }\n\n      throw new Error('`Node.create` only accepts objects or nodes but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Nodes` from an array.\n     *\n     * @param {Array<Object|Node>} elements\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = immutable.List(elements.map(Node.create));\n        return list;\n      }\n\n      throw new Error('`Node.createList` only accepts lists or arrays, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a dictionary of settable node properties from `attrs`.\n     *\n     * @param {Object|String|Node} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n        return {\n          data: attrs.data,\n          isVoid: attrs.isVoid,\n          type: attrs.type\n        };\n      }\n\n      if (typeof attrs == 'string') {\n        return { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        var props = {};\n        if ('type' in attrs) props.type = attrs.type;\n        if ('data' in attrs) props.data = Data.create(attrs.data);\n        if ('isVoid' in attrs) props.isVoid = attrs.isVoid;\n        return props;\n      }\n\n      throw new Error('`Node.createProperties` only accepts objects, strings, blocks or inlines, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Node` from a JSON `value`.\n     *\n     * @param {Object} value\n     * @return {Node}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(value) {\n      var object = value.object;\n\n\n      if (!object && value.kind) {\n        logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n\n        object = value.kind;\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.fromJSON(value);\n        case 'document':\n          return Document.fromJSON(value);\n        case 'inline':\n          return Inline.fromJSON(value);\n        case 'text':\n          return Text.fromJSON(value);\n\n        default:\n          {\n            throw new Error('`Node.fromJSON` requires an `object` of either \\'block\\', \\'document\\', \\'inline\\' or \\'text\\', but you passed: ' + value);\n          }\n      }\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }, {\n    key: 'isNode',\n\n\n    /**\n     * Check if `any` is a `Node`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isNode(any) {\n      return !!['BLOCK', 'DOCUMENT', 'INLINE', 'TEXT'].find(function (type) {\n        return isType(type, any);\n      });\n    }\n\n    /**\n     * Check if `any` is a list of nodes.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isNodeList',\n    value: function isNodeList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Node.isNode(item);\n      });\n    }\n  }]);\n  return Node;\n}();\n\n/**\n * Mix in assertion variants.\n */\n\nNode.fromJS = Node.fromJSON;\nvar ASSERTS = ['Child', 'Depth', 'Descendant', 'Node', 'Parent', 'Path'];\n\nvar _loop = function _loop(method) {\n  Node.prototype['assert' + method] = function (path) {\n    for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    var ret = this['get' + method].apply(this, [path].concat(args));\n\n    if (ret == null) {\n      throw new Error('`Node.assert' + method + '` could not find node with path or key: ' + path);\n    }\n\n    return ret;\n  };\n};\n\nvar _iteratorNormalCompletion2 = true;\nvar _didIteratorError2 = false;\nvar _iteratorError2 = undefined;\n\ntry {\n  for (var _iterator2 = ASSERTS[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n    var method = _step2.value;\n\n    _loop(method);\n  }\n\n  /**\n   * Memoize read methods.\n   */\n} catch (err) {\n  _didIteratorError2 = true;\n  _iteratorError2 = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n      _iterator2.return();\n    }\n  } finally {\n    if (_didIteratorError2) {\n      throw _iteratorError2;\n    }\n  }\n}\n\nmemoize(Node.prototype, ['getBlocksAsArray', 'getBlocksAtRangeAsArray', 'getBlocksByTypeAsArray', 'getDecorations', 'getFirstInvalidDescendant', 'getFirstText', 'getFragmentAtRange', 'getInlinesAsArray', 'getInlinesAtRangeAsArray', 'getInlinesByTypeAsArray', 'getMarksAsArray', 'getMarksAtPosition', 'getOrderedMarksBetweenPositions', 'getInsertMarksAtRange', 'getKeysToPathsTable', 'getLastText', 'getMarksByTypeAsArray', 'getNextBlock', 'getOffset', 'getOffsetAtRange', 'getPreviousBlock', 'getText', 'getTextAtOffset', 'getTextDirection', 'getTextsAsArray', 'getTextsBetweenPositionsAsArray', 'isLeafBlock', 'isLeafInline', 'normalize', 'validate']);\n\n/**\n * Mix in `Node` methods.\n */\n\nObject.getOwnPropertyNames(Node.prototype).forEach(function (method) {\n  if (method === 'constructor') return;\n  Block.prototype[method] = Node.prototype[method];\n  Inline.prototype[method] = Node.prototype[method];\n  Document.prototype[method] = Node.prototype[method];\n});\n\nBlock.createChildren = Node.createList;\nInline.createChildren = Node.createList;\nDocument.createChildren = Node.createList;\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nvar SURROGATE_START = 0xd800;\nvar SURROGATE_END = 0xdfff;\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nvar SPACE = /\\s/;\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nvar CHAMELEON = /['\\u2018\\u2019]/;\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END;\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false;\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    var next = remaining.charAt(0);\n    var length = getCharLength(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n    if (isWord(next, rest)) return true;\n  }\n\n  if (PUNCTUATION.test(char)) return false;\n  return true;\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1;\n}\n\n/**\n * Get the offset to the end of the first character in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getCharOffset(text) {\n  var char = text.charAt(0);\n  return getCharLength(char);\n}\n\n/**\n * Get the offset to the end of the character before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset) {\n  text = text.slice(0, offset);\n  text = esrever.reverse(text);\n  return getCharOffset(text);\n}\n\n/**\n * Get the offset to the end of the character after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset) {\n  text = text.slice(offset);\n  return getCharOffset(text);\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  var length = 0;\n  var i = 0;\n  var started = false;\n  var char = void 0;\n\n  while (char = text.charAt(i)) {\n    var l = getCharLength(char);\n    char = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWord(char, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset);\n  text = esrever.reverse(text);\n  var o = getWordOffset(text);\n  return o;\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset);\n  var o = getWordOffset(text);\n  return o;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar TextUtils = {\n  getCharLength: getCharLength,\n  getCharOffset: getCharOffset,\n  getCharOffsetBackward: getCharOffsetBackward,\n  getCharOffsetForward: getCharOffsetForward,\n  getWordOffset: getWordOffset,\n  getWordOffsetBackward: getWordOffsetBackward,\n  getWordOffsetForward: getWordOffsetForward,\n  isSurrogate: isSurrogate,\n  isWord: isWord\n};\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes$1 = {};\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.addMarkAtRange = function (change, range, mark) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (range.isCollapsed) return;\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n  var texts = document.getTextsAtRange(range);\n\n  texts.forEach(function (node) {\n    var key = node.key;\n\n    var index = 0;\n    var length = node.text.length;\n\n    if (key == startKey) index = startOffset;\n    if (key == endKey) length = endOffset;\n    if (key == startKey && key == endKey) length = endOffset - startOffset;\n\n    change.addMarkByKey(key, index, length, mark, { normalize: normalize });\n  });\n};\n\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Array<Mixed>} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.addMarksAtRange = function (change, range, marks) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  marks.forEach(function (mark) {\n    return change.addMarkAtRange(range, mark, options);\n  });\n};\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteAtRange = function (change, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (range.isCollapsed) return;\n\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  change.snapshotSelection();\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n  var document = value.document;\n\n  var isStartVoid = document.hasVoidParent(startKey);\n  var isEndVoid = document.hasVoidParent(endKey);\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(endKey);\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  var isHanging = startOffset == 0 && endOffset == 0 && isStartVoid == false && startKey == startBlock.getFirstText().key && endKey == endBlock.getFirstText().key;\n\n  // If it's a hanging selection, nudge it back to end in the previous text.\n  if (isHanging && isEndVoid) {\n    var prevText = document.getPreviousText(endKey);\n    endKey = prevText.key;\n    endOffset = prevText.text.length;\n    isEndVoid = document.hasVoidParent(endKey);\n  }\n\n  // If the start node is inside a void node, remove the void node and update\n  // the starting point to be right after it, continuously until the start point\n  // is not a void, or until the entire range is handled.\n  while (isStartVoid) {\n    var startVoid = document.getClosestVoid(startKey);\n    var nextText = document.getNextText(startKey);\n    change.removeNodeByKey(startVoid.key, { normalize: false });\n\n    // If the start and end keys are the same, we're done.\n    if (startKey == endKey) return;\n\n    // If there is no next text node, we're done.\n    if (!nextText) return;\n\n    // Continue...\n    document = change.value.document;\n    startKey = nextText.key;\n    startOffset = 0;\n    isStartVoid = document.hasVoidParent(startKey);\n  }\n\n  // If the end node is inside a void node, do the same thing but backwards. But\n  // we don't need any aborting checks because if we've gotten this far there\n  // must be a non-void node that will exit the loop.\n  while (isEndVoid) {\n    var endVoid = document.getClosestVoid(endKey);\n    var _prevText = document.getPreviousText(endKey);\n    change.removeNodeByKey(endVoid.key, { normalize: false });\n\n    // Continue...\n    document = change.value.document;\n    endKey = _prevText.key;\n    endOffset = _prevText.text.length;\n    isEndVoid = document.hasVoidParent(endKey);\n  }\n\n  // If the start and end key are the same, and it was a hanging selection, we\n  // can just remove the entire block.\n  if (startKey == endKey && isHanging) {\n    change.removeNodeByKey(startBlock.key, { normalize: normalize });\n    return;\n  } else if (startKey == endKey) {\n    // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n    // simply remove the text in the range.\n    var index = startOffset;\n    var length = endOffset - startOffset;\n    change.removeTextByKey(startKey, index, length, { normalize: normalize });\n    return;\n  } else {\n    // Otherwise, we need to recursively remove text and nodes inside the start\n    // block after the start offset and inside the end block before the end\n    // offset. Then remove any blocks that are in between the start and end\n    // blocks. Then finally merge the start and end nodes.\n    startBlock = document.getClosestBlock(startKey);\n    endBlock = document.getClosestBlock(endKey);\n    var startText = document.getNode(startKey);\n    var endText = document.getNode(endKey);\n    var startLength = startText.text.length - startOffset;\n    var endLength = endOffset;\n\n    var ancestor = document.getCommonAncestor(startKey, endKey);\n    var startChild = ancestor.getFurthestAncestor(startKey);\n    var endChild = ancestor.getFurthestAncestor(endKey);\n\n    var startParent = document.getParent(startBlock.key);\n    var startParentIndex = startParent.nodes.indexOf(startBlock);\n    var endParentIndex = startParent.nodes.indexOf(endBlock);\n\n    var child = void 0;\n\n    // Iterate through all of the nodes in the tree after the start text node\n    // but inside the end child, and remove them.\n    child = startText;\n\n    while (child.key != startChild.key) {\n      var parent = document.getParent(child.key);\n      var _index = parent.nodes.indexOf(child);\n      var afters = parent.nodes.slice(_index + 1);\n\n      afters.reverse().forEach(function (node) {\n        change.removeNodeByKey(node.key, { normalize: false });\n      });\n\n      child = parent;\n    }\n\n    // Remove all of the middle children.\n    var startChildIndex = ancestor.nodes.indexOf(startChild);\n    var endChildIndex = ancestor.nodes.indexOf(endChild);\n    var middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex);\n\n    middles.reverse().forEach(function (node) {\n      change.removeNodeByKey(node.key, { normalize: false });\n    });\n\n    // Remove the nodes before the end text node in the tree.\n    child = endText;\n\n    while (child.key != endChild.key) {\n      var _parent = document.getParent(child.key);\n      var _index2 = _parent.nodes.indexOf(child);\n      var befores = _parent.nodes.slice(0, _index2);\n\n      befores.reverse().forEach(function (node) {\n        change.removeNodeByKey(node.key, { normalize: false });\n      });\n\n      child = _parent;\n    }\n\n    // Remove any overlapping text content from the leaf text nodes.\n    if (startLength != 0) {\n      change.removeTextByKey(startKey, startOffset, startLength, {\n        normalize: false\n      });\n    }\n\n    if (endLength != 0) {\n      change.removeTextByKey(endKey, 0, endOffset, { normalize: false });\n    }\n\n    // If the start and end blocks aren't the same, move and merge the end block\n    // into the start block.\n    if (startBlock.key != endBlock.key) {\n      document = change.value.document;\n      var lonely = document.getFurthestOnlyChildAncestor(endBlock.key);\n\n      // Move the end block to be right after the start block.\n      if (endParentIndex != startParentIndex + 1) {\n        change.moveNodeByKey(endBlock.key, startParent.key, startParentIndex + 1, { normalize: false });\n      }\n\n      // If the selection is hanging, just remove the start block, otherwise\n      // merge the end block into it.\n      if (isHanging) {\n        change.removeNodeByKey(startBlock.key, { normalize: false });\n      } else {\n        change.mergeNodeByKey(endBlock.key, { normalize: false });\n      }\n\n      // If nested empty blocks are left over above the end block, remove them.\n      if (lonely) {\n        change.removeNodeByKey(lonely.key, { normalize: false });\n      }\n    }\n\n    // If we should normalize, do it now after everything.\n    if (normalize) {\n      change.normalizeNodeByKey(ancestor.key);\n    }\n  }\n};\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteCharBackwardAtRange = function (change, range, options) {\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = TextUtils.getCharOffsetBackward(text, o);\n  change.deleteBackwardAtRange(range, n, options);\n};\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteLineBackwardAtRange = function (change, range, options) {\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  change.deleteBackwardAtRange(range, o, options);\n};\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteWordBackwardAtRange = function (change, range, options) {\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = TextUtils.getWordOffsetBackward(text, o);\n  change.deleteBackwardAtRange(range, n, options);\n};\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteBackwardAtRange = function (change, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (n === 0) return;\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n  var _range = range,\n      startKey = _range.startKey,\n      focusOffset = _range.focusOffset;\n\n  // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  var voidParent = document.getClosestVoid(startKey);\n\n  // If there is a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key, { normalize: normalize });\n    return;\n  }\n\n  var block = document.getClosestBlock(startKey);\n\n  // If the closest is not void, but empty, remove it\n  if (block && block.isEmpty && document.nodes.size !== 1) {\n    change.removeNodeByKey(block.key, { normalize: normalize });\n    return;\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtStartOf(document)) {\n    return;\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  var text = document.getDescendant(startKey);\n\n  if (range.isAtStartOf(text)) {\n    var prev = document.getPreviousText(text.key);\n    var prevBlock = document.getClosestBlock(prev.key);\n    var prevVoid = document.getClosestVoid(prev.key);\n\n    // If the previous text node has a void parent, remove it.\n    if (prevVoid) {\n      change.removeNodeByKey(prevVoid.key, { normalize: normalize });\n      return;\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && prevBlock != block) {\n      range = range.merge({\n        anchorKey: prev.key,\n        anchorOffset: prev.text.length\n      });\n\n      change.deleteAtRange(range, { normalize: normalize });\n      return;\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n < focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset - n,\n      isBackward: true\n    });\n\n    change.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  var node = text;\n  var offset = 0;\n  var traversed = focusOffset;\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key);\n    var next = traversed + node.text.length;\n\n    if (n <= next) {\n      offset = next - n;\n      break;\n    } else {\n      traversed = next;\n    }\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset,\n    isBackward: true\n  });\n\n  change.deleteAtRange(range, { normalize: normalize });\n};\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteCharForwardAtRange = function (change, range, options) {\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = TextUtils.getCharOffsetForward(text, o);\n  change.deleteForwardAtRange(range, n, options);\n};\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteLineForwardAtRange = function (change, range, options) {\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  change.deleteForwardAtRange(range, startBlock.text.length - o, options);\n};\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteWordForwardAtRange = function (change, range, options) {\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = TextUtils.getWordOffsetForward(text, o);\n  change.deleteForwardAtRange(range, n, options);\n};\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.deleteForwardAtRange = function (change, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (n === 0) return;\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n  var _range2 = range,\n      startKey = _range2.startKey,\n      focusOffset = _range2.focusOffset;\n\n  // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  var voidParent = document.getClosestVoid(startKey);\n\n  // If the node has a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key, { normalize: normalize });\n    return;\n  }\n\n  var block = document.getClosestBlock(startKey);\n\n  // If the closest is not void, but empty, remove it\n  if (block && block.isEmpty && document.nodes.size !== 1) {\n    var nextBlock = document.getNextBlock(block.key);\n    change.removeNodeByKey(block.key, { normalize: normalize });\n\n    if (nextBlock && nextBlock.key) {\n      change.moveToStartOf(nextBlock);\n    }\n    return;\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtEndOf(document)) {\n    return;\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  var text = document.getDescendant(startKey);\n\n  if (range.isAtEndOf(text)) {\n    var next = document.getNextText(text.key);\n    var _nextBlock = document.getClosestBlock(next.key);\n    var nextVoid = document.getClosestVoid(next.key);\n\n    // If the next text node has a void parent, remove it.\n    if (nextVoid) {\n      change.removeNodeByKey(nextVoid.key, { normalize: normalize });\n      return;\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && _nextBlock != block) {\n      range = range.merge({\n        focusKey: next.key,\n        focusOffset: 0\n      });\n\n      change.deleteAtRange(range, { normalize: normalize });\n      return;\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.text.length - focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset + n\n    });\n\n    change.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  var node = text;\n  var offset = focusOffset;\n  var traversed = text.text.length - focusOffset;\n\n  while (n > traversed) {\n    node = document.getNextText(node.key);\n    var _next = traversed + node.text.length;\n\n    if (n <= _next) {\n      offset = n - traversed;\n      break;\n    } else {\n      traversed = _next;\n    }\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset\n  });\n\n  change.deleteAtRange(range, { normalize: normalize });\n};\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|String|Object} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.insertBlockAtRange = function (change, range, block) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  block = Block.create(block);\n  var normalize = change.getFlag('normalize', options);\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range);\n    range = range.collapseToStart();\n  }\n\n  var value = change.value;\n  var document = value.document;\n  var _range3 = range,\n      startKey = _range3.startKey,\n      startOffset = _range3.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var startInline = document.getClosestInline(startKey);\n  var parent = document.getParent(startBlock.key);\n  var index = parent.nodes.indexOf(startBlock);\n\n  if (startBlock.isVoid) {\n    var extra = range.isAtEndOf(startBlock) ? 1 : 0;\n    change.insertNodeByKey(parent.key, index + extra, block, { normalize: normalize });\n  } else if (startBlock.isEmpty) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });\n  } else if (range.isAtStartOf(startBlock)) {\n    change.insertNodeByKey(parent.key, index, block, { normalize: normalize });\n  } else if (range.isAtEndOf(startBlock)) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });\n  } else {\n    if (startInline && startInline.isVoid) {\n      var atEnd = range.isAtEndOf(startInline);\n      var siblingText = atEnd ? document.getNextText(startKey) : document.getPreviousText(startKey);\n\n      var splitRange = atEnd ? range.moveToStartOf(siblingText) : range.moveToEndOf(siblingText);\n\n      startKey = splitRange.startKey;\n      startOffset = splitRange.startOffset;\n    }\n\n    change.splitDescendantsByKey(startBlock.key, startKey, startOffset, {\n      normalize: false\n    });\n\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });\n  }\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Document} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.insertFragmentAtRange = function (change, range, fragment) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var normalize = change.getFlag('normalize', options);\n\n  // If the range is expanded, delete it first.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false });\n\n    if (change.value.document.getDescendant(range.startKey)) {\n      range = range.collapseToStart();\n    } else {\n      range = range.collapseTo(range.endKey, 0);\n    }\n  }\n\n  // If the fragment is empty, there's nothing to do after deleting.\n  if (!fragment.nodes.size) return;\n\n  // Regenerate the keys for all of the fragments nodes, so that they're\n  // guaranteed not to collide with the existing keys in the document. Otherwise\n  // they will be rengerated automatically and we won't have an easy way to\n  // reference them.\n  fragment = fragment.mapDescendants(function (child) {\n    return child.regenerateKey();\n  });\n\n  // Calculate a few things...\n  var _range4 = range,\n      startKey = _range4.startKey,\n      startOffset = _range4.startOffset;\n  var value = change.value;\n  var document = value.document;\n\n  var startText = document.getDescendant(startKey);\n  var startBlock = document.getClosestBlock(startText.key);\n  var startChild = startBlock.getFurthestAncestor(startText.key);\n  var isAtStart = range.isAtStartOf(startBlock);\n  var parent = document.getParent(startBlock.key);\n  var index = parent.nodes.indexOf(startBlock);\n  var blocks = fragment.getBlocks();\n  var firstChild = fragment.nodes.first();\n  var lastChild = fragment.nodes.last();\n  var firstBlock = blocks.first();\n  var lastBlock = blocks.last();\n\n  // If the fragment only contains a void block, use `insertBlock` instead.\n  if (firstBlock == lastBlock && firstBlock.isVoid) {\n    change.insertBlockAtRange(range, firstBlock, options);\n    return;\n  }\n\n  // If the fragment starts or ends with single nested block, (e.g., table),\n  // do not merge this fragment with existing blocks.\n  if (firstChild.hasBlockChildren() || lastChild.hasBlockChildren()) {\n    fragment.nodes.reverse().forEach(function (node) {\n      change.insertBlockAtRange(range, node, options);\n    });\n    return;\n  }\n\n  // If the first and last block aren't the same, we need to insert all of the\n  // nodes after the fragment's first block at the index.\n  if (firstBlock != lastBlock) {\n    var lonelyParent = fragment.getFurthest(firstBlock.key, function (p) {\n      return p.nodes.size == 1;\n    });\n    var lonelyChild = lonelyParent || firstBlock;\n    var startIndex = parent.nodes.indexOf(startBlock);\n    fragment = fragment.removeNode(lonelyChild.key);\n\n    fragment.nodes.forEach(function (node, i) {\n      var newIndex = startIndex + i + 1;\n      change.insertNodeByKey(parent.key, newIndex, node, { normalize: false });\n    });\n  }\n\n  // Check if we need to split the node.\n  if (startOffset != 0) {\n    change.splitDescendantsByKey(startChild.key, startKey, startOffset, {\n      normalize: false\n    });\n  }\n\n  // Update our variables with the new value.\n  document = change.value.document;\n  startText = document.getDescendant(startKey);\n  startBlock = document.getClosestBlock(startKey);\n  startChild = startBlock.getFurthestAncestor(startText.key);\n\n  // If the first and last block aren't the same, we need to move any of the\n  // starting block's children after the split into the last block of the\n  // fragment, which has already been inserted.\n  if (firstBlock != lastBlock) {\n    var nextChild = isAtStart ? startChild : startBlock.getNextSibling(startChild.key);\n    var nextNodes = nextChild ? startBlock.nodes.skipUntil(function (n) {\n      return n.key == nextChild.key;\n    }) : immutable.List();\n    var lastIndex = lastBlock.nodes.size;\n\n    nextNodes.forEach(function (node, i) {\n      var newIndex = lastIndex + i;\n\n      change.moveNodeByKey(node.key, lastBlock.key, newIndex, {\n        normalize: false\n      });\n    });\n  }\n\n  // If the starting block is empty, we replace it entirely with the first block\n  // of the fragment, since this leads to a more expected behavior for the user.\n  if (startBlock.isEmpty) {\n    change.removeNodeByKey(startBlock.key, { normalize: false });\n    change.insertNodeByKey(parent.key, index, firstBlock, { normalize: false });\n  } else {\n    // Otherwise, we maintain the starting block, and insert all of the first\n    // block's inline nodes into it at the split point.\n    var inlineChild = startBlock.getFurthestAncestor(startText.key);\n    var inlineIndex = startBlock.nodes.indexOf(inlineChild);\n\n    firstBlock.nodes.forEach(function (inline, i) {\n      var o = startOffset == 0 ? 0 : 1;\n      var newIndex = inlineIndex + i + o;\n\n      change.insertNodeByKey(startBlock.key, newIndex, inline, {\n        normalize: false\n      });\n    });\n  }\n\n  // Normalize if requested.\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|String|Object} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.insertInlineAtRange = function (change, range, inline) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  inline = Inline.create(inline);\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false });\n    range = range.collapseToStart();\n  }\n\n  var value = change.value;\n  var document = value.document;\n  var _range5 = range,\n      startKey = _range5.startKey,\n      startOffset = _range5.startOffset;\n\n  var parent = document.getParent(startKey);\n  var startText = document.assertDescendant(startKey);\n  var index = parent.nodes.indexOf(startText);\n\n  if (parent.isVoid) return;\n\n  change.splitNodeByKey(startKey, startOffset, { normalize: false });\n  change.insertNodeByKey(parent.key, index + 1, inline, { normalize: false });\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.insertTextAtRange = function (change, range, text, marks) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var normalize = options.normalize;\n  var value = change.value;\n  var document = value.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var key = startKey;\n  var offset = startOffset;\n  var parent = document.getParent(startKey);\n\n  if (parent.isVoid) return;\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false });\n\n    // Update range start after delete\n    if (change.value.startKey !== key) {\n      key = change.value.startKey;\n      offset = change.value.startOffset;\n    }\n  }\n\n  // PERF: Unless specified, don't normalize if only inserting text.\n  if (normalize === undefined) {\n    normalize = range.isExpanded && marks && marks.size !== 0;\n  }\n\n  change.insertTextByKey(key, offset, text, marks, { normalize: false });\n\n  if (normalize) {\n    // normalize in the narrowest existing block that originally contains startKey and endKey\n    var commonAncestor = document.getCommonAncestor(startKey, range.endKey);\n    var ancestors = document.getAncestors(commonAncestor.key).push(commonAncestor);\n    var normalizeAncestor = ancestors.findLast(function (n) {\n      return change.value.document.getDescendant(n.key);\n    });\n    // it is possible that normalizeAncestor doesn't return any node\n    // on that case fallback to startKey to be normalized\n    var normalizeKey = normalizeAncestor ? normalizeAncestor.key : startKey;\n    change.normalizeNodeByKey(normalizeKey);\n  }\n};\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.removeMarkAtRange = function (change, range, mark) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (range.isCollapsed) return;\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var texts = document.getTextsAtRange(range);\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n\n  texts.forEach(function (node) {\n    var key = node.key;\n\n    var index = 0;\n    var length = node.text.length;\n\n    if (key == startKey) index = startOffset;\n    if (key == endKey) length = endOffset;\n    if (key == startKey && key == endKey) length = endOffset - startOffset;\n\n    change.removeMarkByKey(key, index, length, mark, { normalize: normalize });\n  });\n};\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.setBlocksAtRange = function (change, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var blocks = document.getBlocksAtRange(range);\n\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset,\n      isCollapsed = range.isCollapsed;\n\n  var isStartVoid = document.hasVoidParent(startKey);\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(endKey);\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  var isHanging = isCollapsed == false && startOffset == 0 && endOffset == 0 && isStartVoid == false && startKey == startBlock.getFirstText().key && endKey == endBlock.getFirstText().key;\n\n  // If it's a hanging selection, ignore the last block.\n  var sets = isHanging ? blocks.slice(0, -1) : blocks;\n\n  sets.forEach(function (block) {\n    change.setNodeByKey(block.key, properties, { normalize: normalize });\n  });\n};\n\nChanges$1.setBlockAtRange = function () {\n  logger.deprecate('slate@0.33.0', 'The `setBlockAtRange` method of Slate changes has been renamed to `setBlocksAtRange`.');\n\n  Changes$1.setBlocksAtRange.apply(Changes$1, arguments);\n};\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.setInlinesAtRange = function (change, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var inlines = document.getInlinesAtRange(range);\n\n  inlines.forEach(function (inline) {\n    change.setNodeByKey(inline.key, properties, { normalize: normalize });\n  });\n};\n\nChanges$1.setInlineAtRange = function () {\n  logger.deprecate('slate@0.33.0', 'The `setInlineAtRange` method of Slate changes has been renamed to `setInlinesAtRange`.');\n\n  Changes$1.setInlinesAtRange.apply(Changes$1, arguments);\n};\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.splitBlockAtRange = function (change, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var normalize = change.getFlag('normalize', options);\n\n  var _range6 = range,\n      startKey = _range6.startKey,\n      startOffset = _range6.startOffset,\n      endOffset = _range6.endOffset,\n      endKey = _range6.endKey;\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.assertDescendant(startKey);\n  var parent = document.getClosestBlock(node.key);\n  var h = 0;\n\n  while (parent && parent.object == 'block' && h < height) {\n    node = parent;\n    parent = document.getClosestBlock(parent.key);\n    h++;\n  }\n\n  change.splitDescendantsByKey(node.key, startKey, startOffset, {\n    normalize: normalize && range.isCollapsed\n  });\n\n  if (range.isExpanded) {\n    if (range.isBackward) range = range.flip();\n    var nextBlock = change.value.document.getNextBlock(node.key);\n    range = range.moveAnchorToStartOf(nextBlock);\n\n    if (startKey === endKey) {\n      range = range.moveFocusTo(range.anchorKey, endOffset - startOffset);\n    }\n\n    change.deleteAtRange(range, { normalize: normalize });\n  }\n};\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.splitInlineAtRange = function (change, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var normalize = change.getFlag('normalize', options);\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: normalize });\n    range = range.collapseToStart();\n  }\n\n  var _range7 = range,\n      startKey = _range7.startKey,\n      startOffset = _range7.startOffset;\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.assertDescendant(startKey);\n  var parent = document.getClosestInline(node.key);\n  var h = 0;\n\n  while (parent && parent.object == 'inline' && h < height) {\n    node = parent;\n    parent = document.getClosestInline(parent.key);\n    h++;\n  }\n\n  change.splitDescendantsByKey(node.key, startKey, startOffset, { normalize: normalize });\n};\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.toggleMarkAtRange = function (change, range, mark) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (range.isCollapsed) return;\n\n  mark = Mark.create(mark);\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var marks = document.getActiveMarksAtRange(range);\n  var exists = marks.some(function (m) {\n    return m.equals(mark);\n  });\n\n  if (exists) {\n    change.removeMarkAtRange(range, mark, { normalize: normalize });\n  } else {\n    change.addMarkAtRange(range, mark, { normalize: normalize });\n  }\n};\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.unwrapBlockAtRange = function (change, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  properties = Node.createProperties(properties);\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var blocks = document.getBlocksAtRange(range);\n  var wrappers = blocks.map(function (block) {\n    return document.getClosest(block.key, function (parent) {\n      if (parent.object != 'block') return false;\n      if (properties.type != null && parent.type != properties.type) return false;\n      if (properties.isVoid != null && parent.isVoid != properties.isVoid) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n\n  wrappers.forEach(function (block) {\n    var first = block.nodes.first();\n    var last = block.nodes.last();\n    var parent = document.getParent(block.key);\n    var index = parent.nodes.indexOf(block);\n\n    var children = block.nodes.filter(function (child) {\n      return blocks.some(function (b) {\n        return child == b || child.hasDescendant(b.key);\n      });\n    });\n\n    var firstMatch = children.first();\n    var lastMatch = children.last();\n\n    if (first == firstMatch && last == lastMatch) {\n      block.nodes.forEach(function (child, i) {\n        change.moveNodeByKey(child.key, parent.key, index + i, {\n          normalize: false\n        });\n      });\n\n      change.removeNodeByKey(block.key, { normalize: false });\n    } else if (last == lastMatch) {\n      block.nodes.skipUntil(function (n) {\n        return n == firstMatch;\n      }).forEach(function (child, i) {\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false\n        });\n      });\n    } else if (first == firstMatch) {\n      block.nodes.takeUntil(function (n) {\n        return n == lastMatch;\n      }).push(lastMatch).forEach(function (child, i) {\n        change.moveNodeByKey(child.key, parent.key, index + i, {\n          normalize: false\n        });\n      });\n    } else {\n      var firstText = firstMatch.getFirstText();\n\n      change.splitDescendantsByKey(block.key, firstText.key, 0, {\n        normalize: false\n      });\n\n      document = change.value.document;\n\n      children.forEach(function (child, i) {\n        if (i == 0) {\n          var extra = child;\n          child = document.getNextBlock(child.key);\n          change.removeNodeByKey(extra.key, { normalize: false });\n        }\n\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false\n        });\n      });\n    }\n  });\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument();\n  }\n};\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.unwrapInlineAtRange = function (change, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  properties = Node.createProperties(properties);\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n  var texts = document.getTextsAtRange(range);\n  var inlines = texts.map(function (text) {\n    return document.getClosest(text.key, function (parent) {\n      if (parent.object != 'inline') return false;\n      if (properties.type != null && parent.type != properties.type) return false;\n      if (properties.isVoid != null && parent.isVoid != properties.isVoid) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n\n  inlines.forEach(function (inline) {\n    var parent = change.value.document.getParent(inline.key);\n    var index = parent.nodes.indexOf(inline);\n\n    inline.nodes.forEach(function (child, i) {\n      change.moveNodeByKey(child.key, parent.key, index + i, {\n        normalize: false\n      });\n    });\n  });\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument();\n  }\n};\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|Object|String} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.wrapBlockAtRange = function (change, range, block) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  block = Block.create(block);\n  block = block.set('nodes', block.nodes.clear());\n\n  var normalize = change.getFlag('normalize', options);\n  var value = change.value;\n  var document = value.document;\n\n\n  var blocks = document.getBlocksAtRange(range);\n  var firstblock = blocks.first();\n  var lastblock = blocks.last();\n  var parent = void 0,\n      siblings = void 0,\n      index = void 0;\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key);\n    siblings = blocks;\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, function (p1) {\n      return !!document.getClosest(lastblock.key, function (p2) {\n        return p1 == p2;\n      });\n    });\n  }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document;\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    var indexes = parent.nodes.reduce(function (ind, node, i) {\n      if (node == firstblock || node.hasDescendant(firstblock.key)) ind[0] = i;\n      if (node == lastblock || node.hasDescendant(lastblock.key)) ind[1] = i;\n      return ind;\n    }, []);\n\n    index = indexes[0];\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1);\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first());\n  }\n\n  // Inject the new block node into the parent.\n  change.insertNodeByKey(parent.key, index, block, { normalize: false });\n\n  // Move the sibling nodes into the new block node.\n  siblings.forEach(function (node, i) {\n    change.moveNodeByKey(node.key, block.key, i, { normalize: false });\n  });\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key);\n  }\n};\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|Object|String} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.wrapInlineAtRange = function (change, range, inline) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var value = change.value;\n  var document = value.document;\n\n  var normalize = change.getFlag('normalize', options);\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    var inlineParent = document.getClosestInline(startKey);\n\n    if (!inlineParent.isVoid) {\n      return;\n    }\n\n    return change.wrapInlineByKey(inlineParent.key, inline, options);\n  }\n\n  inline = Inline.create(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n\n  var blocks = document.getBlocksAtRange(range);\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(endKey);\n  var startInline = document.getClosestInline(startKey);\n  var endInline = document.getClosestInline(endKey);\n  var startChild = startBlock.getFurthestAncestor(startKey);\n  var endChild = endBlock.getFurthestAncestor(endKey);\n\n  if (!startInline || startInline != endInline) {\n    change.splitDescendantsByKey(endChild.key, endKey, endOffset, {\n      normalize: false\n    });\n\n    change.splitDescendantsByKey(startChild.key, startKey, startOffset, {\n      normalize: false\n    });\n  }\n\n  document = change.value.document;\n  startBlock = document.getDescendant(startBlock.key);\n  endBlock = document.getDescendant(endBlock.key);\n  startChild = startBlock.getFurthestAncestor(startKey);\n  endChild = endBlock.getFurthestAncestor(endKey);\n  var startIndex = startBlock.nodes.indexOf(startChild);\n  var endIndex = endBlock.nodes.indexOf(endChild);\n\n  if (startInline && startInline == endInline) {\n    var text = startBlock.getTextsAtRange(range).get(0).splitText(startOffset)[1].splitText(endOffset - startOffset)[0];\n    inline = inline.set('nodes', immutable.List([text]));\n    Changes$1.insertInlineAtRange(change, range, inline, { normalize: false });\n    var inlinekey = inline.getFirstText().key;\n    var rng = {\n      anchorKey: inlinekey,\n      focusKey: inlinekey,\n      anchorOffset: 0,\n      focusOffset: endOffset - startOffset,\n      isFocused: true\n    };\n    change.select(rng);\n  } else if (startBlock == endBlock) {\n    document = change.value.document;\n    startBlock = document.getClosestBlock(startKey);\n    startChild = startBlock.getFurthestAncestor(startKey);\n\n    var startInner = document.getNextSibling(startChild.key);\n    var startInnerIndex = startBlock.nodes.indexOf(startInner);\n    var endInner = startKey == endKey ? startInner : startBlock.getFurthestAncestor(endKey);\n    var inlines = startBlock.nodes.skipUntil(function (n) {\n      return n == startInner;\n    }).takeUntil(function (n) {\n      return n == endInner;\n    }).push(endInner);\n\n    var node = inline.regenerateKey();\n\n    change.insertNodeByKey(startBlock.key, startInnerIndex, node, {\n      normalize: false\n    });\n\n    inlines.forEach(function (child, i) {\n      change.moveNodeByKey(child.key, node.key, i, { normalize: false });\n    });\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key);\n    }\n  } else {\n    var startInlines = startBlock.nodes.slice(startIndex + 1);\n    var endInlines = endBlock.nodes.slice(0, endIndex + 1);\n    var startNode = inline.regenerateKey();\n    var endNode = inline.regenerateKey();\n\n    change.insertNodeByKey(startBlock.key, startIndex + 1, startNode, {\n      normalize: false\n    });\n\n    change.insertNodeByKey(endBlock.key, endIndex, endNode, {\n      normalize: false\n    });\n\n    startInlines.forEach(function (child, i) {\n      change.moveNodeByKey(child.key, startNode.key, i, { normalize: false });\n    });\n\n    endInlines.forEach(function (child, i) {\n      change.moveNodeByKey(child.key, endNode.key, i, { normalize: false });\n    });\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key).normalizeNodeByKey(endBlock.key);\n    }\n\n    blocks.slice(1, -1).forEach(function (block) {\n      var node = inline.regenerateKey();\n      change.insertNodeByKey(block.key, 0, node, { normalize: false });\n\n      block.nodes.forEach(function (child, i) {\n        change.moveNodeByKey(child.key, node.key, i, { normalize: false });\n      });\n\n      if (normalize) {\n        change.normalizeNodeByKey(block.key);\n      }\n    });\n  }\n};\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges$1.wrapTextAtRange = function (change, range, prefix) {\n  var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prefix;\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  var startKey = range.startKey,\n      endKey = range.endKey;\n\n  var start = range.collapseToStart();\n  var end = range.collapseToEnd();\n\n  if (startKey == endKey) {\n    end = end.move(prefix.length);\n  }\n\n  change.insertTextAtRange(start, prefix, [], { normalize: normalize });\n  change.insertTextAtRange(end, suffix, [], { normalize: normalize });\n};\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes$2 = {};\n\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n * @param {Object} options\n */\n\nChanges$2.addMarkByPath = function (change, path, offset, length, mark, options) {\n  mark = Mark.create(mark);\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n  var leaves = node.getLeaves();\n\n  var operations = [];\n  var bx = offset;\n  var by = offset + length;\n  var o = 0;\n\n  leaves.forEach(function (leaf) {\n    var ax = o;\n    var ay = ax + leaf.text.length;\n\n    o += leaf.text.length;\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return;\n\n    // If the leaf already has the mark, continue on.\n    if (leaf.marks.has(mark)) return;\n\n    // Otherwise, determine which offset and characters overlap.\n    var start = Math.max(ax, bx);\n    var end = Math.min(ay, by);\n\n    operations.push({\n      type: 'add_mark',\n      value: value,\n      path: path,\n      offset: start,\n      length: end - start,\n      mark: mark\n    });\n  });\n\n  change.applyOperations(operations);\n  change.normalizeParentByPath(path, options);\n};\n\n/**\n * Insert a `fragment` at `index` in a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} index\n * @param {Fragment} fragment\n * @param {Object} options\n */\n\nChanges$2.insertFragmentByPath = function (change, path, index, fragment, options) {\n  fragment.nodes.forEach(function (node, i) {\n    change.insertNodeByPath(path, index + i, node);\n  });\n\n  change.normalizeNodeByPath(path, options);\n};\n\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} index\n * @param {Node} node\n * @param {Object} options\n */\n\nChanges$2.insertNodeByPath = function (change, path, index, node, options) {\n  var value = change.value;\n\n\n  change.applyOperation({\n    type: 'insert_node',\n    value: value,\n    path: path.concat(index),\n    node: node\n  });\n\n  change.normalizeNodeByPath(path, options);\n};\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n */\n\nChanges$2.insertTextByPath = function (change, path, offset, text, marks, options) {\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n  marks = marks || node.getMarksAtIndex(offset);\n\n  change.applyOperation({\n    type: 'insert_text',\n    value: value,\n    path: path,\n    offset: offset,\n    text: text,\n    marks: marks\n  });\n\n  change.normalizeParentByPath(path, options);\n};\n\n/**\n * Merge a node by `path` with the previous node.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object} options\n */\n\nChanges$2.mergeNodeByPath = function (change, path, options) {\n  var value = change.value;\n  var document = value.document;\n\n  var original = document.getDescendant(path);\n  var previous = document.getPreviousSibling(path);\n\n  if (!previous) {\n    throw new Error('Unable to merge node with path \"' + path + '\", because it has no previous sibling.');\n  }\n\n  var position = previous.object == 'text' ? previous.text.length : previous.nodes.size;\n\n  change.applyOperation({\n    type: 'merge_node',\n    value: value,\n    path: path,\n    position: position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data\n    },\n    target: null\n  });\n\n  change.normalizeParentByPath(path, options);\n};\n\n/**\n * Move a node by `path` to a new parent by `newPath` and `index`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {String} newPath\n * @param {Number} index\n * @param {Object} options\n */\n\nChanges$2.moveNodeByPath = function (change, path, newPath, newIndex, options) {\n  var value = change.value;\n\n\n  change.applyOperation({\n    type: 'move_node',\n    value: value,\n    path: path,\n    newPath: newPath.concat(newIndex)\n  });\n\n  var ancestorPath = PathUtils.relate(path, newPath);\n  change.normalizeNodeByPath(ancestorPath, options);\n};\n\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n */\n\nChanges$2.removeMarkByPath = function (change, path, offset, length, mark, options) {\n  mark = Mark.create(mark);\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n  var leaves = node.getLeaves();\n\n  var operations = [];\n  var bx = offset;\n  var by = offset + length;\n  var o = 0;\n\n  leaves.forEach(function (leaf) {\n    var ax = o;\n    var ay = ax + leaf.text.length;\n\n    o += leaf.text.length;\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return;\n\n    // If the leaf already has the mark, continue on.\n    if (!leaf.marks.has(mark)) return;\n\n    // Otherwise, determine which offset and characters overlap.\n    var start = Math.max(ax, bx);\n    var end = Math.min(ay, by);\n\n    operations.push({\n      type: 'remove_mark',\n      value: value,\n      path: path,\n      offset: start,\n      length: end - start,\n      mark: mark\n    });\n  });\n\n  change.applyOperations(operations);\n  change.normalizeParentByPath(path, options);\n};\n\n/**\n * Remove all `marks` from node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object} options\n */\n\nChanges$2.removeAllMarksByPath = function (change, path, options) {\n  var state = change.state;\n  var document = state.document;\n\n  var node = document.assertNode(path);\n  var texts = node.object === 'text' ? [node] : node.getTextsAsArray();\n\n  texts.forEach(function (text) {\n    text.getMarksAsArray().forEach(function (mark) {\n      change.removeMarkByKey(text.key, 0, text.text.length, mark, options);\n    });\n  });\n};\n\n/**\n * Remove a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object} options\n */\n\nChanges$2.removeNodeByPath = function (change, path, options) {\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n\n  change.applyOperation({\n    type: 'remove_node',\n    value: value,\n    path: path,\n    node: node\n  });\n\n  change.normalizeParentByPath(path, options);\n};\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n */\n\nChanges$2.setTextByPath = function (change, path, text, marks, options) {\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n  var end = node.text.length;\n  change.replaceTextByPath(path, 0, end, text, marks, options);\n};\n\n/**\n * Replace A Length of Text with another string or text\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *\n */\n\nChanges$2.replaceTextByPath = function (change, path, offset, length, text, marks, options) {\n  var document = change.value.document;\n\n  var node = document.assertNode(path);\n\n  if (length + offset > node.text.length) {\n    length = node.text.length - offset;\n  }\n\n  var range = Range.create({\n    anchorPath: path,\n    focusPath: path,\n    anchorOffset: offset,\n    focusOffset: offset + length\n  }).normalize(document);\n\n  var activeMarks = document.getActiveMarksAtRange(range);\n\n  change.removeTextByPath(path, offset, length, { normalize: false });\n\n  if (!marks) {\n    // Do not use mark at index when marks and activeMarks are both empty\n    marks = activeMarks ? activeMarks : [];\n  } else if (activeMarks) {\n    // Do not use `has` because we may want to reset marks like font-size with an updated data;\n    activeMarks = activeMarks.filter(function (activeMark) {\n      return !marks.find(function (m) {\n        return activeMark.type === m.type;\n      });\n    });\n\n    marks = activeMarks.merge(marks);\n  }\n\n  change.insertTextByPath(path, offset, text, marks, options);\n};\n\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Object} options\n */\n\nChanges$2.removeTextByPath = function (change, path, offset, length, options) {\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n  var leaves = node.getLeaves();\n  var text = node.text;\n\n\n  var removals = [];\n  var bx = offset;\n  var by = offset + length;\n  var o = 0;\n\n  leaves.forEach(function (leaf) {\n    var ax = o;\n    var ay = ax + leaf.text.length;\n\n    o += leaf.text.length;\n\n    // If the leaf doesn't overlap with the removal, continue on.\n    if (ay < bx || by < ax) return;\n\n    // Otherwise, determine which offset and characters overlap.\n    var start = Math.max(ax, bx);\n    var end = Math.min(ay, by);\n    var string = text.slice(start, end);\n\n    removals.push({\n      type: 'remove_text',\n      value: value,\n      path: path,\n      offset: start,\n      text: string,\n      marks: leaf.marks\n    });\n  });\n\n  // Apply in reverse order, so subsequent removals don't impact previous ones.\n  change.applyOperations(removals.reverse());\n\n  var block = document.getClosestBlock(node.key);\n  change.normalizeNodeByKey(block.key, options);\n};\n\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|Node} node\n * @param {Object} options\n */\n\nChanges$2.replaceNodeByPath = function (change, path, newNode, options) {\n  newNode = Node.create(newNode);\n  var index = path.last();\n  var parentPath = PathUtils.lift(path);\n  change.removeNodeByPath(path, { normalize: false });\n  change.insertNodeByPath(parentPath, index, newNode, { normalize: false });\n  change.normalizeParentByPath(path, options);\n};\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n */\n\nChanges$2.setMarkByPath = function (change, path, offset, length, mark, properties, options) {\n  mark = Mark.create(mark);\n  properties = Mark.createProperties(properties);\n  var value = change.value;\n\n\n  change.applyOperation({\n    type: 'set_mark',\n    value: value,\n    path: path,\n    offset: offset,\n    length: length,\n    mark: mark,\n    properties: properties\n  });\n\n  change.normalizeParentByPath(path, options);\n};\n\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|String} properties\n * @param {Object} options\n */\n\nChanges$2.setNodeByPath = function (change, path, properties, options) {\n  properties = Node.createProperties(properties);\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n\n  change.applyOperation({\n    type: 'set_node',\n    value: value,\n    path: path,\n    node: node,\n    properties: properties\n  });\n\n  change.normalizeNodeByPath(path, options);\n};\n\n/**\n * Split a node by `path` at `position`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} position\n * @param {Object} options\n */\n\nChanges$2.splitNodeByPath = function (change, path, position) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$target = options.target,\n      target = _options$target === undefined ? null : _options$target;\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.getDescendant(path);\n\n  change.applyOperation({\n    type: 'split_node',\n    value: value,\n    path: path,\n    position: position,\n    properties: {\n      type: node.type,\n      data: node.data\n    },\n    target: target\n  });\n\n  change.normalizeParentByPath(path, options);\n};\n\n/**\n * Split a node deeply down the tree by `path`, `textPath` and `textOffset`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Array} textPath\n * @param {Number} textOffset\n * @param {Object} options\n */\n\nChanges$2.splitDescendantsByPath = function (change, path, textPath, textOffset, options) {\n  if (path.equals(textPath)) {\n    change.splitNodeByPath(textPath, textOffset, options);\n    return;\n  }\n\n  var value = change.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n  var text = document.assertNode(textPath);\n  var ancestors = document.getAncestors(textPath);\n  var nodes = ancestors.skipUntil(function (a) {\n    return a.key == node.key;\n  }).reverse().unshift(text);\n\n  var previous = void 0;\n  var index = void 0;\n\n  nodes.forEach(function (n) {\n    var prevIndex = index == null ? null : index;\n    index = previous ? n.nodes.indexOf(previous) + 1 : textOffset;\n    previous = n;\n\n    change.splitNodeByKey(n.key, index, {\n      normalize: false,\n      target: prevIndex\n    });\n  });\n\n  change.normalizeParentByPath(path, options);\n};\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|String} properties\n * @param {Object} options\n */\n\nChanges$2.unwrapInlineByPath = function (change, path, properties, options) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var node = document.assertNode(path);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOf(first, last);\n  change.unwrapInlineAtRange(range, properties, options);\n};\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|String} properties\n * @param {Object} options\n */\n\nChanges$2.unwrapBlockByPath = function (change, path, properties, options) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var node = document.assertNode(path);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOf(first, last);\n  change.unwrapBlockAtRange(range, properties, options);\n};\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object} options\n */\n\nChanges$2.unwrapNodeByPath = function (change, path, options) {\n  var value = change.value;\n  var document = value.document;\n\n  document.assertNode(path);\n\n  var parentPath = PathUtils.lift(path);\n  var parent = document.assertNode(parentPath);\n  var index = path.last();\n  var parentIndex = parentPath.last();\n  var grandPath = PathUtils.lift(parentPath);\n  var isFirst = index === 0;\n  var isLast = index === parent.nodes.size - 1;\n\n  if (parent.nodes.size === 1) {\n    change.moveNodeByPath(path, grandPath, parentIndex + 1, {\n      normalize: false\n    });\n\n    change.removeNodeByPath(parentPath, options);\n  } else if (isFirst) {\n    change.moveNodeByPath(path, grandPath, parentIndex, options);\n  } else if (isLast) {\n    change.moveNodeByPath(path, grandPath, parentIndex + 1, options);\n  } else {\n    change.splitNodeByPath(parentPath, index, { normalize: false });\n\n    var updatedPath = PathUtils.increment(path, 1, parentPath.size - 1);\n    updatedPath = updatedPath.set(updatedPath.size - 1, 0);\n\n    change.moveNodeByPath(updatedPath, grandPath, parentIndex + 1, {\n      normalize: false\n    });\n\n    change.normalizeNodeByPath(grandPath, options);\n  }\n};\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Block|Object|String} block\n * @param {Object} options\n */\n\nChanges$2.wrapBlockByPath = function (change, path, block, options) {\n  block = Block.create(block);\n  block = block.set('nodes', block.nodes.clear());\n  var parentPath = PathUtils.lift(path);\n  var index = path.last();\n  var newPath = PathUtils.increment(path);\n  change.insertNodeByPath(parentPath, index, block, { normalize: false });\n  change.moveNodeByPath(newPath, path, 0, options);\n};\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Block|Object|String} inline\n * @param {Object} options\n */\n\nChanges$2.wrapInlineByPath = function (change, path, inline, options) {\n  inline = Inline.create(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n  var parentPath = PathUtils.lift(path);\n  var index = path.last();\n  var newPath = PathUtils.increment(path);\n  change.insertNodeByPath(parentPath, index, inline, { normalize: false });\n  change.moveNodeByPath(newPath, path, 0, options);\n};\n\n/**\n * Wrap a node by `path` with `node`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Node|Object} node\n * @param {Object} options\n */\n\nChanges$2.wrapNodeByPath = function (change, path, node) {\n  node = Node.create(node);\n\n  if (node.object == 'block') {\n    change.wrapBlockByPath(path, node);\n    return;\n  }\n\n  if (node.object == 'inline') {\n    change.wrapInlineByPath(path, node);\n    return;\n  }\n};\n\n/**\n * Mix in `*ByKey` variants.\n */\n\nvar CHANGES = ['addMark', 'insertFragment', 'insertNode', 'insertText', 'mergeNode', 'removeMark', 'removeAllMarks', 'removeNode', 'setText', 'replaceText', 'removeText', 'replaceNode', 'setMark', 'setNode', 'splitNode', 'unwrapInline', 'unwrapBlock', 'unwrapNode', 'wrapBlock', 'wrapInline', 'wrapNode'];\n\nvar _loop$1 = function _loop(method) {\n  Changes$2[method + 'ByKey'] = function (change, key) {\n    for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      args[_key3 - 2] = arguments[_key3];\n    }\n\n    var value = change.value;\n    var document = value.document;\n\n    var path = document.assertPath(key);\n    change[method + 'ByPath'].apply(change, [path].concat(args));\n  };\n};\n\nvar _iteratorNormalCompletion = true;\nvar _didIteratorError = false;\nvar _iteratorError = undefined;\n\ntry {\n  for (var _iterator = CHANGES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n    var method$1 = _step.value;\n\n    _loop$1(method$1);\n  }\n\n  // Moving nodes takes two keys, so it's slightly different.\n} catch (err) {\n  _didIteratorError = true;\n  _iteratorError = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion && _iterator.return) {\n      _iterator.return();\n    }\n  } finally {\n    if (_didIteratorError) {\n      throw _iteratorError;\n    }\n  }\n}\n\nChanges$2.moveNodeByKey = function (change, key, newKey) {\n  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.assertPath(key);\n  var newPath = document.assertPath(newKey);\n  change.moveNodeByPath.apply(change, [path, newPath].concat(args));\n};\n\n// Splitting descendants takes two keys, so it's slightly different.\nChanges$2.splitDescendantsByKey = function (change, key, textKey) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    args[_key2 - 3] = arguments[_key2];\n  }\n\n  var value = change.value;\n  var document = value.document;\n\n  var path = document.assertPath(key);\n  var textPath = document.assertPath(textKey);\n  change.splitDescendantsByPath.apply(change, [path, textPath].concat(args));\n};\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = Debug('slate:history');\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$8 = {\n  redos: new immutable.Stack(),\n  undos: new immutable.Stack()\n\n  /**\n   * History.\n   *\n   * @type {History}\n   */\n\n};\nvar History = function (_Record) {\n  inherits(History, _Record);\n\n  function History() {\n    classCallCheck(this, History);\n    return possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).apply(this, arguments));\n  }\n\n  createClass(History, [{\n    key: 'save',\n\n\n    /**\n     * Save an `operation` into the history.\n     *\n     * @param {Object} operation\n     * @param {Object} options\n     * @return {History}\n     */\n\n    value: function save(operation) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var history = this;\n      var _history = history,\n          undos = _history.undos,\n          redos = _history.redos;\n      var merge = options.merge,\n          skip = options.skip;\n\n      var prevBatch = undos.peek();\n      var prevOperation = prevBatch && prevBatch.last();\n\n      if (skip == null) {\n        skip = shouldSkip(operation, prevOperation);\n      }\n\n      if (skip) {\n        return history;\n      }\n\n      if (merge == null) {\n        merge = shouldMerge(operation, prevOperation);\n      }\n\n      debug('save', { operation: operation, merge: merge });\n\n      // If the `merge` flag is true, add the operation to the previous batch.\n      if (merge && prevBatch) {\n        var batch = prevBatch.push(operation);\n        undos = undos.pop();\n        undos = undos.push(batch);\n      } else {\n        // Otherwise, create a new batch with the operation.\n        var _batch = new immutable.List([operation]);\n        undos = undos.push(_batch);\n      }\n\n      // Constrain the history to 100 entries for memory's sake.\n      if (undos.size > 100) {\n        undos = undos.take(100);\n      }\n\n      // Clear the redos and update the history.\n      redos = redos.clear();\n      history = history.set('undos', undos).set('redos', redos);\n      return history;\n    }\n\n    /**\n     * Return a JSON representation of the history.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        redos: this.redos.toJSON(),\n        undos: this.undos.toJSON()\n      };\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS() {\n      return this.toJSON();\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'history';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `History` with `attrs`.\n     *\n     * @param {Object|History} attrs\n     * @return {History}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (History.isHistory(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return History.fromJSON(attrs);\n      }\n\n      throw new Error('`History.create` only accepts objects or histories, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Operations` from `operations`.\n     *\n     * @param {Array<Object>|List<Object>} operations\n     * @return {List<Object>}\n     */\n\n  }, {\n    key: 'createOperationsList',\n    value: function createOperationsList() {\n      var operations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(operations)) {\n        return operations;\n      }\n\n      if (Array.isArray(operations)) {\n        return new immutable.List(operations);\n      }\n\n      throw new Error('`History.createList` only accepts arrays or lists, but you passed it: ' + operations);\n    }\n\n    /**\n     * Create a `History` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {History}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$redos = object.redos,\n          redos = _object$redos === undefined ? [] : _object$redos,\n          _object$undos = object.undos,\n          undos = _object$undos === undefined ? [] : _object$undos;\n\n\n      var history = new History({\n        redos: new immutable.Stack(redos.map(this.createOperationsList)),\n        undos: new immutable.Stack(undos.map(this.createOperationsList))\n      });\n\n      return history;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    /**\n     * Check if `any` is a `History`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }]);\n  return History;\n}(immutable.Record(DEFAULTS$8));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nHistory.fromJS = History.fromJSON;\nHistory.isHistory = isType.bind(null, 'HISTORY');\nHistory.prototype[MODEL_TYPES.HISTORY] = true;\n\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldMerge(o, p) {\n  if (!p) return false;\n\n  var merge = o.type == 'set_selection' && p.type == 'set_selection' || o.type == 'insert_text' && p.type == 'insert_text' && o.offset == p.offset + p.text.length && isEqual(o.path, p.path) || o.type == 'remove_text' && p.type == 'remove_text' && o.offset + o.text.length == p.offset && isEqual(o.path, p.path);\n\n  return merge;\n}\n\n/**\n * Check whether to skip a new operation `o`, given previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldSkip(o, p) {\n  if (!p) return false;\n\n  var skip = o.type == 'set_selection' && p.type == 'set_selection';\n\n  return skip;\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$9 = {\n  plugins: []\n\n  /**\n   * Stack.\n   *\n   * @type {Stack}\n   */\n\n};\nvar Stack = function (_Record) {\n  inherits(Stack, _Record);\n\n  function Stack() {\n    classCallCheck(this, Stack);\n    return possibleConstructorReturn(this, (Stack.__proto__ || Object.getPrototypeOf(Stack)).apply(this, arguments));\n  }\n\n  createClass(Stack, [{\n    key: 'getPluginsWith',\n\n\n    /**\n     * Get all plugins with `property`.\n     *\n     * @param {String} property\n     * @return {Array}\n     */\n\n    value: function getPluginsWith(property) {\n      return this.plugins.filter(function (plugin) {\n        return plugin[property] != null;\n      });\n    }\n\n    /**\n     * Iterate the plugins with `property`, returning the first non-null value.\n     *\n     * @param {String} property\n     * @param {Any} ...args\n     */\n\n  }, {\n    key: 'find',\n    value: function find(property) {\n      var plugins = this.getPluginsWith(property);\n\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var plugin = _step.value;\n\n          var ret = plugin[property].apply(plugin, args);\n          if (ret != null) return ret;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    /**\n     * Iterate the plugins with `property`, returning all the non-null values.\n     *\n     * @param {String} property\n     * @param {Any} ...args\n     * @return {Array}\n     */\n\n  }, {\n    key: 'map',\n    value: function map(property) {\n      var plugins = this.getPluginsWith(property);\n      var array = [];\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = plugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var plugin = _step2.value;\n\n          var ret = plugin[property].apply(plugin, args);\n          if (ret != null) array.push(ret);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return array;\n    }\n\n    /**\n     * Iterate the plugins with `property`, breaking on any a non-null values.\n     *\n     * @param {String} property\n     * @param {Any} ...args\n     */\n\n  }, {\n    key: 'run',\n    value: function run(property) {\n      var plugins = this.getPluginsWith(property);\n\n      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = plugins[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var plugin = _step3.value;\n\n          var ret = plugin[property].apply(plugin, args);\n          if (ret != null) return;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n\n    /**\n     * Iterate the plugins with `property`, reducing to a set of React children.\n     *\n     * @param {String} property\n     * @param {Object} props\n     * @param {Any} ...args\n     */\n\n  }, {\n    key: 'render',\n    value: function render(property, props) {\n      for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        args[_key4 - 2] = arguments[_key4];\n      }\n\n      var plugins = this.getPluginsWith(property);\n      return plugins.reduceRight(function (children, plugin) {\n        if (!plugin[property]) return children;\n        var ret = plugin[property].apply(plugin, [props].concat(args));\n        if (ret == null) return children;\n        props.children = ret;\n        return ret;\n      }, props.children === undefined ? null : props.children);\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'stack';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Constructor.\n     *\n     * @param {Object} attrs\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _attrs$plugins = attrs.plugins,\n          plugins = _attrs$plugins === undefined ? [] : _attrs$plugins;\n\n      var stack = new Stack({ plugins: plugins });\n      return stack;\n    }\n\n    /**\n     * Check if `any` is a `Stack`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isStack',\n    value: function isStack(any) {\n      return !!(any && any[MODEL_TYPES.STACK]);\n    }\n  }]);\n  return Stack;\n}(immutable.Record(DEFAULTS$9));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nStack.prototype[MODEL_TYPES.STACK] = true;\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Stack.prototype, ['getPluginsWith']);\n\n/**\n * Define a Slate error.\n *\n * @type {SlateError}\n */\n\nvar SlateError = function (_Error) {\n  inherits(SlateError, _Error);\n\n  function SlateError(code) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, SlateError);\n\n    var _this = possibleConstructorReturn(this, (SlateError.__proto__ || Object.getPrototypeOf(SlateError)).call(this, code));\n\n    _this.code = code;\n\n    for (var key in attrs) {\n      _this[key] = attrs[key];\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_this, _this.constructor);\n    } else {\n      _this.stack = new Error().stack;\n    }\n    return _this;\n  }\n\n  return SlateError;\n}(Error);\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$1 = Debug('slate:schema');\n\n/**\n * Define the core schema rules, order-sensitive.\n *\n * @type {Array}\n */\n\nvar CORE_RULES = [\n// Only allow block nodes in documents.\n{\n  match: { object: 'document' },\n  nodes: [{\n    match: { object: 'block' }\n  }]\n},\n\n// Only allow block nodes or inline and text nodes in blocks.\n{\n  match: {\n    object: 'block',\n    first: { object: 'block' }\n  },\n  nodes: [{\n    match: { object: 'block' }\n  }]\n}, {\n  match: {\n    object: 'block',\n    first: [{ object: 'inline' }, { object: 'text' }]\n  },\n  nodes: [{\n    match: [{ object: 'inline' }, { object: 'text' }]\n  }]\n},\n\n// Only allow inline and text nodes in inlines.\n{\n  match: { object: 'inline' },\n  nodes: [{ match: [{ object: 'inline' }, { object: 'text' }] }]\n},\n\n// Ensure that block and inline nodes have at least one text child.\n{\n  match: [{ object: 'block' }, { object: 'inline' }],\n  nodes: [{ min: 1 }],\n  normalize: function normalize(change, error) {\n    var code = error.code,\n        node = error.node;\n\n    if (code !== 'child_required') return;\n    change.insertNodeByKey(node.key, 0, Text.create(), { normalize: false });\n  }\n},\n\n// Ensure that inline non-void nodes are never empty.\n{\n  match: {\n    object: 'inline',\n    isVoid: false,\n    nodes: [{ match: { object: 'text' } }]\n  },\n  text: /[\\w\\W]+/\n},\n\n// Ensure that inline void nodes are surrounded by text nodes.\n{\n  match: { object: 'block' },\n  first: [{ object: 'block' }, { object: 'text' }],\n  last: [{ object: 'block' }, { object: 'text' }],\n  normalize: function normalize(change, error) {\n    var code = error.code,\n        node = error.node;\n\n    var text = Text.create();\n    var i = void 0;\n\n    if (code === 'first_child_object_invalid') {\n      i = 0;\n    } else if (code === 'last_child_object_invalid') {\n      i = node.nodes.size;\n    } else {\n      return;\n    }\n\n    change.insertNodeByKey(node.key, i, text, { normalize: false });\n  }\n}, {\n  match: { object: 'inline' },\n  first: [{ object: 'block' }, { object: 'text' }],\n  last: [{ object: 'block' }, { object: 'text' }],\n  previous: [{ object: 'block' }, { object: 'text' }],\n  next: [{ object: 'block' }, { object: 'text' }],\n  normalize: function normalize(change, error) {\n    var code = error.code,\n        node = error.node,\n        index = error.index;\n\n    var text = Text.create();\n    var i = void 0;\n\n    if (code === 'first_child_object_invalid') {\n      i = 0;\n    } else if (code === 'last_child_object_invalid') {\n      i = node.nodes.size;\n    } else if (code === 'previous_sibling_object_invalid') {\n      i = index;\n    } else if (code === 'next_sibling_object_invalid') {\n      i = index + 1;\n    } else {\n      return;\n    }\n\n    change.insertNodeByKey(node.key, i, text, { normalize: false });\n  }\n},\n\n// Merge adjacent text nodes.\n{\n  match: { object: 'text' },\n  next: [{ object: 'block' }, { object: 'inline' }],\n  normalize: function normalize(change, error) {\n    var code = error.code,\n        next = error.next;\n\n    if (code !== 'next_sibling_object_invalid') return;\n    change.mergeNodeByKey(next.key, { normalize: false });\n  }\n}];\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$10 = {\n  stack: Stack.create(),\n  rules: []\n\n  /**\n   * Schema.\n   *\n   * @type {Schema}\n   */\n\n};\nvar Schema = function (_Record) {\n  inherits(Schema, _Record);\n\n  function Schema() {\n    classCallCheck(this, Schema);\n    return possibleConstructorReturn(this, (Schema.__proto__ || Object.getPrototypeOf(Schema)).apply(this, arguments));\n  }\n\n  createClass(Schema, [{\n    key: 'validateNode',\n\n\n    /**\n     * Validate a `node` with the schema, returning an error if it's invalid.\n     *\n     * @param {Node} node\n     * @return {Error|Void}\n     */\n\n    value: function validateNode(node) {\n      var rules = this.rules.filter(function (r) {\n        return testRules(node, r.match);\n      });\n      var failure = validateRules(node, rules, this.rules, { every: true });\n      if (!failure) return;\n      var error = new SlateError(failure.code, failure);\n      return error;\n    }\n\n    /**\n     * Test whether a `node` is valid against the schema.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'testNode',\n    value: function testNode(node) {\n      var error = this.validateNode(node);\n      return !error;\n    }\n\n    /**\n     * Assert that a `node` is valid against the schema.\n     *\n     * @param {Node} node\n     * @throws\n     */\n\n  }, {\n    key: 'assertNode',\n    value: function assertNode(node) {\n      var error = this.validateNode(node);\n      if (error) throw error;\n    }\n\n    /**\n     * Normalize a `node` with the schema, returning a function that will fix the\n     * invalid node, or void if the node is valid.\n     *\n     * @param {Node} node\n     * @return {Function|Void}\n     */\n\n  }, {\n    key: 'normalizeNode',\n    value: function normalizeNode(node) {\n      var ret = this.stack.find('normalizeNode', node);\n      if (ret) return ret;\n      if (node.object == 'text') return;\n\n      var error = this.validateNode(node);\n      if (!error) return;\n\n      return function (change) {\n        debug$1('normalizing', { error: error });\n        var rule = error.rule;\n        var size = change.operations.size;\n\n        // First run the user-provided `normalize` function if one exists...\n\n        if (rule.normalize) {\n          rule.normalize(change, error);\n        }\n\n        // If the `normalize` function did not add any operations to the change\n        // object, it can't have normalized, so run the default one.\n        if (change.operations.size === size) {\n          defaultNormalize(change, error);\n        }\n      };\n    }\n\n    /**\n     * Return a JSON representation of the schema.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        rules: this.rules\n      };\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS() {\n      return this.toJSON();\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'schema';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Schema` with `attrs`.\n     *\n     * @param {Object|Schema} attrs\n     * @return {Schema}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Schema.isSchema(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Schema.fromJSON(attrs);\n      }\n\n      throw new Error('`Schema.create` only accepts objects or schemas, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Schema` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Schema}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Schema.isSchema(object)) {\n        return object;\n      }\n\n      var plugins = object.plugins ? object.plugins : [{ schema: object }];\n      var rules = [].concat(CORE_RULES);\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var plugin = _step.value;\n          var _plugin$schema = plugin.schema,\n              schema = _plugin$schema === undefined ? {} : _plugin$schema;\n          var _schema$blocks = schema.blocks,\n              blocks = _schema$blocks === undefined ? {} : _schema$blocks,\n              _schema$inlines = schema.inlines,\n              inlines = _schema$inlines === undefined ? {} : _schema$inlines;\n\n\n          if (schema.rules) {\n            rules = rules.concat(schema.rules);\n          }\n\n          if (schema.document) {\n            rules.push(_extends({\n              match: [{ object: 'document' }]\n            }, schema.document));\n          }\n\n          for (var key in blocks) {\n            rules.push(_extends({\n              match: [{ object: 'block', type: key }]\n            }, blocks[key]));\n          }\n\n          for (var _key in inlines) {\n            rules.push(_extends({\n              match: [{ object: 'inline', type: _key }]\n            }, inlines[_key]));\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var stack = Stack.create({ plugins: plugins });\n      var ret = new Schema({ stack: stack, rules: rules });\n      return ret;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }, {\n    key: 'isSchema',\n\n\n    /**\n     * Check if `any` is a `Schema`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isSchema(any) {\n      return !!(any && any[MODEL_TYPES.SCHEMA]);\n    }\n  }]);\n  return Schema;\n}(immutable.Record(DEFAULTS$10));\n\n/**\n * Normalize an invalid value with `error` with default remedies.\n *\n * @param {Change} change\n * @param {SlateError} error\n */\n\nSchema.fromJS = Schema.fromJSON;\nfunction defaultNormalize(change, error) {\n  switch (error.code) {\n    case slateSchemaViolations.CHILD_OBJECT_INVALID:\n    case slateSchemaViolations.CHILD_TYPE_INVALID:\n    case slateSchemaViolations.CHILD_UNKNOWN:\n    case slateSchemaViolations.FIRST_CHILD_OBJECT_INVALID:\n    case slateSchemaViolations.FIRST_CHILD_TYPE_INVALID:\n    case slateSchemaViolations.LAST_CHILD_OBJECT_INVALID:\n    case slateSchemaViolations.LAST_CHILD_TYPE_INVALID:\n      {\n        var child = error.child,\n            node = error.node;\n\n        return child.object == 'text' && node.object == 'block' && node.nodes.size == 1 ? change.removeNodeByKey(node.key) : change.removeNodeByKey(child.key);\n      }\n\n    case slateSchemaViolations.CHILD_REQUIRED:\n    case slateSchemaViolations.NODE_TEXT_INVALID:\n    case slateSchemaViolations.PARENT_OBJECT_INVALID:\n    case slateSchemaViolations.PARENT_TYPE_INVALID:\n      {\n        var _node = error.node;\n\n        return _node.object == 'document' ? _node.nodes.forEach(function (child) {\n          return change.removeNodeByKey(child.key);\n        }) : change.removeNodeByKey(_node.key);\n      }\n\n    case slateSchemaViolations.NODE_DATA_INVALID:\n      {\n        var _node2 = error.node,\n            key = error.key;\n\n        return _node2.data.get(key) === undefined && _node2.object != 'document' ? change.removeNodeByKey(_node2.key) : change.setNodeByKey(_node2.key, { data: _node2.data.delete(key) });\n      }\n\n    case slateSchemaViolations.NODE_IS_VOID_INVALID:\n      {\n        var _node3 = error.node;\n\n        return change.setNodeByKey(_node3.key, { isVoid: !_node3.isVoid });\n      }\n\n    case slateSchemaViolations.NODE_MARK_INVALID:\n      {\n        var _node4 = error.node,\n            mark = error.mark;\n\n        return _node4.getTexts().forEach(function (t) {\n          return change.removeMarkByKey(t.key, 0, t.text.length, mark);\n        });\n      }\n\n    default:\n      {\n        var _node5 = error.node;\n\n        return change.removeNodeByKey(_node5.key);\n      }\n  }\n}\n\n/**\n * Check that a `node` matches one of a set of `rules`.\n *\n * @param {Node} node\n * @param {Object|Array} rules\n * @return {Boolean}\n */\n\nfunction testRules(node, rules) {\n  var error = validateRules(node, rules);\n  return !error;\n}\n\n/**\n * Validate that a `node` matches a `rule` object or array.\n *\n * @param {Node} node\n * @param {Object|Array} rule\n * @param {Array|Void} rules\n * @return {Error|Void}\n */\n\nfunction validateRules(node, rule, rules) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$every = options.every,\n      every = _options$every === undefined ? false : _options$every;\n\n\n  if (Array.isArray(rule)) {\n    var array = rule.length ? rule : [{}];\n    var first = void 0;\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var r = _step2.value;\n\n        var _error = validateRules(node, r, rules);\n        first = first || _error;\n        if (every && _error) return _error;\n        if (!every && !_error) return;\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return first;\n  }\n\n  var error = validateObject(node, rule) || validateType(node, rule) || validateIsVoid(node, rule) || validateData(node, rule) || validateMarks(node, rule) || validateText(node, rule) || validateFirst(node, rule) || validateLast(node, rule) || validateNodes(node, rule, rules);\n\n  return error;\n}\n\nfunction validateObject(node, rule) {\n  if (rule.objects) {\n    logger.warn('The `objects` schema validation rule was changed. Please use the new `match` syntax with `object`.');\n  }\n\n  if (rule.object == null) return;\n  if (rule.object === node.object) return;\n  return fail(slateSchemaViolations.NODE_OBJECT_INVALID, { rule: rule, node: node });\n}\n\nfunction validateType(node, rule) {\n  if (rule.types) {\n    logger.warn('The `types` schema validation rule was changed. Please use the new `match` syntax with `type`.');\n  }\n\n  if (rule.type == null) return;\n  if (rule.type === node.type) return;\n  return fail(slateSchemaViolations.NODE_TYPE_INVALID, { rule: rule, node: node });\n}\n\nfunction validateIsVoid(node, rule) {\n  if (rule.isVoid == null) return;\n  if (rule.isVoid === node.isVoid) return;\n  return fail(slateSchemaViolations.NODE_IS_VOID_INVALID, { rule: rule, node: node });\n}\n\nfunction validateData(node, rule) {\n  if (rule.data == null) return;\n  if (node.data == null) return;\n\n  for (var key in rule.data) {\n    var fn = rule.data[key];\n    var value = node.data && node.data.get(key);\n    var valid = typeof fn === 'function' ? fn(value) : fn === value;\n    if (valid) continue;\n    return fail(slateSchemaViolations.NODE_DATA_INVALID, { rule: rule, node: node, key: key, value: value });\n  }\n}\n\nfunction validateMarks(node, rule) {\n  if (rule.marks == null) return;\n  var marks = node.getMarks().toArray();\n\n  var _loop = function _loop(mark) {\n    var valid = rule.marks.some(function (def) {\n      return def.type === mark.type;\n    });\n    if (valid) return 'continue';\n    return {\n      v: fail(slateSchemaViolations.NODE_MARK_INVALID, { rule: rule, node: node, mark: mark })\n    };\n  };\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = marks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var mark = _step3.value;\n\n      var _ret = _loop(mark);\n\n      switch (_ret) {\n        case 'continue':\n          continue;\n\n        default:\n          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n}\n\nfunction validateText(node, rule) {\n  if (rule.text == null) return;\n  var text = node.text;\n\n  var valid = rule.text.test(text);\n  if (valid) return;\n  return fail(slateSchemaViolations.NODE_TEXT_INVALID, { rule: rule, node: node, text: text });\n}\n\nfunction validateFirst(node, rule) {\n  if (rule.first == null) return;\n  var first = node.nodes.first();\n  if (!first) return;\n  var error = validateRules(first, rule.first);\n  if (!error) return;\n  error.rule = rule;\n  error.node = node;\n  error.child = first;\n  error.code = error.code.replace('node_', 'first_child_');\n  return error;\n}\n\nfunction validateLast(node, rule) {\n  if (rule.last == null) return;\n  var last = node.nodes.last();\n  if (!last) return;\n  var error = validateRules(last, rule.last);\n  if (!error) return;\n  error.rule = rule;\n  error.node = node;\n  error.child = last;\n  error.code = error.code.replace('node_', 'last_child_');\n  return error;\n}\n\nfunction validateNodes(node, rule) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (node.nodes == null) return;\n\n  var children = node.nodes.toArray();\n  var defs = rule.nodes != null ? rule.nodes.slice() : [];\n  var offset = void 0;\n  var min = void 0;\n  var index = void 0;\n  var def = void 0;\n  var max = void 0;\n  var child = void 0;\n  var previous = void 0;\n  var next = void 0;\n\n  function nextDef() {\n    offset = offset == null ? null : 0;\n    def = defs.shift();\n    min = def && def.min;\n    max = def && def.max;\n    return !!def;\n  }\n\n  function nextChild() {\n    index = index == null ? 0 : index + 1;\n    offset = offset == null ? 0 : offset + 1;\n    previous = child;\n    child = children[index];\n    next = children[index + 1];\n    if (max != null && offset == max) nextDef();\n    return !!child;\n  }\n\n  function rewind() {\n    offset -= 1;\n    index -= 1;\n  }\n\n  if (rule.nodes != null) {\n    nextDef();\n  }\n\n  while (nextChild()) {\n    var err = validateParent(node, child, rules) || validatePrevious(node, child, previous, index, rules) || validateNext(node, child, next, index, rules);\n\n    if (err) return err;\n\n    if (rule.nodes != null) {\n      if (!def) {\n        return fail(slateSchemaViolations.CHILD_UNKNOWN, { rule: rule, node: node, child: child, index: index });\n      }\n\n      if (def) {\n        if (def.objects) {\n          logger.warn('The `objects` schema validation rule was changed. Please use the new `match` syntax with `object`.');\n        }\n\n        if (def.types) {\n          logger.warn('The `types` schema validation rule was changed. Please use the new `match` syntax with `type`.');\n        }\n      }\n\n      if (def.match) {\n        var error = validateRules(child, def.match);\n\n        if (error && offset >= min && nextDef()) {\n          rewind();\n          continue;\n        }\n\n        if (error) {\n          error.rule = rule;\n          error.node = node;\n          error.child = child;\n          error.index = index;\n          error.code = error.code.replace('node_', 'child_');\n          return error;\n        }\n      }\n    }\n  }\n\n  if (rule.nodes != null) {\n    while (min != null) {\n      if (offset < min) {\n        return fail(slateSchemaViolations.CHILD_REQUIRED, { rule: rule, node: node, index: index });\n      }\n\n      nextDef();\n    }\n  }\n}\n\nfunction validateParent(node, child, rules) {\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = rules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var rule = _step4.value;\n\n      if (rule.parent == null) continue;\n      if (!testRules(child, rule.match)) continue;\n\n      var error = validateRules(node, rule.parent);\n      if (!error) continue;\n\n      error.rule = rule;\n      error.parent = node;\n      error.node = child;\n      error.code = error.code.replace('node_', 'parent_');\n      return error;\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\nfunction validatePrevious(node, child, previous, index, rules) {\n  if (!previous) return;\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = rules[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var rule = _step5.value;\n\n      if (rule.previous == null) continue;\n      if (!testRules(child, rule.match)) continue;\n\n      var error = validateRules(previous, rule.previous);\n      if (!error) continue;\n\n      error.rule = rule;\n      error.node = node;\n      error.child = child;\n      error.index = index;\n      error.previous = previous;\n      error.code = error.code.replace('node_', 'previous_sibling_');\n      return error;\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\n\nfunction validateNext(node, child, next, index, rules) {\n  if (!next) return;\n\n  var _iteratorNormalCompletion6 = true;\n  var _didIteratorError6 = false;\n  var _iteratorError6 = undefined;\n\n  try {\n    for (var _iterator6 = rules[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n      var rule = _step6.value;\n\n      if (rule.next == null) continue;\n      if (!testRules(child, rule.match)) continue;\n\n      var error = validateRules(next, rule.next);\n      if (!error) continue;\n\n      error.rule = rule;\n      error.node = node;\n      error.child = child;\n      error.index = index;\n      error.next = next;\n      error.code = error.code.replace('node_', 'next_sibling_');\n      return error;\n    }\n  } catch (err) {\n    _didIteratorError6 = true;\n    _iteratorError6 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion6 && _iterator6.return) {\n        _iterator6.return();\n      }\n    } finally {\n      if (_didIteratorError6) {\n        throw _iteratorError6;\n      }\n    }\n  }\n}\n\n/**\n * Create an interim failure object with `code` and `attrs`.\n *\n * @param {String} code\n * @param {Object} attrs\n * @return {Object}\n */\n\nfunction fail(code, attrs) {\n  return _extends({ code: code }, attrs);\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nSchema.prototype[MODEL_TYPES.SCHEMA] = true;\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$11 = {\n  data: new immutable.Map(),\n  decorations: null,\n  document: Document.create(),\n  history: History.create(),\n  schema: Schema.create(),\n  selection: Range.create()\n\n  /**\n   * Value.\n   *\n   * @type {Value}\n   */\n\n};\nvar Value = function (_Record) {\n  inherits(Value, _Record);\n\n  function Value() {\n    classCallCheck(this, Value);\n    return possibleConstructorReturn(this, (Value.__proto__ || Object.getPrototypeOf(Value)).apply(this, arguments));\n  }\n\n  createClass(Value, [{\n    key: 'change',\n\n\n    /**\n     * Create a new `Change` with the current value as a starting point.\n     *\n     * @param {Object} attrs\n     * @return {Change}\n     */\n\n    value: function change() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return new Change(_extends({}, attrs, { value: this }));\n    }\n\n    /**\n     * Add mark to text at `offset` and `length` in node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {Number} length\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'addMark',\n    value: function addMark(path, offset, length, mark) {\n      var value = this;\n      var _value = value,\n          document = _value.document;\n\n      document = document.addMark(path, offset, length, mark);\n      value = this.set('document', document);\n      return value;\n    }\n\n    /**\n     * Insert a `node`.\n     *\n     * @param {List|String} path\n     * @param {Node} node\n     * @return {Value}\n     */\n\n  }, {\n    key: 'insertNode',\n    value: function insertNode(path, node) {\n      var value = this;\n      var _value2 = value,\n          document = _value2.document;\n\n      document = document.insertNode(path, node);\n      value = value.set('document', document);\n\n      value = value.mapRanges(function (range) {\n        return range.merge({ anchorPath: null, focusPath: null });\n      });\n\n      return value;\n    }\n\n    /**\n     * Insert `text` at `offset` in node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {String} text\n     * @param {Set} marks\n     * @return {Value}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(path, offset, text, marks) {\n      var value = this;\n      var _value3 = value,\n          document = _value3.document;\n\n      document = document.insertText(path, offset, text, marks);\n      value = value.set('document', document);\n\n      // Update any ranges that were affected.\n      var node = document.assertNode(path);\n      value = value.clearAtomicRanges(node.key, offset);\n\n      value = value.mapRanges(function (range) {\n        var anchorKey = range.anchorKey,\n            anchorOffset = range.anchorOffset,\n            isBackward = range.isBackward,\n            isAtomic = range.isAtomic;\n\n\n        if (anchorKey === node.key && (anchorOffset > offset || anchorOffset === offset && (!isAtomic || !isBackward))) {\n          return range.moveAnchor(text.length);\n        }\n\n        return range;\n      });\n\n      value = value.mapRanges(function (range) {\n        var focusKey = range.focusKey,\n            focusOffset = range.focusOffset,\n            isBackward = range.isBackward,\n            isAtomic = range.isAtomic;\n\n\n        if (focusKey === node.key && (focusOffset > offset || focusOffset == offset && (!isAtomic || isBackward))) {\n          return range.moveFocus(text.length);\n        }\n\n        return range;\n      });\n\n      return value;\n    }\n\n    /**\n     * Merge a node backwards its previous sibling.\n     *\n     * @param {List|Key} path\n     * @return {Value}\n     */\n\n  }, {\n    key: 'mergeNode',\n    value: function mergeNode(path) {\n      var value = this;\n      var _value4 = value,\n          document = _value4.document;\n\n      var newDocument = document.mergeNode(path);\n      path = document.resolvePath(path);\n      var withPath = PathUtils.decrement(path);\n      var one = document.getNode(withPath);\n      var two = document.getNode(path);\n      value = value.set('document', newDocument);\n\n      value = value.mapRanges(function (range) {\n        if (two.object === 'text') {\n          var max = one.text.length;\n\n          if (range.anchorKey === two.key) {\n            range = range.moveAnchorTo(one.key, max + range.anchorOffset);\n          }\n\n          if (range.focusKey === two.key) {\n            range = range.moveFocusTo(one.key, max + range.focusOffset);\n          }\n        }\n\n        range = range.merge({ anchorPath: null, focusPath: null });\n        return range;\n      });\n\n      return value;\n    }\n\n    /**\n     * Move a node by `path` to `newPath`.\n     *\n     * A `newIndex` can be provided when move nodes by `key`, to account for not\n     * being able to have a key for a location in the tree that doesn't exist yet.\n     *\n     * @param {List|Key} path\n     * @param {List|Key} newPath\n     * @param {Number} newIndex\n     * @return {Value}\n     */\n\n  }, {\n    key: 'moveNode',\n    value: function moveNode(path, newPath) {\n      var newIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var value = this;\n      var _value5 = value,\n          document = _value5.document;\n\n      document = document.moveNode(path, newPath, newIndex);\n      value = value.set('document', document);\n\n      value = value.mapRanges(function (range) {\n        return range.merge({ anchorPath: null, focusPath: null });\n      });\n\n      return value;\n    }\n\n    /**\n     * Remove mark from text at `offset` and `length` in node.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {Number} length\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(path, offset, length, mark) {\n      var value = this;\n      var _value6 = value,\n          document = _value6.document;\n\n      document = document.removeMark(path, offset, length, mark);\n      value = this.set('document', document);\n      return value;\n    }\n\n    /**\n     * Remove a node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeNode',\n    value: function removeNode(path) {\n      var value = this;\n      var _value7 = value,\n          document = _value7.document;\n\n      var node = document.assertNode(path);\n      var first = node.object == 'text' ? node : node.getFirstText() || node;\n      var last = node.object == 'text' ? node : node.getLastText() || node;\n      var prev = document.getPreviousText(first.key);\n      var next = document.getNextText(last.key);\n\n      document = document.removeNode(path);\n      value = value.set('document', document);\n\n      value = value.mapRanges(function (range) {\n        var _range = range,\n            startKey = _range.startKey,\n            endKey = _range.endKey;\n\n\n        if (node.hasNode(startKey)) {\n          range = prev ? range.moveStartTo(prev.key, prev.text.length) : next ? range.moveStartTo(next.key, 0) : range.deselect();\n        }\n\n        if (node.hasNode(endKey)) {\n          range = prev ? range.moveEndTo(prev.key, prev.text.length) : next ? range.moveEndTo(next.key, 0) : range.deselect();\n        }\n\n        range = range.merge({ anchorPath: null, focusPath: null });\n        return range;\n      });\n\n      return value;\n    }\n\n    /**\n     * Remove `text` at `offset` in node by `path`.\n     *\n     * @param {List|Key} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(path, offset, text) {\n      var value = this;\n      var _value8 = value,\n          document = _value8.document;\n\n      document = document.removeText(path, offset, text);\n      value = value.set('document', document);\n\n      var node = document.assertNode(path);\n      var length = text.length;\n\n      var rangeOffset = offset + length;\n      value = value.clearAtomicRanges(node.key, offset, offset + length);\n\n      value = value.mapRanges(function (range) {\n        var anchorKey = range.anchorKey;\n\n\n        if (anchorKey === node.key) {\n          return range.anchorOffset >= rangeOffset ? range.moveAnchor(-length) : range.anchorOffset > offset ? range.moveAnchorTo(range.anchorKey, offset) : range;\n        }\n\n        return range;\n      });\n\n      value = value.mapRanges(function (range) {\n        var focusKey = range.focusKey;\n\n\n        if (focusKey === node.key) {\n          return range.focusOffset >= rangeOffset ? range.moveFocus(-length) : range.focusOffset > offset ? range.moveFocusTo(range.focusKey, offset) : range;\n        }\n\n        return range;\n      });\n\n      return value;\n    }\n\n    /**\n     * Set `properties` on a node.\n     *\n     * @param {List|String} path\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setNode',\n    value: function setNode(path, properties) {\n      var value = this;\n      var _value9 = value,\n          document = _value9.document;\n\n      document = document.setNode(path, properties);\n      value = value.set('document', document);\n      return value;\n    }\n\n    /**\n     * Set `properties` on `mark` on text at `offset` and `length` in node.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {Number} length\n     * @param {Mark} mark\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setMark',\n    value: function setMark(path, offset, length, mark, properties) {\n      var value = this;\n      var _value10 = value,\n          document = _value10.document;\n\n      document = document.setMark(path, offset, length, mark, properties);\n      value = value.set('document', document);\n      return value;\n    }\n\n    /**\n     * Set `properties` on the selection.\n     *\n     * @param {Value} value\n     * @param {Operation} operation\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setSelection',\n    value: function setSelection(properties) {\n      var value = this;\n      var _value11 = value,\n          document = _value11.document,\n          selection = _value11.selection;\n\n      selection = selection.merge(properties);\n      selection = selection.normalize(document);\n      value = value.set('selection', selection);\n      return value;\n    }\n\n    /**\n     * Split a node by `path` at `position` with optional `properties` to apply\n     * to the newly split node.\n     *\n     * @param {List|String} path\n     * @param {Number} position\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'splitNode',\n    value: function splitNode(path, position, properties) {\n      var value = this;\n      var _value12 = value,\n          document = _value12.document;\n\n      var newDocument = document.splitNode(path, position, properties);\n      var node = document.assertNode(path);\n      value = value.set('document', newDocument);\n\n      value = value.mapRanges(function (range) {\n        var next = newDocument.getNextText(node.key);\n        var _range2 = range,\n            startKey = _range2.startKey,\n            startOffset = _range2.startOffset,\n            endKey = _range2.endKey,\n            endOffset = _range2.endOffset;\n\n        // If the start was after the split, move it to the next node.\n\n        if (node.key === startKey && position <= startOffset) {\n          range = range.moveStartTo(next.key, startOffset - position);\n        }\n\n        // If the end was after the split, move it to the next node.\n        if (node.key === endKey && position <= endOffset) {\n          range = range.moveEndTo(next.key, endOffset - position);\n        }\n\n        range = range.merge({ anchorPath: null, focusPath: null });\n        return range;\n      });\n\n      return value;\n    }\n\n    /**\n     * Map all range objects to apply adjustments with an `iterator`.\n     *\n     * @param {Function} iterator\n     * @return {Value}\n     */\n\n  }, {\n    key: 'mapRanges',\n    value: function mapRanges(iterator) {\n      var value = this;\n      var _value13 = value,\n          document = _value13.document,\n          selection = _value13.selection,\n          decorations = _value13.decorations;\n\n\n      if (selection) {\n        var next = selection.isSet ? iterator(selection) : selection;\n        if (!next) next = selection.deselect();\n        if (next !== selection) next = next.normalize(document);\n        value = value.set('selection', next);\n      }\n\n      if (decorations) {\n        var _next = decorations.map(function (decoration) {\n          var n = decoration.isSet ? iterator(decoration) : decoration;\n          if (n && n !== decoration) n = n.normalize(document);\n          return n;\n        });\n\n        _next = _next.filter(function (decoration) {\n          return !!decoration;\n        });\n        _next = _next.size ? _next : null;\n        value = value.set('decorations', _next);\n      }\n\n      return value;\n    }\n\n    /**\n     * Remove any atomic ranges inside a `key`, `offset` and `length`.\n     *\n     * @param {String} key\n     * @param {Number} start\n     * @param {Number?} end\n     * @return {Value}\n     */\n\n  }, {\n    key: 'clearAtomicRanges',\n    value: function clearAtomicRanges(key, start) {\n      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      return this.mapRanges(function (range) {\n        var isAtomic = range.isAtomic,\n            startKey = range.startKey,\n            startOffset = range.startOffset,\n            endKey = range.endKey,\n            endOffset = range.endOffset;\n\n        if (!isAtomic) return range;\n        if (startKey !== key) return range;\n\n        if (startOffset < start && (endKey !== key || endOffset > start)) {\n          return null;\n        }\n\n        if (end != null && startOffset < end && (endKey !== key || endOffset > end)) {\n          return null;\n        }\n\n        return range;\n      });\n    }\n\n    /**\n     * Return a JSON representation of the value.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        document: this.document.toJSON(options)\n      };\n\n      if (options.preserveData) {\n        object.data = this.data.toJSON(options);\n      }\n\n      if (options.preserveDecorations) {\n        object.decorations = this.decorations ? this.decorations.toArray().map(function (d) {\n          return d.toJSON(options);\n        }) : null;\n      }\n\n      if (options.preserveHistory) {\n        object.history = this.history.toJSON(options);\n      }\n\n      if (options.preserveSelection) {\n        object.selection = this.selection.toJSON(options);\n      }\n\n      if (options.preserveSchema) {\n        object.schema = this.schema.toJSON(options);\n      }\n\n      return object;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS(options) {\n      return this.toJSON(options);\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'value';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n\n    /**\n     * Are there undoable events?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasUndos',\n    get: function get$$1() {\n      return this.history.undos.size > 0;\n    }\n\n    /**\n     * Are there redoable events?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasRedos',\n    get: function get$$1() {\n      return this.history.redos.size > 0;\n    }\n\n    /**\n     * Is the current selection blurred?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlurred',\n    get: function get$$1() {\n      return this.selection.isBlurred;\n    }\n\n    /**\n     * Is the current selection focused?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isFocused',\n    get: function get$$1() {\n      return this.selection.isFocused;\n    }\n\n    /**\n     * Is the current selection collapsed?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCollapsed',\n    get: function get$$1() {\n      return this.selection.isCollapsed;\n    }\n\n    /**\n     * Is the current selection expanded?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isExpanded',\n    get: function get$$1() {\n      return this.selection.isExpanded;\n    }\n\n    /**\n     * Is the current selection backward?\n     *\n     * @return {Boolean} isBackward\n     */\n\n  }, {\n    key: 'isBackward',\n    get: function get$$1() {\n      return this.selection.isBackward;\n    }\n\n    /**\n     * Is the current selection forward?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isForward',\n    get: function get$$1() {\n      return this.selection.isForward;\n    }\n\n    /**\n     * Get the current start key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startKey',\n    get: function get$$1() {\n      return this.selection.startKey;\n    }\n\n    /**\n     * Get the current end key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endKey',\n    get: function get$$1() {\n      return this.selection.endKey;\n    }\n\n    /**\n     * Get the current start path.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startPath',\n    get: function get$$1() {\n      return this.selection.startPath;\n    }\n\n    /**\n     * Get the current end path.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endPath',\n    get: function get$$1() {\n      return this.selection.endPath;\n    }\n\n    /**\n     * Get the current start offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startOffset',\n    get: function get$$1() {\n      return this.selection.startOffset;\n    }\n\n    /**\n     * Get the current end offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endOffset',\n    get: function get$$1() {\n      return this.selection.endOffset;\n    }\n\n    /**\n     * Get the current anchor key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'anchorKey',\n    get: function get$$1() {\n      return this.selection.anchorKey;\n    }\n\n    /**\n     * Get the current focus key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'focusKey',\n    get: function get$$1() {\n      return this.selection.focusKey;\n    }\n\n    /**\n     * Get the current anchor path.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'anchorPath',\n    get: function get$$1() {\n      return this.selection.anchorPath;\n    }\n\n    /**\n     * Get the current focus path.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'focusPath',\n    get: function get$$1() {\n      return this.selection.focusPath;\n    }\n\n    /**\n     * Get the current anchor offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'anchorOffset',\n    get: function get$$1() {\n      return this.selection.anchorOffset;\n    }\n\n    /**\n     * Get the current focus offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'focusOffset',\n    get: function get$$1() {\n      return this.selection.focusOffset;\n    }\n\n    /**\n     * Get the current start text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'startBlock',\n    get: function get$$1() {\n      return this.startKey && this.document.getClosestBlock(this.startKey);\n    }\n\n    /**\n     * Get the current end text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'endBlock',\n    get: function get$$1() {\n      return this.endKey && this.document.getClosestBlock(this.endKey);\n    }\n\n    /**\n     * Get the current anchor text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'anchorBlock',\n    get: function get$$1() {\n      return this.anchorKey && this.document.getClosestBlock(this.anchorKey);\n    }\n\n    /**\n     * Get the current focus text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'focusBlock',\n    get: function get$$1() {\n      return this.focusKey && this.document.getClosestBlock(this.focusKey);\n    }\n\n    /**\n     * Get the current start text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'startInline',\n    get: function get$$1() {\n      return this.startKey && this.document.getClosestInline(this.startKey);\n    }\n\n    /**\n     * Get the current end text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'endInline',\n    get: function get$$1() {\n      return this.endKey && this.document.getClosestInline(this.endKey);\n    }\n\n    /**\n     * Get the current anchor text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'anchorInline',\n    get: function get$$1() {\n      return this.anchorKey && this.document.getClosestInline(this.anchorKey);\n    }\n\n    /**\n     * Get the current focus text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'focusInline',\n    get: function get$$1() {\n      return this.focusKey && this.document.getClosestInline(this.focusKey);\n    }\n\n    /**\n     * Get the current start text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'startText',\n    get: function get$$1() {\n      return this.startKey && this.document.getDescendant(this.startKey);\n    }\n\n    /**\n     * Get the current end node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'endText',\n    get: function get$$1() {\n      return this.endKey && this.document.getDescendant(this.endKey);\n    }\n\n    /**\n     * Get the current anchor node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'anchorText',\n    get: function get$$1() {\n      return this.anchorKey && this.document.getDescendant(this.anchorKey);\n    }\n\n    /**\n     * Get the current focus node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'focusText',\n    get: function get$$1() {\n      return this.focusKey && this.document.getDescendant(this.focusKey);\n    }\n\n    /**\n     * Get the next block node.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'nextBlock',\n    get: function get$$1() {\n      return this.endKey && this.document.getNextBlock(this.endKey);\n    }\n\n    /**\n     * Get the previous block node.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'previousBlock',\n    get: function get$$1() {\n      return this.startKey && this.document.getPreviousBlock(this.startKey);\n    }\n\n    /**\n     * Get the next inline node.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'nextInline',\n    get: function get$$1() {\n      return this.endKey && this.document.getNextInline(this.endKey);\n    }\n\n    /**\n     * Get the previous inline node.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'previousInline',\n    get: function get$$1() {\n      return this.startKey && this.document.getPreviousInline(this.startKey);\n    }\n\n    /**\n     * Get the next text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'nextText',\n    get: function get$$1() {\n      return this.endKey && this.document.getNextText(this.endKey);\n    }\n\n    /**\n     * Get the previous text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'previousText',\n    get: function get$$1() {\n      return this.startKey && this.document.getPreviousText(this.startKey);\n    }\n\n    /**\n     * Get the characters in the current selection.\n     *\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'characters',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.List() : this.document.getCharactersAtRange(this.selection);\n    }\n\n    /**\n     * Get the marks of the current selection.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'marks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.Set() : this.selection.marks || this.document.getMarksAtRange(this.selection);\n    }\n\n    /**\n     * Get the active marks of the current selection.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'activeMarks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.Set() : this.selection.marks || this.document.getActiveMarksAtRange(this.selection);\n    }\n\n    /**\n     * Get the block nodes in the current selection.\n     *\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'blocks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.List() : this.document.getBlocksAtRange(this.selection);\n    }\n\n    /**\n     * Get the fragment of the current selection.\n     *\n     * @return {Document}\n     */\n\n  }, {\n    key: 'fragment',\n    get: function get$$1() {\n      return this.selection.isUnset ? Document.create() : this.document.getFragmentAtRange(this.selection);\n    }\n\n    /**\n     * Get the inline nodes in the current selection.\n     *\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'inlines',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.List() : this.document.getInlinesAtRange(this.selection);\n    }\n\n    /**\n     * Get the text nodes in the current selection.\n     *\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'texts',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.List() : this.document.getTextsAtRange(this.selection);\n    }\n\n    /**\n     * Check whether the selection is empty.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get$$1() {\n      if (this.isCollapsed) return true;\n      if (this.endOffset != 0 && this.startOffset != 0) return false;\n      return this.fragment.isEmpty;\n    }\n\n    /**\n     * Check whether the selection is collapsed in a void node.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInVoid',\n    get: function get$$1() {\n      if (this.isExpanded) return false;\n      return this.document.hasVoidParent(this.startKey);\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Value` with `attrs`.\n     *\n     * @param {Object|Value} attrs\n     * @param {Object} options\n     * @return {Value}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (Value.isValue(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Value.fromJSON(attrs, options);\n      }\n\n      throw new Error('`Value.create` only accepts objects or values, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a dictionary of settable value properties from `attrs`.\n     *\n     * @param {Object|Value} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Value.isValue(a)) {\n        return {\n          data: a.data,\n          decorations: a.decorations,\n          schema: a.schema\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('data' in a) p.data = Data.create(a.data);\n        if ('decorations' in a) p.decorations = Range.createList(a.decorations);\n        if ('schema' in a) p.schema = Schema.create(a.schema);\n        return p;\n      }\n\n      throw new Error('`Value.createProperties` only accepts objects or values, but you passed it: ' + a);\n    }\n\n    /**\n     * Create a `Value` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @param {Object} options\n     *   @property {Boolean} normalize\n     *   @property {Array} plugins\n     * @return {Value}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _object$document = object.document,\n          document = _object$document === undefined ? {} : _object$document,\n          _object$selection = object.selection,\n          selection = _object$selection === undefined ? {} : _object$selection,\n          _object$schema = object.schema,\n          schema = _object$schema === undefined ? {} : _object$schema,\n          _object$history = object.history,\n          history = _object$history === undefined ? {} : _object$history;\n\n      var data = new immutable.Map();\n      document = Document.fromJSON(document);\n      selection = Range.fromJSON(selection);\n      schema = Schema.fromJSON(schema);\n      history = History.fromJSON(history);\n\n      // Allow plugins to set a default value for `data`.\n      if (options.plugins) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = options.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var plugin = _step.value;\n\n            if (plugin.data) data = data.merge(plugin.data);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      // Then merge in the `data` provided.\n      if ('data' in object) {\n        data = data.merge(object.data);\n      }\n\n      if (selection.isUnset) {\n        var text = document.getFirstText();\n        if (text) selection = selection.collapseToStartOf(text);\n      }\n\n      selection = selection.normalize(document);\n\n      var value = new Value({\n        data: data,\n        document: document,\n        selection: selection,\n        schema: schema,\n        history: history\n      });\n\n      if (options.normalize !== false) {\n        value = value.change({ save: false }).normalize().value;\n      }\n\n      return value;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }, {\n    key: 'isValue',\n\n\n    /**\n     * Check if a `value` is a `Value`.\n     *\n     * @param {Any} value\n     * @return {Boolean}\n     */\n\n    value: function isValue(value) {\n      return !!(value && value[MODEL_TYPES.VALUE]);\n    }\n  }]);\n  return Value;\n}(immutable.Record(DEFAULTS$11));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nValue.fromJS = Value.fromJSON;\nValue.prototype[MODEL_TYPES.VALUE] = true;\n\n/**\n * Operation attributes.\n *\n * @type {Array}\n */\n\nvar OPERATION_ATTRIBUTES = {\n  add_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  insert_node: ['value', 'path', 'node'],\n  insert_text: ['value', 'path', 'offset', 'text', 'marks'],\n  merge_node: ['value', 'path', 'position', 'properties', 'target'],\n  move_node: ['value', 'path', 'newPath'],\n  remove_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  remove_node: ['value', 'path', 'node'],\n  remove_text: ['value', 'path', 'offset', 'text', 'marks'],\n  set_mark: ['value', 'path', 'offset', 'length', 'mark', 'properties'],\n  set_node: ['value', 'path', 'node', 'properties'],\n  set_selection: ['value', 'selection', 'properties'],\n  set_value: ['value', 'properties'],\n  split_node: ['value', 'path', 'position', 'properties', 'target']\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n};var DEFAULTS$12 = {\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  selection: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined,\n  value: undefined\n\n  /**\n   * Operation.\n   *\n   * @type {Operation}\n   */\n\n};\nvar Operation = function (_Record) {\n  inherits(Operation, _Record);\n\n  function Operation() {\n    classCallCheck(this, Operation);\n    return possibleConstructorReturn(this, (Operation.__proto__ || Object.getPrototypeOf(Operation)).apply(this, arguments));\n  }\n\n  createClass(Operation, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the operation.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var object = this.object,\n          type = this.type;\n\n      var json = { object: object, type: type };\n      var ATTRIBUTES = OPERATION_ATTRIBUTES[type];\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = ATTRIBUTES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n\n          var value = this[key];\n\n          // Skip keys for objects that should not be serialized, and are only used\n          // for providing the local-only invert behavior for the history stack.\n          if (key == 'document') continue;\n          if (key == 'selection') continue;\n          if (key == 'value') continue;\n          if (key == 'node' && type != 'insert_node') continue;\n\n          if (key == 'mark' || key == 'marks' || key == 'node') {\n            value = value.toJSON();\n          }\n\n          if (key == 'properties' && type == 'merge_node') {\n            var v = {};\n            if ('data' in value) v.data = value.data.toJS();\n            if ('type' in value) v.type = value.type;\n            value = v;\n          }\n\n          if (key == 'properties' && type == 'set_mark') {\n            var _v = {};\n            if ('data' in value) _v.data = value.data.toJS();\n            if ('type' in value) _v.type = value.type;\n            value = _v;\n          }\n\n          if (key == 'properties' && type == 'set_node') {\n            var _v2 = {};\n            if ('data' in value) _v2.data = value.data.toJS();\n            if ('isVoid' in value) _v2.isVoid = value.isVoid;\n            if ('type' in value) _v2.type = value.type;\n            value = _v2;\n          }\n\n          if (key == 'properties' && type == 'set_selection') {\n            var _v3 = {};\n            if ('anchorOffset' in value) _v3.anchorOffset = value.anchorOffset;\n            if ('anchorPath' in value) _v3.anchorPath = value.anchorPath && value.anchorPath.toJSON();\n            if ('focusOffset' in value) _v3.focusOffset = value.focusOffset;\n            if ('focusPath' in value) _v3.focusPath = value.focusPath && value.focusPath.toJSON();\n            if ('isBackward' in value) _v3.isBackward = value.isBackward;\n            if ('isFocused' in value) _v3.isFocused = value.isFocused;\n            if ('marks' in value) _v3.marks = value.marks && value.marks.toJSON();\n            value = _v3;\n          }\n\n          if (key == 'properties' && type == 'set_value') {\n            var _v4 = {};\n            if ('data' in value) _v4.data = value.data.toJS();\n            if ('decorations' in value) _v4.decorations = value.decorations.toJS();\n            if ('schema' in value) _v4.schema = value.schema.toJS();\n            value = _v4;\n          }\n\n          if (key == 'properties' && type == 'split_node') {\n            var _v5 = {};\n            if ('data' in value) _v5.data = value.data.toJS();\n            if ('type' in value) _v5.type = value.type;\n            value = _v5;\n          }\n\n          json[key] = value;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return json;\n    }\n\n    /**\n     * Alias `toJS`.\n     */\n\n  }, {\n    key: 'toJS',\n    value: function toJS(options) {\n      return this.toJSON(options);\n    }\n  }, {\n    key: 'object',\n\n\n    /**\n     * Object.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return 'operation';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Operation` with `attrs`.\n     *\n     * @param {Object|Array|List|String|Operation} attrs\n     * @return {Operation}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Operation.isOperation(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Operation.fromJSON(attrs);\n      }\n\n      throw new Error('`Operation.create` only accepts objects or operations, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Operations` from `elements`.\n     *\n     * @param {Array<Operation|Object>|List<Operation|Object>} elements\n     * @return {List<Operation>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Operation.create));\n        return list;\n      }\n\n      throw new Error('`Operation.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a `Operation` from a JSON `object`.\n     *\n     * @param {Object|Operation} object\n     * @return {Operation}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Operation.isOperation(object)) {\n        return object;\n      }\n\n      var type = object.type;\n\n      var ATTRIBUTES = OPERATION_ATTRIBUTES[type];\n      var attrs = { type: type };\n\n      if (!ATTRIBUTES) {\n        throw new Error('`Operation.fromJSON` was passed an unrecognized operation type: \"' + type + '\"');\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = ATTRIBUTES[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var key = _step2.value;\n\n          var v = object[key];\n\n          if (v === undefined) {\n            // Skip keys for objects that should not be serialized, and are only used\n            // for providing the local-only invert behavior for the history stack.\n            if (key == 'document') continue;\n            if (key == 'selection') continue;\n            if (key == 'value') continue;\n            if (key == 'node' && type != 'insert_node') continue;\n\n            throw new Error('`Operation.fromJSON` was passed a \"' + type + '\" operation without the required \"' + key + '\" attribute.');\n          }\n\n          if (key === 'path' || key === 'newPath') {\n            v = PathUtils.create(v);\n          }\n\n          if (key === 'mark') {\n            v = Mark.create(v);\n          }\n\n          if (key === 'marks' && v != null) {\n            v = Mark.createSet(v);\n          }\n\n          if (key === 'node') {\n            v = Node.create(v);\n          }\n\n          if (key === 'selection') {\n            v = Range.create(v);\n          }\n\n          if (key === 'value') {\n            v = Value.create(v);\n          }\n\n          if (key === 'properties' && type === 'merge_node') {\n            v = Node.createProperties(v);\n          }\n\n          if (key === 'properties' && type === 'set_mark') {\n            v = Mark.createProperties(v);\n          }\n\n          if (key === 'properties' && type === 'set_node') {\n            v = Node.createProperties(v);\n          }\n\n          if (key === 'properties' && type === 'set_selection') {\n            v = Range.createProperties(v);\n          }\n\n          if (key === 'properties' && type === 'set_value') {\n            v = Value.createProperties(v);\n          }\n\n          if (key === 'properties' && type === 'split_node') {\n            v = Node.createProperties(v);\n          }\n\n          attrs[key] = v;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var node = new Operation(attrs);\n      return node;\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }, {\n    key: 'isOperation',\n\n\n    /**\n     * Check if `any` is a `Operation`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n    value: function isOperation(any) {\n      return !!(any && any[MODEL_TYPES.OPERATION]);\n    }\n\n    /**\n     * Check if `any` is a list\u00a0of operations.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isOperationList',\n    value: function isOperationList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Operation.isOperation(item);\n      });\n    }\n  }]);\n  return Operation;\n}(immutable.Record(DEFAULTS$12));\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nOperation.fromJS = Operation.fromJSON;\nOperation.prototype[MODEL_TYPES.OPERATION] = true;\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$2 = Debug('slate:operation:invert');\n\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op);\n  var _op = op,\n      type = _op.type;\n\n  debug$2(type, op);\n\n  switch (type) {\n    case 'insert_node':\n      {\n        var inverse = op.set('type', 'remove_node');\n        return inverse;\n      }\n\n    case 'remove_node':\n      {\n        var _inverse = op.set('type', 'insert_node');\n        return _inverse;\n      }\n\n    case 'move_node':\n      {\n        var _op2 = op,\n            newPath = _op2.newPath,\n            path = _op2.path;\n\n        var inversePath = newPath;\n        var inverseNewPath = path;\n\n        var pathLast = path.size - 1;\n        var newPathLast = newPath.size - 1;\n\n        // If the node's old position was a left sibling of an ancestor of\n        // its new position, we need to adjust part of the path by -1.\n        if (path.size < inversePath.size && path.slice(0, pathLast).every(function (e, i) {\n          return e == inversePath.get(i);\n        }) && path.last() < inversePath.get(pathLast)) {\n          inversePath = inversePath.slice(0, pathLast).concat(inversePath.get(pathLast) - 1).concat(inversePath.slice(pathLast + 1, inversePath.size));\n        }\n\n        // If the node's new position is an ancestor of the old position,\n        // or a left sibling of an ancestor of its old position, we need\n        // to adjust part of the path by 1.\n        if (newPath.size < inverseNewPath.size && newPath.slice(0, newPathLast).every(function (e, i) {\n          return e == inverseNewPath.get(i);\n        }) && newPath.last() <= inverseNewPath.get(newPathLast)) {\n          inverseNewPath = inverseNewPath.slice(0, newPathLast).concat(inverseNewPath.get(newPathLast) + 1).concat(inverseNewPath.slice(newPathLast + 1, inverseNewPath.size));\n        }\n\n        var _inverse2 = op.set('path', inversePath).set('newPath', inverseNewPath);\n        return _inverse2;\n      }\n\n    case 'merge_node':\n      {\n        var _op3 = op,\n            _path = _op3.path;\n\n        var _inversePath = PathUtils.decrement(_path);\n        var _inverse3 = op.set('type', 'split_node').set('path', _inversePath);\n        return _inverse3;\n      }\n\n    case 'split_node':\n      {\n        var _op4 = op,\n            _path2 = _op4.path;\n\n        var _inversePath2 = PathUtils.increment(_path2);\n        var _inverse4 = op.set('type', 'merge_node').set('path', _inversePath2);\n        return _inverse4;\n      }\n\n    case 'set_node':\n      {\n        var _op5 = op,\n            properties = _op5.properties,\n            node = _op5.node;\n\n        var inverseNode = node.merge(properties);\n        var inverseProperties = pick(node, Object.keys(properties));\n        var _inverse5 = op.set('node', inverseNode).set('properties', inverseProperties);\n        return _inverse5;\n      }\n\n    case 'insert_text':\n      {\n        var _inverse6 = op.set('type', 'remove_text');\n        return _inverse6;\n      }\n\n    case 'remove_text':\n      {\n        var _inverse7 = op.set('type', 'insert_text');\n        return _inverse7;\n      }\n\n    case 'add_mark':\n      {\n        var _inverse8 = op.set('type', 'remove_mark');\n        return _inverse8;\n      }\n\n    case 'remove_mark':\n      {\n        var _inverse9 = op.set('type', 'add_mark');\n        return _inverse9;\n      }\n\n    case 'set_mark':\n      {\n        var _op6 = op,\n            _properties = _op6.properties,\n            mark = _op6.mark;\n\n        var inverseMark = mark.merge(_properties);\n        var _inverseProperties = pick(mark, Object.keys(_properties));\n        var _inverse10 = op.set('mark', inverseMark).set('properties', _inverseProperties);\n        return _inverse10;\n      }\n\n    case 'set_selection':\n      {\n        var _op7 = op,\n            _properties2 = _op7.properties,\n            selection = _op7.selection;\n\n        var inverseSelection = selection.merge(_properties2);\n        var inverseProps = pick(selection, Object.keys(_properties2));\n        var _inverse11 = op.set('selection', inverseSelection).set('properties', inverseProps);\n        return _inverse11;\n      }\n\n    case 'set_value':\n      {\n        var _op8 = op,\n            _properties3 = _op8.properties,\n            value = _op8.value;\n\n        var inverseValue = value.merge(_properties3);\n        var _inverseProperties2 = pick(value, Object.keys(_properties3));\n        var _inverse12 = op.set('value', inverseValue).set('properties', _inverseProperties2);\n        return _inverse12;\n      }\n\n    default:\n      {\n        throw new Error('Unknown operation type: \"' + type + '\".');\n      }\n  }\n}\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes$3 = {};\n\n/**\n * Redo to the next value in the history.\n *\n * @param {Change} change\n */\n\nChanges$3.redo = function (change) {\n  var value = change.value;\n  var _value = value,\n      history = _value.history;\n\n  if (!history) return;\n\n  var _history = history,\n      undos = _history.undos,\n      redos = _history.redos;\n\n  var next = redos.peek();\n  if (!next) return;\n\n  // Shift the next value into the undo stack.\n  redos = redos.pop();\n  undos = undos.push(next);\n\n  // Replay the next operations.\n  next.forEach(function (op) {\n    var _op = op,\n        type = _op.type,\n        properties = _op.properties;\n\n    // When the operation mutates the selection, omit its `isFocused` value to\n    // prevent the editor focus from changing during redoing.\n\n    if (type == 'set_selection') {\n      op = op.set('properties', omit(properties, 'isFocused'));\n    }\n\n    change.applyOperation(op, { save: false });\n  });\n\n  // Update the history.\n  value = change.value;\n  history = history.set('undos', undos).set('redos', redos);\n  value = value.set('history', history);\n  change.value = value;\n};\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Change} change\n */\n\nChanges$3.undo = function (change) {\n  var value = change.value;\n  var _value2 = value,\n      history = _value2.history;\n\n  if (!history) return;\n\n  var _history2 = history,\n      undos = _history2.undos,\n      redos = _history2.redos;\n\n  var previous = undos.peek();\n  if (!previous) return;\n\n  // Shift the previous operations into the redo stack.\n  undos = undos.pop();\n  redos = redos.push(previous);\n\n  // Replay the inverse of the previous operations.\n  previous.slice().reverse().map(invertOperation).forEach(function (inverse) {\n    var _inverse = inverse,\n        type = _inverse.type,\n        properties = _inverse.properties;\n\n    // When the operation mutates the selection, omit its `isFocused` value to\n    // prevent the editor focus from changing during undoing.\n\n    if (type == 'set_selection') {\n      inverse = inverse.set('properties', omit(properties, 'isFocused'));\n    }\n\n    change.applyOperation(inverse, { save: false });\n  });\n\n  // Update the history.\n  value = change.value;\n  history = history.set('undos', undos).set('redos', redos);\n  value = value.set('history', history);\n  change.value = value;\n};\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes$4 = {};\n\n/**\n * Set `properties` on the selection.\n *\n * @param {Change} change\n * @param {Object} properties\n */\n\nChanges$4.select = function (change, properties) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  properties = Range.createProperties(properties);\n\n  var _options$snapshot = options.snapshot,\n      snapshot = _options$snapshot === undefined ? false : _options$snapshot;\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var props = {};\n  var sel = selection.toJSON();\n  var next = selection.merge(properties).normalize(document);\n  properties = pick(next, Object.keys(properties));\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (var k in properties) {\n    if (snapshot == false && properties[k] == sel[k]) continue;\n    props[k] = properties[k];\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n  var moved = ['anchorKey', 'anchorOffset', 'focusKey', 'focusOffset'].some(function (p) {\n    return props.hasOwnProperty(p);\n  });\n\n  if (sel.marks && properties.marks == sel.marks && moved) {\n    props.marks = null;\n  }\n\n  // If there are no new properties to set, abort.\n  if (isEmpty(props)) {\n    return;\n  }\n\n  // Apply the operation.\n  change.applyOperation({\n    type: 'set_selection',\n    value: value,\n    properties: props,\n    selection: sel\n  }, snapshot ? { skip: false, merge: false } : {});\n};\n\n/**\n * Select the whole document.\n *\n * @param {Change} change\n */\n\nChanges$4.selectAll = function (change) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var next = selection.moveToRangeOf(document);\n  change.select(next);\n};\n\n/**\n * Snapshot the current selection.\n *\n * @param {Change} change\n */\n\nChanges$4.snapshotSelection = function (change) {\n  var value = change.value;\n  var selection = value.selection;\n\n  change.select(selection, { snapshot: true });\n};\n\n/**\n * Move the anchor point backward, accounting for being at the start of a block.\n *\n * @param {Change} change\n */\n\nChanges$4.moveAnchorCharBackward = function (change) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection,\n      anchorText = value.anchorText,\n      anchorBlock = value.anchorBlock;\n  var anchorOffset = selection.anchorOffset;\n\n  var previousText = document.getPreviousText(anchorText.key);\n  var isInVoid = document.hasVoidParent(anchorText.key);\n  var isPreviousInVoid = previousText && document.hasVoidParent(previousText.key);\n\n  if (!isInVoid && anchorOffset > 0) {\n    change.moveAnchor(-1);\n    return;\n  }\n\n  if (!previousText) {\n    return;\n  }\n\n  change.moveAnchorToEndOf(previousText);\n\n  if (!isInVoid && !isPreviousInVoid && anchorBlock.hasNode(previousText.key)) {\n    change.moveAnchor(-1);\n  }\n};\n\n/**\n * Move the anchor point forward, accounting for being at the end of a block.\n *\n * @param {Change} change\n */\n\nChanges$4.moveAnchorCharForward = function (change) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection,\n      anchorText = value.anchorText,\n      anchorBlock = value.anchorBlock;\n  var anchorOffset = selection.anchorOffset;\n\n  var nextText = document.getNextText(anchorText.key);\n  var isInVoid = document.hasVoidParent(anchorText.key);\n  var isNextInVoid = nextText && document.hasVoidParent(nextText.key);\n\n  if (!isInVoid && anchorOffset < anchorText.text.length) {\n    change.moveAnchor(1);\n    return;\n  }\n\n  if (!nextText) {\n    return;\n  }\n\n  change.moveAnchorToStartOf(nextText);\n\n  if (!isInVoid && !isNextInVoid && anchorBlock.hasNode(nextText.key)) {\n    change.moveAnchor(1);\n  }\n};\n\n/**\n * Move the focus point backward, accounting for being at the start of a block.\n *\n * @param {Change} change\n */\n\nChanges$4.moveFocusCharBackward = function (change) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection,\n      focusText = value.focusText,\n      focusBlock = value.focusBlock;\n  var focusOffset = selection.focusOffset;\n\n  var previousText = document.getPreviousText(focusText.key);\n  var isInVoid = document.hasVoidParent(focusText.key);\n  var isPreviousInVoid = previousText && document.hasVoidParent(previousText.key);\n\n  if (!isInVoid && focusOffset > 0) {\n    change.moveFocus(-1);\n    return;\n  }\n\n  if (!previousText) {\n    return;\n  }\n\n  change.moveFocusToEndOf(previousText);\n\n  if (!isInVoid && !isPreviousInVoid && focusBlock.hasNode(previousText.key)) {\n    change.moveFocus(-1);\n  }\n};\n\n/**\n * Move the focus point forward, accounting for being at the end of a block.\n *\n * @param {Change} change\n */\n\nChanges$4.moveFocusCharForward = function (change) {\n  var value = change.value;\n  var document = value.document,\n      selection = value.selection,\n      focusText = value.focusText,\n      focusBlock = value.focusBlock;\n  var focusOffset = selection.focusOffset;\n\n  var nextText = document.getNextText(focusText.key);\n  var isInVoid = document.hasVoidParent(focusText.key);\n  var isNextInVoid = nextText && document.hasVoidParent(nextText.key);\n\n  if (!isInVoid && focusOffset < focusText.text.length) {\n    change.moveFocus(1);\n    return;\n  }\n\n  if (!nextText) {\n    return;\n  }\n\n  change.moveFocusToStartOf(nextText);\n\n  if (!isInVoid && !isNextInVoid && focusBlock.hasNode(nextText.key)) {\n    change.moveFocus(1);\n  }\n};\n\n/**\n * Mix in move methods.\n */\n\nvar MOVE_DIRECTIONS = ['Forward', 'Backward'];\n\nMOVE_DIRECTIONS.forEach(function (direction$$1) {\n  var anchor = 'moveAnchorChar' + direction$$1;\n  var focus = 'moveFocusChar' + direction$$1;\n\n  Changes$4['moveChar' + direction$$1] = function (change) {\n    change[anchor]()[focus]();\n  };\n\n  Changes$4['moveStartChar' + direction$$1] = function (change) {\n    if (change.value.isBackward) {\n      change[focus]();\n    } else {\n      change[anchor]();\n    }\n  };\n\n  Changes$4['moveEndChar' + direction$$1] = function (change) {\n    if (change.value.isBackward) {\n      change[anchor]();\n    } else {\n      change[focus]();\n    }\n  };\n\n  Changes$4['extendChar' + direction$$1] = function (change) {\n    change['moveFocusChar' + direction$$1]();\n  };\n\n  Changes$4['collapseChar' + direction$$1] = function (change) {\n    var collapse = direction$$1 == 'Forward' ? 'collapseToEnd' : 'collapseToStart';\n    change[collapse]()['moveChar' + direction$$1]();\n  };\n});\n\n/**\n * Mix in alias methods.\n */\n\nvar ALIAS_METHODS$1 = [['collapseLineBackward', 'collapseToStartOfBlock'], ['collapseLineForward', 'collapseToEndOfBlock'], ['extendLineBackward', 'extendToStartOfBlock'], ['extendLineForward', 'extendToEndOfBlock']];\n\nALIAS_METHODS$1.forEach(function (_ref) {\n  var _ref2 = slicedToArray(_ref, 2),\n      alias = _ref2[0],\n      method = _ref2[1];\n\n  Changes$4[alias] = function (change) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    change[method].apply(change, [change].concat(args));\n  };\n});\n\n/**\n * Mix in selection changes that are just a proxy for the selection method.\n */\n\nvar PROXY_TRANSFORMS$1 = ['blur', 'collapseTo', 'collapseToAnchor', 'collapseToEnd', 'collapseToEndOf', 'collapseToFocus', 'collapseToStart', 'collapseToStartOf', 'extend', 'extendTo', 'extendToEndOf', 'extendToStartOf', 'flip', 'focus', 'move', 'moveAnchor', 'moveAnchorOffsetTo', 'moveAnchorTo', 'moveAnchorToEndOf', 'moveAnchorToStartOf', 'moveEnd', 'moveEndOffsetTo', 'moveEndTo', 'moveFocus', 'moveFocusOffsetTo', 'moveFocusTo', 'moveFocusToEndOf', 'moveFocusToStartOf', 'moveOffsetsTo', 'moveStart', 'moveStartOffsetTo', 'moveStartTo', 'moveTo', 'moveToEnd', 'moveToEndOf', 'moveToRangeOf', 'moveToStart', 'moveToStartOf', 'deselect'];\n\nPROXY_TRANSFORMS$1.forEach(function (method) {\n  Changes$4[method] = function (change) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var normalize = method != 'deselect';\n    var value = change.value;\n    var document = value.document,\n        selection = value.selection;\n\n    var next = selection[method].apply(selection, args);\n    if (normalize) next = next.normalize(document);\n    change.select(next);\n  };\n});\n\n/**\n * Mix in node-related changes.\n */\n\nvar PREFIXES = ['moveTo', 'moveAnchorTo', 'moveFocusTo', 'moveStartTo', 'moveEndTo', 'collapseTo', 'extendTo'];\n\nvar DIRECTIONS = ['Next', 'Previous'];\n\nvar OBJECTS = ['Block', 'Inline', 'Text'];\n\nPREFIXES.forEach(function (prefix) {\n  var edges = ['Start', 'End'];\n\n  if (prefix == 'moveTo') {\n    edges.push('Range');\n  }\n\n  edges.forEach(function (edge) {\n    var method = '' + prefix + edge + 'Of';\n\n    OBJECTS.forEach(function (object) {\n      var getNode = object == 'Text' ? 'getNode' : 'getClosest' + object;\n\n      Changes$4['' + method + object] = function (change) {\n        var value = change.value;\n        var document = value.document,\n            selection = value.selection;\n\n        var node = document[getNode](selection.startKey);\n        if (!node) return;\n        change[method](node);\n      };\n\n      DIRECTIONS.forEach(function (direction$$1) {\n        var getDirectionNode = 'get' + direction$$1 + object;\n        var directionKey = direction$$1 == 'Next' ? 'startKey' : 'endKey';\n\n        Changes$4['' + method + direction$$1 + object] = function (change) {\n          var value = change.value;\n          var document = value.document,\n              selection = value.selection;\n\n          var node = document[getNode](selection[directionKey]);\n          if (!node) return;\n          var target = document[getDirectionNode](node.key);\n          if (!target) return;\n          change[method](target);\n        };\n      });\n    });\n  });\n});\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes$5 = {};\n\n/**\n * Set `properties` on the value.\n *\n * @param {Change} change\n * @param {Object|Value} properties\n * @param {Object} options\n */\n\nChanges$5.setValue = function (change, properties) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  properties = Value.createProperties(properties);\n  var value = change.value;\n\n\n  change.applyOperation({\n    type: 'set_value',\n    properties: properties,\n    value: value\n  }, options);\n};\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nvar Changes$6 = {};\n\n/**\n * Normalize the value with its schema.\n *\n * @param {Change} change\n */\n\nChanges$6.normalize = function (change, options) {\n  change.normalizeDocument(options);\n};\n\n/**\n * Normalize the document with the value's schema.\n *\n * @param {Change} change\n */\n\nChanges$6.normalizeDocument = function (change, options) {\n  var value = change.value;\n  var document = value.document;\n\n  change.normalizeNodeByKey(document.key, options);\n};\n\n/**\n * Normalize a `node` and its children with the value's schema.\n *\n * @param {Change} change\n * @param {Node|String} key\n */\n\nChanges$6.normalizeNodeByKey = function (change, key) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  if (!normalize) return;\n\n  var value = change.value;\n  var document = value.document,\n      schema = value.schema;\n\n  var node = document.assertNode(key);\n\n  normalizeNodeAndChildren(change, node, schema);\n\n  change.normalizeAncestorsByKey(key);\n};\n\n/**\n * Normalize a node's ancestors by `key`.\n *\n * @param {Change} change\n * @param {String} key\n */\n\nChanges$6.normalizeAncestorsByKey = function (change, key) {\n  var value = change.value;\n  var document = value.document,\n      schema = value.schema;\n\n  var ancestors = document.getAncestors(key);\n  if (!ancestors) return;\n\n  ancestors.forEach(function (ancestor) {\n    if (change.value.document.getDescendant(ancestor.key)) {\n      normalizeNode(change, ancestor, schema);\n    }\n  });\n};\n\nChanges$6.normalizeParentByKey = function (change, key, options) {\n  var value = change.value;\n  var document = value.document;\n\n  var parent = document.getParent(key);\n  change.normalizeNodeByKey(parent.key, options);\n};\n\n/**\n * Normalize a `node` and its children with the value's schema.\n *\n * @param {Change} change\n * @param {Array} path\n */\n\nChanges$6.normalizeNodeByPath = function (change, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var normalize = change.getFlag('normalize', options);\n  if (!normalize) return;\n\n  var value = change.value;\n  var document = value.document,\n      schema = value.schema;\n\n  var node = document.assertNode(path);\n\n  normalizeNodeAndChildren(change, node, schema);\n\n  document = change.value.document;\n  var ancestors = document.getAncestors(path);\n  if (!ancestors) return;\n\n  ancestors.forEach(function (ancestor) {\n    if (change.value.document.getDescendant(ancestor.key)) {\n      normalizeNode(change, ancestor, schema);\n    }\n  });\n};\n\nChanges$6.normalizeParentByPath = function (change, path, options) {\n  var p = PathUtils.lift(path);\n  change.normalizeNodeByPath(p, options);\n};\n\n/**\n * Normalize a `node` and its children with a `schema`.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNodeAndChildren(change, node, schema) {\n  if (node.object == 'text') {\n    normalizeNode(change, node, schema);\n    return;\n  }\n\n  var child = node.getFirstInvalidDescendant(schema);\n  var path = change.value.document.getPath(node.key);\n\n  while (node && child) {\n    normalizeNodeAndChildren(change, child, schema);\n    node = change.value.document.refindNode(path, node.key);\n\n    if (!node) {\n      path = [];\n      child = null;\n    } else {\n      path = change.value.document.refindPath(path, node.key);\n      child = node.getFirstInvalidDescendant(schema);\n    }\n  }\n\n  // Normalize the node itself if it still exists.\n  if (node) {\n    normalizeNode(change, node, schema);\n  }\n}\n\n/**\n * Normalize a `node` with a `schema`, but not its children.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNode(change, node, schema) {\n  var max = schema.stack.plugins.length + schema.rules.length + 1;\n  var iterations = 0;\n\n  function iterate(c, n) {\n    var normalize = n.normalize(schema);\n    if (!normalize) return;\n\n    // Run the `normalize` function to fix the node.\n    var path = c.value.document.getPath(n.key);\n    normalize(c);\n\n    // Re-find the node reference, in case it was updated. If the node no longer\n    // exists, we're done for this branch.\n    n = c.value.document.refindNode(path, n.key);\n    if (!n) return;\n\n    path = c.value.document.refindPath(path, n.key);\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `normalize`\n    // function of a schema rule to be written incorrectly and for an infinite\n    // invalid loop to occur.\n    iterations++;\n\n    if (iterations > max) {\n      throw new Error('A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.');\n    }\n\n    // Otherwise, iterate again.\n    iterate(c, n);\n  }\n\n  iterate(change, node);\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar Changes$7 = _extends({}, Changes, Changes$1, Changes$2, Changes$3, Changes$4, Changes$5, Changes$6);\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$3 = Debug('slate:operation:apply');\n\n/**\n * Apply an `op` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} op\n * @return {Value} value\n */\n\nfunction applyOperation(value, op) {\n  op = Operation.create(op);\n  var _op = op,\n      type = _op.type;\n\n  debug$3(type, op);\n\n  switch (type) {\n    case 'add_mark':\n      {\n        var _op2 = op,\n            path = _op2.path,\n            offset = _op2.offset,\n            length = _op2.length,\n            mark = _op2.mark;\n\n        var next = value.addMark(path, offset, length, mark);\n        return next;\n      }\n\n    case 'insert_node':\n      {\n        var _op3 = op,\n            _path = _op3.path,\n            node = _op3.node;\n\n        var _next = value.insertNode(_path, node);\n        return _next;\n      }\n\n    case 'insert_text':\n      {\n        var _op4 = op,\n            _path2 = _op4.path,\n            _offset = _op4.offset,\n            text = _op4.text,\n            marks = _op4.marks;\n\n        var _next2 = value.insertText(_path2, _offset, text, marks);\n        return _next2;\n      }\n\n    case 'merge_node':\n      {\n        var _op5 = op,\n            _path3 = _op5.path;\n\n        var _next3 = value.mergeNode(_path3);\n        return _next3;\n      }\n\n    case 'move_node':\n      {\n        var _op6 = op,\n            _path4 = _op6.path,\n            newPath = _op6.newPath;\n\n        var _next4 = value.moveNode(_path4, newPath);\n        return _next4;\n      }\n\n    case 'remove_mark':\n      {\n        var _op7 = op,\n            _path5 = _op7.path,\n            _offset2 = _op7.offset,\n            _length = _op7.length,\n            _mark = _op7.mark;\n\n        var _next5 = value.removeMark(_path5, _offset2, _length, _mark);\n        return _next5;\n      }\n\n    case 'remove_node':\n      {\n        var _op8 = op,\n            _path6 = _op8.path;\n\n        var _next6 = value.removeNode(_path6);\n        return _next6;\n      }\n\n    case 'remove_text':\n      {\n        var _op9 = op,\n            _path7 = _op9.path,\n            _offset3 = _op9.offset,\n            _text = _op9.text;\n\n        var _next7 = value.removeText(_path7, _offset3, _text);\n        return _next7;\n      }\n\n    case 'set_mark':\n      {\n        var _op10 = op,\n            _path8 = _op10.path,\n            _offset4 = _op10.offset,\n            _length2 = _op10.length,\n            _mark2 = _op10.mark,\n            properties = _op10.properties;\n\n        var _next8 = value.setMark(_path8, _offset4, _length2, _mark2, properties);\n        return _next8;\n      }\n\n    case 'set_node':\n      {\n        var _op11 = op,\n            _path9 = _op11.path,\n            _properties = _op11.properties;\n\n        var _next9 = value.setNode(_path9, _properties);\n        return _next9;\n      }\n\n    case 'set_selection':\n      {\n        var _op12 = op,\n            _properties2 = _op12.properties;\n\n        var _next10 = value.setSelection(_properties2);\n        return _next10;\n      }\n\n    case 'set_value':\n      {\n        var _op13 = op,\n            _properties3 = _op13.properties;\n\n        var _next11 = value.merge(_properties3);\n        return _next11;\n      }\n\n    case 'split_node':\n      {\n        var _op14 = op,\n            _path10 = _op14.path,\n            position = _op14.position,\n            _properties4 = _op14.properties;\n\n        var _next12 = value.splitNode(_path10, position, _properties4);\n        return _next12;\n      }\n\n    default:\n      {\n        throw new Error('Unknown operation type: \"' + type + '\".');\n      }\n  }\n}\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$4 = Debug('slate:change');\n\n/**\n * Change.\n *\n * @type {Change}\n */\n\nvar Change = function () {\n\n  /**\n   * Create a new `Change` with `attrs`.\n   *\n   * @param {Object} attrs\n   *   @property {Value} value\n   */\n\n  function Change(attrs) {\n    classCallCheck(this, Change);\n    var value = attrs.value;\n\n    this.value = value;\n    this.operations = new immutable.List();\n\n    this.flags = _extends({\n      normalize: true\n    }, pick(attrs, ['merge', 'save', 'normalize']));\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  /**\n   * Check if `any` is a `Change`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  createClass(Change, [{\n    key: 'applyOperation',\n\n\n    /**\n     * Apply an `operation` to the current value, saving the operation to the\n     * history if needed.\n     *\n     * @param {Operation|Object} operation\n     * @param {Object} options\n     * @return {Change}\n     */\n\n    value: function applyOperation$$1(operation) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var operations = this.operations,\n          flags = this.flags;\n      var value = this.value;\n      var _value = value,\n          history = _value.history;\n\n      // Add in the current `value` in case the operation was serialized.\n\n      if (isPlainObject(operation)) {\n        operation = _extends({}, operation, { value: value });\n      }\n\n      operation = Operation.create(operation);\n\n      // Default options to the change-level flags, this allows for setting\n      // specific options for all of the operations of a given change.\n      options = _extends({}, flags, options);\n\n      // Derive the default option values.\n      var _options = options,\n          _options$merge = _options.merge,\n          merge = _options$merge === undefined ? operations.size == 0 ? null : true : _options$merge,\n          _options$save = _options.save,\n          save = _options$save === undefined ? true : _options$save,\n          _options$skip = _options.skip,\n          skip = _options$skip === undefined ? null : _options$skip;\n\n      // Apply the operation to the value.\n\n      debug$4('apply', { operation: operation, save: save, merge: merge });\n      value = applyOperation(value, operation);\n\n      // If needed, save the operation to the history.\n      if (history && save) {\n        history = history.save(operation, { merge: merge, skip: skip });\n        value = value.set('history', history);\n      }\n\n      // Update the mutable change object.\n      this.value = value;\n      this.operations = operations.push(operation);\n      return this;\n    }\n\n    /**\n     * Apply a series of `operations` to the current value.\n     *\n     * @param {Array|List} operations\n     * @param {Object} options\n     * @return {Change}\n     */\n\n  }, {\n    key: 'applyOperations',\n    value: function applyOperations(operations, options) {\n      var _this = this;\n\n      operations.forEach(function (op) {\n        return _this.applyOperation(op, options);\n      });\n      return this;\n    }\n\n    /**\n     * Call a change `fn` with arguments.\n     *\n     * @param {Function} fn\n     * @param {Mixed} ...args\n     * @return {Change}\n     */\n\n  }, {\n    key: 'call',\n    value: function call(fn) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      fn.apply(undefined, [this].concat(args));\n      return this;\n    }\n\n    /**\n     * Applies a series of change mutations, deferring normalization to the end.\n     *\n     * @param {Function} fn\n     * @return {Change}\n     */\n\n  }, {\n    key: 'withoutNormalization',\n    value: function withoutNormalization(fn) {\n      var original = this.flags.normalize;\n      this.setOperationFlag('normalize', false);\n      fn(this);\n      this.setOperationFlag('normalize', original);\n      this.normalizeDocument();\n      return this;\n    }\n\n    /**\n     * Set an operation flag by `key` to `value`.\n     *\n     * @param {String} key\n     * @param {Any} value\n     * @return {Change}\n     */\n\n  }, {\n    key: 'setOperationFlag',\n    value: function setOperationFlag(key, value) {\n      this.flags[key] = value;\n      return this;\n    }\n\n    /**\n     * Get the `value` of the specified flag by its `key`. Optionally accepts an `options`\n     * object with override flags.\n     *\n     * @param {String} key\n     * @param {Object} options\n     * @return {Change}\n     */\n\n  }, {\n    key: 'getFlag',\n    value: function getFlag(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      return options[key] !== undefined ? options[key] : this.flags[key];\n    }\n\n    /**\n     * Unset an operation flag by `key`.\n     *\n     * @param {String} key\n     * @return {Change}\n     */\n\n  }, {\n    key: 'unsetOperationFlag',\n    value: function unsetOperationFlag(key) {\n      delete this.flags[key];\n      return this;\n    }\n  }, {\n    key: 'object',\n    get: function get$$1() {\n      return 'change';\n    }\n  }, {\n    key: 'kind',\n    get: function get$$1() {\n      logger.deprecate('slate@0.32.0', 'The `kind` property of Slate objects has been renamed to `object`.');\n      return this.object;\n    }\n  }]);\n  return Change;\n}();\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nChange.isChange = isType.bind(null, 'CHANGE');\nChange.prototype[MODEL_TYPES.CHANGE] = true;\n\n/**\n * Add a change method for each of the changes.\n */\n\nObject.keys(Changes$7).forEach(function (type) {\n  Change.prototype[type] = function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    debug$4(type, { args: args });\n    this.call.apply(this, [Changes$7[type]].concat(args));\n    return this;\n  };\n});\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar Operations = {\n  apply: applyOperation,\n  invert: invertOperation\n};\n\nfunction setKeyGenerator(fn) {\n  logger.deprecate('0.35.0', 'The `setKeyGenerator()` util is deprecrated. Use the `KeyUtils.setGenerator()` helper instead.');\n\n  return KeyUtils.setGenerator(fn);\n}\n\nfunction resetKeyGenerator() {\n  logger.deprecate('0.35.0', 'The `resetKeyGenerator()` util is deprecrated. Use the `KeyUtils.resetGenerator()` helper instead.');\n\n  return KeyUtils.resetGenerator();\n}\n\nvar index = {\n  Block: Block,\n  Changes: Changes$7,\n  Character: Character,\n  Data: Data,\n  Document: Document,\n  History: History,\n  Inline: Inline,\n  KeyUtils: KeyUtils,\n  Leaf: Leaf,\n  Mark: Mark,\n  Node: Node,\n  Operation: Operation,\n  Operations: Operations,\n  PathUtils: PathUtils,\n  Range: Range,\n  resetKeyGenerator: resetKeyGenerator,\n  resetMemoization: resetMemoization,\n  Schema: Schema,\n  setKeyGenerator: setKeyGenerator,\n  Stack: Stack,\n  Text: Text,\n  TextUtils: TextUtils,\n  useMemoization: useMemoization,\n  Value: Value\n};\n\nexports.Block = Block;\nexports.Change = Change;\nexports.Changes = Changes$7;\nexports.Character = Character;\nexports.Data = Data;\nexports.Document = Document;\nexports.History = History;\nexports.Inline = Inline;\nexports.KeyUtils = KeyUtils;\nexports.Leaf = Leaf;\nexports.Mark = Mark;\nexports.Node = Node;\nexports.Operation = Operation;\nexports.Operations = Operations;\nexports.PathUtils = PathUtils;\nexports.Range = Range;\nexports.resetKeyGenerator = resetKeyGenerator;\nexports.resetMemoization = resetMemoization;\nexports.Schema = Schema;\nexports.setKeyGenerator = setKeyGenerator;\nexports.Stack = Stack;\nexports.Text = Text;\nexports.TextUtils = TextUtils;\nexports.useMemoization = useMemoization;\nexports.Value = Value;\nexports.default = index;\n//# sourceMappingURL=slate.js.map\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","_interopDefault","ex","isType","type","any","MODEL_TYPES","resetGenerator","n","generate","memoize","object","properties","_loop","property","original","Error","_len","arguments","length","args","Array","_key","ENABLED","apply","CACHE_KEY","__cache_key","__cache","Map","__cache_no_args","takesArguments","cachedValue","keys","concat","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","undefined","_iterator2","Symbol","iterator","_step2","done","next","map","get","value","err","return","LEAF","UNDEFINED","v","parent","child","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","key","set","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","resetMemoization","Number","MAX_SAFE_INTEGER","useMemoization","enabled","compare","a","b","size","i","av","bv","create$1","attrs","immutable","List","isList","isArray","crop","min","ca","slice","cb","increment","path","index","newPath","Math","getFirstText","node","getLastText","isSurrogate","code","SURROGATE_START","SURROGATE_END","isWord","char","remaining","SPACE","test","CHAMELEON","charAt","getCharLength","rest","PUNCTUATION","charCodeAt","getCharOffset","text","getWordOffset","started","l","defaultNormalize","change","error","slateSchemaViolations","CHILD_OBJECT_INVALID","CHILD_TYPE_INVALID","CHILD_UNKNOWN","FIRST_CHILD_OBJECT_INVALID","FIRST_CHILD_TYPE_INVALID","LAST_CHILD_OBJECT_INVALID","LAST_CHILD_TYPE_INVALID","nodes","removeNodeByKey","CHILD_REQUIRED","NODE_TEXT_INVALID","PARENT_OBJECT_INVALID","PARENT_TYPE_INVALID","_node","forEach","NODE_DATA_INVALID","_node2","data","setNodeByKey","delete","NODE_IS_VOID_INVALID","_node3","isVoid","NODE_MARK_INVALID","mark","getTexts","t","removeMarkByKey","validateRules","rule","rules","_options$every","every","options","array","first","_error","objects","logger","warn","fail","NODE_OBJECT_INVALID","types","NODE_TYPE_INVALID","fn","valid","replace","last","validateNodes","validateMarks","marks","getMarks","toArray","some","def","_ret","_typeof","nextDef","offset","defs","shift","max","nextChild","previous","children","validateParent","validatePrevious","validateNext","match","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_extends","invertOperation","op","Operation","create","debug$2","inverse","_inverse","_op2","inversePath","inverseNewPath","pathLast","newPathLast","e","_inverse2","_inversePath","_inverse3","PathUtils","decrement","_inversePath2","_inverse4","_op5","_inverse5","inverseNode","merge","inverseProperties","pick","Object","_inverse6","_inverse7","_inverse8","_inverse9","_op6","_inverse10","_properties","inverseMark","_inverseProperties","_op7","_inverse11","_properties2","selection","inverseSelection","inverseProps","_op8","_inverse12","_properties3","inverseValue","_inverseProperties2","normalizeNodeAndChildren","schema","normalizeNode","getFirstInvalidDescendant","document","getPath","refindNode","refindPath","iterate","c","normalize","iterations","stack","plugins","applyOperation","debug$3","addMark","insertNode","_next","_op3","insertText","_next2","_op4","mergeNode","_next3","moveNode","_next4","removeMark","_next5","removeNode","_next6","removeText","_next7","_op9","setMark","_next8","_op10","setNode","_next9","_op11","setSelection","_next10","_next11","splitNode","_next12","_op14","position","setKeyGenerator","deprecate","KeyUtils","setGenerator","resetKeyGenerator","defineProperty","isPlainObject","direction","esrever","Debug","isEqual","omit","isEmpty","BLOCK","CHANGE","CHARACTER","DOCUMENT","HISTORY","INLINE","MARK","OPERATION","RANGE","SCHEMA","STACK","TEXT","VALUE","func","obj","constructor","prototype","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","assign","source","hasOwnProperty","call","inherits","subClass","superClass","setPrototypeOf","__proto__","possibleConstructorReturn","self","ReferenceError","slicedToArray","arr","_arr","_n","_d","_e","_i","_s","push","toConsumableArray","arr2","from","DEFAULTS","Block","_Record","getPrototypeOf","toJSON","preserveKeys","toJS","get$$1","getText","isBlock","fromJSON","createList","list","_object$data","_object$isVoid","_object$key","_object$nodes","block","createChildren","isBlockList","item","Record","fromJS","bind","DEFAULTS$1","Inline","isInline","elements","inline","isInlineList","Data","isMap","DEFAULTS$2","Mark","getComponent","__getComponent","isMark","createSet","Set","isSet","createProperties","isMarkSet","Changes","PROXY_TRANSFORMS","method","collapseToStart","collapseToEnd","setBlock","Changes.setBlock","setBlocks","setInline","Changes.setInline","setInlines","Changes.addMark","isExpanded","addMarkAtRange","add","sel","select","_marks","getActiveMarksAtRange","_sel","addMarks","Changes.addMarks","Changes.delete","deleteAtRange","insertBlock","Changes.insertBlock","insertBlockAtRange","getNode","collapseToEndOf","insertFragment","Changes.insertFragment","fragment","_value","_value2","startText","endText","startInline","lastText","lastInline","getClosestInline","firstChild","lastChild","isAppending","hasEdgeAtStartOf","hasEdgeAtEndOf","isInserting","hasBlockChildren","insertFragmentAtRange","newTexts","filter","includes","newText","takeLast","collapseToStartOf","move","insertInline","Changes.insertInline","insertInlineAtRange","Changes.insertText","getInsertMarksAtRange","insertTextAtRange","splitBlock","Changes.splitBlock","depth","splitBlockAtRange","Changes.removeMark","removeMarkAtRange","remove","_marks2","_sel2","replaceMark","Changes.replaceMark","oldMark","newMark","toggleMark","Changes.toggleMark","activeMarks","has","exists","wrapText","Changes.wrapText","prefix","suffix","wrapTextAtRange","isCollapsed","moveStart","moveEnd","isForward","flip","DEFAULTS$3","Document","isDocument","isAbove","_crop","_crop2","p","isAfter","_crop3","_crop4","isBefore","_crop5","_crop6","lift","relate","Range","hasAnchorAtStartOf","anchorOffset","anchorKey","hasAnchorAtEndOf","hasAnchorBetween","start","end","hasAnchorIn","hasDescendant","hasFocusAtEndOf","focusKey","focusOffset","hasFocusAtStartOf","hasFocusBetween","hasFocusIn","isAtStartOf","isAtEndOf","focus","isFocused","blur","deselect","anchorPath","focusPath","isBackward","moveAnchor","moveFocus","moveAnchorTo","isAnchor","isFocus","_isAnchor","equals","_isFocus","moveFocusTo","_isAnchor2","_isFocus2","moveAnchorOffsetTo","moveFocusOffsetTo","moveOffsetsTo","moveToAnchor","moveToFocus","moveAnchorToStartOf","moveAnchorToEndOf","moveFocusToStartOf","moveFocusToEndOf","moveToRangeOf","range","anchorOffsetType","focusOffsetType","anchorNode","focusNode","anchorText","getTextAtOffset","getOffset","focusText","_offset","result","isAtomic","m","isRange","_object$anchorKey","_object$anchorOffset","_object$anchorPath","_object$focusKey","_object$focusOffset","_object$focusPath","_object$isAtomic","_object$isBackward","_object$isFocused","_object$marks","DEFAULTS$4","MOVE_METHODS","_ref","_ref2","s","_ref3","EDGE_METHODS","_ref4","_ref5","hasEdge","anchor","ALIAS_METHODS","_ref6","_ref7","alias","DEFAULTS$5","Character","isCharacter","split","character","isCharacterList","DEFAULTS$6","Leaf","getCharacters","characters","updateMark","newMarks","withMutations","collection","set$$1","union","isLeaf","createLeaves","leaves","invalid","cache","findLast","leaf","firstLeaf","unshift","splitLeaves","endOffset","left","right","find","startOffset","of","take","skip","_object$text","isLeafList","DEFAULTS$7","Text","getString","reduce","string","searchLeafAtOffset","newFirst","_Leaf$splitLeaves","_Leaf$splitLeaves2","before","_Leaf$splitLeaves3","bundle","_Leaf$splitLeaves4","after","middle","x","setLeaves","getDecorations","__getDecorations","getLeaves","_this2","decorations","hasStart","startKey","hasEnd","endKey","_Leaf$splitLeaves5","_Leaf$splitLeaves6","_Leaf$splitLeaves7","_Leaf$splitLeaves8","getActiveMarksBetweenOffsets","getActiveMarks","leafEnd","leafStart","intersect","_this3","getMarksBetweenOffsets","getMarksAsArray","OrderedSet","getMarksAtIndex","_searchLeafAtOffset","hasNode","_searchLeafAtOffset2","delta","beforeText","afterText","nextLeaves","splice","regenerateKey","_Leaf$splitLeaves9","_Leaf$splitLeaves10","_Leaf$splitLeaves11","_Leaf$splitLeaves12","_searchLeafAtOffset3","_leaves2","_Leaf$splitLeaves13","_Leaf$splitLeaves14","r","_Leaf$splitLeaves15","_Leaf$splitLeaves16","_Leaf$splitLeaves17","_Leaf$splitLeaves18","splitText","splitted","one","two","mergeText","validate","validateNode","flatMap","isText","_attrs","ranges","isTextList","Node","assertDescendant","resolvePath","replaceNode","ret","filterDescendants","matches","forEachDescendant","findDescendant","found","isUnset","getMarksAtPosition","_range","toSet","_range2","getDescendant","_endText","getPreviousText","getNextText","startMarks","endMarks","getAncestors","_this","ancestors","current","getBlocks","getBlocksAsArray","isLeafBlock","getBlocksAtRange","getBlocksAtRangeAsArray","_range3","startBlock","getClosestBlock","endBlock","blocks","indexOf","getBlocksByType","getBlocksByTypeAsArray","getCharactersAtRange","_range4","getTextsAtRange","getChild","getClosest","closest","getClosestVoid","getCommonAncestor","getDepth","startAt","descendant","getFragmentAtRange","_range5","getParent","_index","_position","startNode","getNextSibling","getFurthestAncestor","endNode","startIndex","endIndex","getFurthest","furthest","_len2","_key2","getFurthestBlock","getFurthestInline","getFurthestOnlyChildAncestor","reverse","takeUntil","getInlines","getInlinesAsArray","isLeafInline","getInlinesAtRange","getInlinesAtRangeAsArray","_this4","getTextsAtRangeAsArray","getInlinesByType","getInlinesByTypeAsArray","inlines","_range6","getKeysToPathsTable","nested","currentMarks","closestBlock","getMarksAtRange","getOrderedMarksAtRange","getMarksByType","getMarksByTypeAsArray","memo","getNextBlock","getNextNode","sibling","hasChild","getOffsetAtRange","_range7","getOrderedMarks","getOrderedMarksBetweenPositions","_range8","texts","getTextsBetweenPositionsAsArray","getOrderedMarksByType","parentPath","dict","getPreviousBlock","getPreviousNode","getPreviousSibling","getSelectionIndexes","isSelected","getTextDirection","dir","getTextsAsArray","_range9","_range10","hasInlineChildren","hasVoidParent","assertNode","mapChildren","_this5","mapDescendants","_this6","withPath","newNode","newIndex","newParentPath","_PathUtils$crop","_PathUtils$crop2","np","deep","deleteIn","setIn","_child$splitText","_child$splitText2","befores","afters","getNodeAtPath","getDescendantAtPath","getKeys","getKeysAsArray","areDescendantsSorted","second","_this7","k","firstIndex","secondIndex","isInRange","_range11","isNode","kind","isNodeList","ASSERTS","_len3","_key3","getOwnPropertyNames","TextUtils","getCharOffsetBackward","getCharOffsetForward","getWordOffsetBackward","o","getWordOffsetForward","Changes$1","Changes$1.addMarkAtRange","getFlag","addMarkByKey","Changes$1.addMarksAtRange","Changes$1.deleteAtRange","snapshotSelection","isStartVoid","isEndVoid","isHanging","prevText","startVoid","nextText","endVoid","_prevText","removeTextByKey","startLength","endLength","ancestor","startChild","endChild","startParent","startParentIndex","endParentIndex","startChildIndex","endChildIndex","middles","_parent","_index2","lonely","moveNodeByKey","mergeNodeByKey","normalizeNodeByKey","Changes$1.deleteCharBackwardAtRange","deleteBackwardAtRange","Changes$1.deleteLineBackwardAtRange","Changes$1.deleteWordBackwardAtRange","Changes$1.deleteBackwardAtRange","voidParent","prev","prevBlock","prevVoid","traversed","Changes$1.deleteCharForwardAtRange","deleteForwardAtRange","Changes$1.deleteLineForwardAtRange","Changes$1.deleteWordForwardAtRange","Changes$1.deleteForwardAtRange","nextBlock","moveToStartOf","_nextBlock","nextVoid","Changes$1.insertBlockAtRange","extra","insertNodeByKey","siblingText","atEnd","splitRange","moveToEndOf","splitDescendantsByKey","Changes$1.insertFragmentAtRange","collapseTo","isAtStart","firstBlock","lastBlock","lonelyChild","lonelyParent","nextNodes","skipUntil","lastIndex","inlineChild","inlineIndex","Changes$1.insertInlineAtRange","splitNodeByKey","Changes$1.insertTextAtRange","insertTextByKey","commonAncestor","normalizeAncestor","normalizeKey","Changes$1.removeMarkAtRange","Changes$1.setBlocksAtRange","sets","Changes$1.setBlockAtRange","setBlocksAtRange","Changes$1.setInlinesAtRange","Changes$1.setInlineAtRange","setInlinesAtRange","Changes$1.splitBlockAtRange","height","h","Changes$1.splitInlineAtRange","Infinity","Changes$1.toggleMarkAtRange","Changes$1.unwrapBlockAtRange","isSuperset","toOrderedSet","toList","wrappers","firstMatch","lastMatch","firstText","normalizeDocument","Changes$1.unwrapInlineAtRange","Changes$1.wrapBlockAtRange","clear","firstblock","lastblock","siblings","p1","p2","indexes","ind","Changes$1.wrapInlineAtRange","inlineParent","wrapInlineByKey","endInline","inlinekey","rng","startInner","startInnerIndex","endInner","startInlines","endInlines","Changes$1.wrapTextAtRange","Changes$2","Changes$2.addMarkByPath","operations","by","ax","ay","applyOperations","normalizeParentByPath","Changes$2.insertFragmentByPath","insertNodeByPath","normalizeNodeByPath","Changes$2.insertNodeByPath","Changes$2.insertTextByPath","Changes$2.mergeNodeByPath","Changes$2.moveNodeByPath","ancestorPath","Changes$2.removeMarkByPath","Changes$2.removeAllMarksByPath","state","Changes$2.removeNodeByPath","Changes$2.setTextByPath","replaceTextByPath","Changes$2.replaceTextByPath","removeTextByPath","activeMark","insertTextByPath","Changes$2.removeTextByPath","removals","Changes$2.replaceNodeByPath","removeNodeByPath","Changes$2.setMarkByPath","Changes$2.setNodeByPath","Changes$2.splitNodeByPath","_options$target","Changes$2.splitDescendantsByPath","textPath","textOffset","splitNodeByPath","prevIndex","Changes$2.unwrapInlineByPath","unwrapInlineAtRange","Changes$2.unwrapBlockByPath","unwrapBlockAtRange","Changes$2.unwrapNodeByPath","parentIndex","grandPath","isFirst","isLast","moveNodeByPath","updatedPath","Changes$2.wrapBlockByPath","Changes$2.wrapInlineByPath","Changes$2.wrapNodeByPath","wrapBlockByPath","wrapInlineByPath","CHANGES","_loop$1","assertPath","Changes$2.moveNodeByKey","newKey","Changes$2.splitDescendantsByKey","textKey","splitDescendantsByPath","debug","DEFAULTS$8","redos","Stack","undos","History","save","operation","history","_history","prevBatch","peek","prevOperation","batch","pop","_batch","isHistory","createOperationsList","_object$redos","_object$undos","getPluginsWith","plugin","run","render","_len4","_key4","reduceRight","_attrs$plugins","isStack","DEFAULTS$9","SlateError","_Error","captureStackTrace","debug$1","CORE_RULES","DEFAULTS$10","Schema","failure","testNode","isSchema","_plugin$schema","_schema$blocks","_schema$inlines","DEFAULTS$11","Value","Change","mapRanges","clearAtomicRanges","newDocument","moveStartTo","moveEndTo","rangeOffset","_value11","_value13","decoration","preserveData","preserveDecorations","d","preserveHistory","preserveSelection","preserveSchema","isBlurred","startPath","endPath","getNextInline","getPreviousInline","isValue","_object$document","_object$selection","_object$schema","_object$history","OPERATION_ATTRIBUTES","add_mark","insert_node","insert_text","merge_node","move_node","remove_mark","remove_node","remove_text","set_mark","set_node","set_selection","set_value","split_node","json","ATTRIBUTES","_v","_v2","_v3","_v4","_v5","isOperation","isOperationList","DEFAULTS$12","Changes$4","Changes$4.select","_options$snapshot","snapshot","moved","Changes$4.selectAll","Changes$4.snapshotSelection","Changes$4.moveAnchorCharBackward","anchorBlock","previousText","isInVoid","isPreviousInVoid","Changes$4.moveAnchorCharForward","isNextInVoid","Changes$4.moveFocusCharBackward","focusBlock","Changes$4.moveFocusCharForward","MOVE_DIRECTIONS","direction$$1","collapse","ALIAS_METHODS$1","PROXY_TRANSFORMS$1","DIRECTIONS","OBJECTS","PREFIXES","edges","edge","getDirectionNode","directionKey","Changes$7","Changes$3","Changes$3.redo","_op","Changes$3.undo","_history2","Changes$5","Changes$5.setValue","Changes$6","Changes$6.normalize","Changes$6.normalizeDocument","Changes$6.normalizeNodeByKey","normalizeAncestorsByKey","Changes$6.normalizeAncestorsByKey","Changes$6.normalizeParentByKey","Changes$6.normalizeNodeByPath","Changes$6.normalizeParentByPath","debug$4","flags","applyOperation$$1","_options","_options$merge","_options$save","_options$skip","withoutNormalization","setOperationFlag","unsetOperationFlag","isChange","Operations","invert","default"]
}
